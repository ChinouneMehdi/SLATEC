MODULE TEST10_MOD
  USE service, ONLY : SP, DP
  IMPLICIT NONE

CONTAINS
  !** ZQCAI
  SUBROUTINE ZQCAI(Lun,Kprint,Ipass)
    !> Quick check for SLATEC subroutines
    !            ZAIRY, ZBIRY
    !***
    ! **Library:**   SLATEC
    !***
    ! **Category:**  C10D
    !***
    ! **Type:**      COMPLEX (CQCAI-C, ZQCAI-Z)
    !***
    ! **Keywords:**  QUICK CHECK, ZAIRY, ZBIRY
    !***
    ! **Author:**  Amos, Don, (SNL)
    !           Goudy, Sue, (SNL)
    !           Walton, Lee, (SNL)
    !***
    ! **Description:**
    !
    !- Usage:
    !
    !        INTEGER  LUN, KPRINT, IPASS
    !
    !        CALL ZQCAI (LUN, KPRINT, IPASS)
    !
    !- Arguments:
    !
    !     LUN    :IN  is the unit number to which output is to be written.
    !
    !     KPRINT :IN  controls the amount of output, as specified in the
    !                 SLATEC Guidelines.
    !
    !     IPASS  :OUT indicates whether the test passed or failed.
    !                 A value of one is good, indicating no failures.
    !
    !- Description:
    !
    !               *** A DOUBLE PRECISION ROUTINE ***
    !
    !   ZQCAI is a quick check routine for the complex Airy functions
    !    generated by subroutines ZAIRY and ZBIRY.
    !
    !   ZQCAI generates Airy functions and their derivatives from ZAIRY
    !    and ZBIRY and checks them against the Wronskian evaluation
    !    in the Z plane.
    !
    !***
    ! **References:**  Abramowitz, M. and Stegun, I. A., Handbook
    !                 of Mathematical Functions, Dover Publications,
    !                 New York, 1964.
    !               Amos, D. E., A Subroutine Package for Bessel
    !                 Functions of a Complex Argument and Nonnegative
    !                 Order, SAND85-1018, May, 1985.
    !***
    ! **Routines called:**  ZAIRY, ZBIRY, ZABS, ZSQRT, ZEXP, I1MACH, D1MACH

    !* REVISION HISTORY  (YYMMDD)
    !   830501  DATE WRITTEN
    !   890831  Revised to meet new SLATEC standards
    !   930122  Added ZEXP and ZSQRT to EXTERNAL statement.  (RWC)
    USE slatec, ONLY : ZAIRY, ZBIRY, ZABS, ZSQRT, ZEXP, I1MACH, D1MACH
    !
    !*Internal Notes:
    !   Machine constants are defined by functions I1MACH and D1MACH.
    !
    !   The parameter MQC can have values 1 (the default) for a faster,
    !   less definitive test or 2 for a slower, more definitive test.
    !
    !**End
    !
    !  Set test complexity parameter.
    INTEGER, PARAMETER :: MQC = 1
    !  Declare arguments.
    !
    INTEGER :: Lun, Kprint, Ipass
    !
    !  Declare local variables.
    !
    REAL(DP) :: con1r, con1i, con2r, con2i, con3r, con3i, cvr, &
      cvi, cwr, cwi, cyr, cyi, wr(20), wi(20), yr(20), yi(20), zr, zi, zrr, zri
    REAL(DP) :: aa, ab, acw, acy, alim, arg, atol, av, azrr, &
      a1, a2, ct, c23, dig, elim, eps, er, ertol, &
      film, fnul, fpi, hpi, pi, pi3, ptr, r, rl, rm, &
      rpi, rtpi, r1m4, r1m5, slak, spi, st, sti, str, t(20), tol, tpi, tpi3, ts
    INTEGER :: i, icase, icl, ierr, il, ir, irb, irset, it, itl, k, &
      kdo(20), keps(20), kode, k1, k2, lflg, nz1, nz2, nz3, nz4
    !
    !* FIRST EXECUTABLE STATEMENT  ZQCAI
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99001)
      99001 FORMAT (' QUICK CHECK ROUTINE FOR THE AIRY FUNCTIONS FROM ',&
        'ZAIRY AND ZBIRY'/)
    END IF
    !-----------------------------------------------------------------------
    !     Set parameters related to machine constants.
    !     TOL is the approximate unit roundoff limited to 1.0D-18.
    !     ELIM is the approximate exponential over- and underflow limit.
    !     exp(-ELIM)<exp(-ALIM)=exp(-ELIM)/TOL    and
    !     exp(ELIM)>exp(ALIM)=exp(ELIM)*TOL       are intervals near
    !     underflow and overflow limits where scaled arithmetic is done.
    !     RL is the lower boundary of the asymptotic expansion for large Z.
    !     DIG = number of base 10 digits in TOL = 10**(-DIG).
    !     FNUL is the lower boundary of the asymptotic series for large FNU.
    !-----------------------------------------------------------------------
    r1m4 = D1MACH(4)
    tol = MAX(r1m4,1.E-18_DP)
    atol = 100._DP*tol
    aa = -LOG10(r1m4)
    k1 = I1MACH(12)
    k2 = I1MACH(13)
    r1m5 = D1MACH(5)
    k = MIN(ABS(k1),ABS(k2))
    elim = 2.303_DP*(k*r1m5-3._DP)
    ab = aa*2.303_DP
    alim = elim + MAX(-ab,-41.45_DP)
    dig = MIN(aa,18._DP)
    slak = 3._DP + 4._DP*(-LOG10(tol)-7._DP)/11._DP
    slak = MAX(slak,3._DP)
    ertol = tol*10._DP**slak
    rl = 1.2_DP*dig + 3._DP
    rm = 0.5_DP*(alim+elim)
    rm = MIN(rm,200._DP)
    rm = MAX(rm,rl+10._DP)
    fnul = 10._DP + 6._DP*(dig-3._DP)
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99002)
      99002 FORMAT (' PARAMETERS'/5X,'TOL ',8X,'ELIM',8X,'ALIM',8X,'RL  ',8X,'FNUL',&
        8X,'DIG')
      WRITE (Lun,99003) tol, elim, alim, rl, fnul, dig
      99003 FORMAT (6D12.4/)
    END IF
    !-----------------------------------------------------------------------
    !     Generate angles for construction of complex Z to be used in tests.
    !-----------------------------------------------------------------------
    fpi = ATAN(1._DP)
    hpi = fpi + fpi
    pi = hpi + hpi
    tpi = pi + pi
    rpi = 1._DP/pi
    tpi3 = tpi/3._DP
    spi = pi/6._DP
    pi3 = spi + spi
    rtpi = 1._DP/tpi
    a1 = rtpi*COS(spi)
    a2 = rtpi*SIN(spi)
    con1r = COS(tpi3)
    con1i = SIN(tpi3)
    con2r = a1
    con2i = -a2
    con3r = rpi
    con3i = 0._DP
    c23 = 2._DP/3._DP
    !-----------------------------------------------------------------------
    !     KDO(K), K = 1,IL  determines which of the IL angles in -PI to PI
    !     are used to compute values of Z.
    !       KDO(K) = 0  means that the index K will be used for one or two
    !                   values of Z, depending on the choice of KEPS(K)
    !              = 1  means that the index K and the corresponding angle
    !                   will be skipped
    !     KEPS(K), K = 1,IL determines which of the angles get incremented
    !     up and down to put values of Z in regions where different
    !     formulae are used.
    !       KEPS(K)  = 0  means that the angle will be used without change
    !                = 1  means that the angle will be incremented up and
    !                   down by EPS
    !     The angles to be used are stored in the T(I) array, I = 1,ITL.
    !-----------------------------------------------------------------------
    IF( MQC/=2 ) THEN
      icl = 1
      il = 5
      DO i = 1, il
        kdo(i) = 0
        keps(i) = 0
      END DO
    ELSE
      icl = 2
      il = 7
      DO i = 1, il
        kdo(i) = 0
        keps(i) = 0
      END DO
      keps(2) = 1
      keps(3) = 1
      keps(5) = 1
      keps(6) = 1
    END IF
    i = 2
    eps = 0.01_DP
    film = il - 1
    t(1) = -pi + eps
    DO k = 2, il
      IF( kdo(k)==0 ) THEN
        t(i) = pi*(-il+2*k-1)/film
        IF( keps(k)/=0 ) THEN
          ts = t(i)
          t(i) = ts - eps
          i = i + 1
          t(i) = ts + eps
        END IF
        i = i + 1
      END IF
    END DO
    itl = i - 1
    !-----------------------------------------------------------------------
    !     Test values of Z in -PI<arg(Z)<=PI near formula boundaries.
    !-----------------------------------------------------------------------
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99004)
      99004 FORMAT (' CHECKS IN THE Z PLANE'/)
    END IF
    lflg = 0
    DO icase = 1, icl
      !-----------------------------------------------------------------------
      !     ICASE = 1 computes wron(AI(Z),BI(Z))     =CON3
      !     ICASE = 2 computes wron(AI(Z),AI(Z*CON1))=CON2
      !-----------------------------------------------------------------------
      DO kode = 1, 2
        DO irset = 1, 3
          irb = MIN(irset,2)
          DO ir = irb, 4
            !------------ switch (irset)
            SELECT CASE (irset)
              CASE (2)
                r = (2._DP*(4-ir)+rl*(ir-1))/3._DP
              CASE (3)
                r = (rl*(4-ir)+rm*(ir-1))/3._DP
              CASE DEFAULT
                r = 2._DP*(ir-1)/3._DP
            END SELECT
            !------------ end switch
            DO it = 1, itl
              !----------------------------------------------------------------------
              !     The following values are set before the DO 30 loop:
              !            C23 = 2/3
              !           CON1 = cmplx(cos(2PI/3),sin(2PI/3))
              !           CON2 = cmplx(cos(PI/6),-sin(PI/6)/2PI
              !           CON3 = cmplx(1/PI,0)
              !----------------------------------------------------------------------
              ct = COS(t(it))
              st = SIN(t(it))
              IF( ABS(ct)<atol ) ct = 0._DP
              IF( ABS(st)<atol ) st = 0._DP
              zr = r*ct
              zi = r*st
              CALL ZSQRT(zr,zi,str,sti)
              ptr = (zr*str-zi*sti)*c23
              zri = (zr*sti+zi*str)*c23
              zrr = ptr
              azrr = ABS(zrr)
              !-------------- Check for possible underflow or overflow
              IF( azrr/=0._DP ) THEN
                arg = -azrr - 0.5_DP*LOG(azrr) + 0.226_DP
                arg = arg + arg
                !---------------- Skip test for this case?
                IF( arg<(-elim) ) CYCLE
              END IF
              CALL ZAIRY(zr,zi,0,kode,yr(1),yi(1),nz1,ierr)
              CALL ZAIRY(zr,zi,1,kode,yr(2),yi(2),nz2,ierr)
              IF( icase==1 ) THEN
                !---------------- Compare 1/PI with Wronskian of ZAIRY(Z) and ZBIRY(Z).
                CALL ZBIRY(zr,zi,0,kode,wr(1),wi(1),ierr)
                CALL ZBIRY(zr,zi,1,kode,wr(2),wi(2),ierr)
                IF( kode==2 ) THEN
                  !-----------------------------------------------------------------------
                  !     When KODE = 2, the scaling factor exp(-zeta1-zeta2) is 1.0 for
                  !     -PI<arg(Z)<=PI/3 and exp(-2.0*zeta1) for PI/3<arg(Z)
                  !     <=PI where zeta1 = zeta2 in this range. This is due to the fact
                  !     that arg(Z*CON1) is taken to be in (-PI,PI) by the principal
                  !     square root.
                  !-----------------------------------------------------------------------
                  !------------------ Adjust scaling factor.
                  cvr = azrr - zrr
                  cvi = -zri
                  CALL ZEXP(cvr,cvi,cvr,cvi)
                  str = wr(1)*cvr - wi(1)*cvi
                  wi(1) = wr(1)*cvi + wi(1)*cvr
                  wr(1) = str
                  str = wr(2)*cvr - wi(2)*cvi
                  wi(2) = wr(2)*cvi + wi(2)*cvr
                  wr(2) = str
                END IF
                cvr = con3r
                cvi = con3i
              ELSE
                !---------------- Compare exp(-i*PI/6)/2PI with Wronskian of ZAIRY(Z)
                !                 and ZAIRY(Z*exp(2i*PI/3)).
                cvr = zr*con1r - zi*con1i
                cvi = zr*con1i + zi*con1r
                CALL ZAIRY(cvr,cvi,0,kode,wr(1),wi(1),nz3,ierr)
                CALL ZAIRY(cvr,cvi,1,kode,wr(2),wi(2),nz4,ierr)
                IF( kode==2 ) THEN
                  IF( t(it)>=pi3 ) THEN
                    !-------------------- Adjust scaling factor.
                    cvr = zrr + zrr
                    cvi = zri + zri
                    CALL ZEXP(-cvr,-cvi,cvr,cvi)
                    str = wr(1)*cvr - wi(1)*cvi
                    wi(1) = wr(1)*cvi + wi(1)*cvr
                    wr(1) = str
                    str = wr(2)*cvr - wi(2)*cvi
                    wi(2) = wr(2)*cvi + wi(2)*cvr
                    wr(2) = str
                  END IF
                END IF
                str = wr(2)*con1r - wi(2)*con1i
                wi(2) = wr(2)*con1i + wi(2)*con1r
                wr(2) = str
                cvr = con2r
                cvi = con2i
              END IF
              !-----------------------------------------------------------------------
              !     Error relative to maximum term
              !-----------------------------------------------------------------------
              av = ZABS(cvr,cvi)
              cwr = yr(1)*wr(2) - yi(1)*wi(2)
              cwi = yr(1)*wi(2) + yi(1)*wr(2)
              cyr = yr(2)*wr(1) - yi(2)*wi(1)
              cyi = yr(2)*wi(1) + yi(2)*wr(1)
              cyr = cwr - cyr - cvr
              cyi = cwi - cyi - cvi
              acy = ZABS(yr(1),yi(1))*ZABS(wr(2),wi(2))
              acw = ZABS(wr(1),wi(1))*ZABS(yr(2),yi(2))
              av = MAX(acw,acy,av)
              er = ZABS(cyr,cyi)/av
              IF( er>=ertol ) THEN
                IF( lflg==0 ) THEN
                  IF( Kprint>=2 ) THEN
                    WRITE (Lun,99005) ertol
                    99005 FORMAT (' CASES WHICH VIOLATE THE RELATIVE ERROR',&
                      ' TEST WITH ERTOL = ',D12.4/)
                    WRITE (Lun,99006)
                    99006 FORMAT (' INPUT TO ZAIRY AND ERROR')
                  END IF
                  IF( Kprint>=3 ) THEN
                    WRITE (Lun,99007)
                    99007 FORMAT (' COMPARISON VALUE AND WRONSKIAN')
                    WRITE (Lun,99008)
                    99008 FORMAT (' RESULTS FROM ZAIRY AND/OR ZBIRY')
                    WRITE (Lun,99009)
                    99009 FORMAT (' TEST CASE INDICES'/)
                  END IF
                END IF
                lflg = 1
                IF( Kprint>=2 ) THEN
                  WRITE (Lun,99010) zr, zi, er
                  99010 FORMAT (12X,'INPUT:    Z=',2D12.4,5X,'ERROR:   ER=',D12.4)
                END IF
                IF( Kprint>=3 ) THEN
                  WRITE (Lun,99011) cvr, cvi, cyr, cyi
                  99011 FORMAT (' COMPARISON VALUE:   CV=',2D12.4/8X,&
                    'WRONSKIAN:   CY=',2D12.4)
                  WRITE (Lun,99012) nz1, yr(1), yi(1), nz2, yr(2), yi(2)
                  99012 FORMAT (10X,'RESULTS:  NZ1=',I3,4X,'Y(1)=',2D12.4/20X,&
                    'NZ2=',I3,4X,'Y(2)=',2D12.4)
                  IF( icase==1 ) THEN
                    WRITE (Lun,99013) wr(1), wi(1), wr(2), wi(2)
                    99013 FORMAT (31X,'W(1)=',2D12.4/31X,'W(2)=',2D12.4)
                  ELSE
                    WRITE (Lun,99014) nz3, wr(1), wi(1), nz4, wr(2), wi(2)
                    99014 FORMAT (20X,'NZ3=',I3,4X,'W(1)=',2D12.4/20X,'NZ4=',I3,4X,&
                      'W(2)=',2D12.4)
                  END IF
                  WRITE (Lun,99015) it, ir, irset, icase
                  99015 FORMAT (13X,'CASE:   IT=',I3,4X,'IR=',I3,4X,'IRSET=',I3,4X,&
                    'ICASE=',I3,4X/)
                END IF
              END IF
            END DO
          END DO
        END DO
      END DO
    END DO
    IF( Kprint>=2 ) THEN
      IF( lflg==0 ) THEN
        WRITE (Lun,99016)
        99016 FORMAT (' QUICK CHECKS OK')
      ELSE
        WRITE (Lun,99017)
        99017 FORMAT (' ***',5X,'FAILURE(S) FOR ZAIRY IN THE Z PLANE')
      END IF
    END IF
    Ipass = 0
    IF( lflg==0 ) Ipass = 1
    IF( Ipass==1 .AND. Kprint>=2 ) THEN
      WRITE (Lun,99018)
      99018 FORMAT (/' ****** ZAIRY  PASSED ALL TESTS  ******'/)
    END IF
    IF( Ipass==0 .AND. Kprint>=1 ) THEN
      WRITE (Lun,99019)
      99019 FORMAT (/' ****** ZAIRY  FAILED SOME TESTS ******'/)
    END IF
  END SUBROUTINE ZQCAI
  !** ZQCBH
  SUBROUTINE ZQCBH(Lun,Kprint,Ipass)
    !> Quick check for SLATEC subroutine
    !            ZBESH
    !***
    ! **Library:**   SLATEC
    !***
    ! **Category:**  C10A4
    !***
    ! **Type:**      COMPLEX (CQCBH-C, ZQCBH-Z)
    !***
    ! **Keywords:**  QUICK CHECK, ZBESH
    !***
    ! **Author:**  Amos, Don, (SNL)
    !           Goudy, Sue, (SNL)
    !           Walton, Lee, (SNL)
    !***
    ! **Description:**
    !
    !- Usage:
    !
    !        INTEGER  LUN, KPRINT, IPASS
    !
    !        CALL ZQCBH (LUN, KPRINT, IPASS)
    !
    !- Arguments:
    !
    !     LUN    :IN  is the unit number to which output is to be written.
    !
    !     KPRINT :IN  controls the amount of output, as specified in the
    !                 SLATEC Guidelines.
    !
    !     IPASS  :OUT indicates whether the test passed or failed.
    !                 A value of one is good, indicating no failures.
    !
    !- Description:
    !
    !                 *** A DOUBLE PRECISION ROUTINE ***
    !
    !   ZQCBH is a quick check routine for the complex H Bessel functions
    !    generated by subroutine ZBESH.
    !
    !   ZQCBH generates sequences of H Bessel functions for kinds 1 and 2
    !    from CBESH and checks them against the Wronskian evaluation
    !    in the (Z,FNU) space.
    !
    !***
    ! **References:**  Abramowitz, M. and Stegun, I. A., Handbook
    !                 of Mathematical Functions, Dover Publications,
    !                 New York, 1964.
    !               Amos, D. E., A Subroutine Package for Bessel
    !                 Functions of a Complex Argument and Nonnegative
    !                 Order, SAND85-1018, May, 1985.
    !***
    ! **Routines called:**  ZBESH, ZUOIK, ZABS, ZDIV, I1MACH, D1MACH

    !* REVISION HISTORY  (YYMMDD)
    !   830501  DATE WRITTEN
    !   890831  Revised to meet new SLATEC standards
    USE slatec, ONLY : ZBESH, ZUOIK, ZABS, ZDIV, I1MACH, D1MACH
    !
    !*Internal Notes:
    !   Machine constants are defined by functions I1MACH and D1MACH.
    !
    !   The parameter MQC can have values 1 (the default) for a faster,
    !   less definitive test or 2 for a slower, more definitive test.
    !
    !**End
    !
    !  Set test complexity parameter.
    INTEGER, PARAMETER :: MQC = 1
    !  Declare arguments.
    !
    INTEGER :: Lun, Kprint, Ipass
    !
    !  Declare local variables.
    !
    REAL(DP) :: cvr, cvi, cwr, cwi, cyr, cyi, wr(20), wi(20), yr(20), yi(20), &
      zr, zi, znr, zni
    REAL(DP) :: aa, ab, acw, acy, aer(20), alim, atol, av, aw, ay, &
      az, ct, dig, elim, eps, er, ertol, film, fnu, fnul, fpi, hpi, pi, r, rfpi, &
      rl, rm, r1m4, r1m5, r2, slak, st, t(20), tol, ts, xnu(20)
    INTEGER :: i, icase, ierr, il, ir, irb, it, itl, k, kdo(20), keps(20), &
      kk, kode, k1, k2, lflg, mflg, n, nl, nu, nul, nz1, nz2, n1
    !
    !* FIRST EXECUTABLE STATEMENT  ZQCBH
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99001)
      99001 FORMAT (' QUICK CHECK ROUTINE FOR THE H BESSEL FUNCTIONS FROM ','ZBESH'/)
    END IF
    !-----------------------------------------------------------------------
    !     Set parameters related to machine constants.
    !     TOL is the approximate unit roundoff limited to 1.0D-18.
    !     ELIM is the approximate exponential over- and underflow limit.
    !     exp(-ELIM)<exp(-ALIM)=exp(-ELIM)/TOL    and
    !     exp(ELIM)>exp(ALIM)=exp(ELIM)*TOL       are intervals near
    !     underflow and overflow limits where scaled arithmetic is done.
    !     RL is the lower boundary of the asymptotic expansion for large Z.
    !     DIG = number of base 10 digits in TOL = 10**(-DIG).
    !     FNUL is the lower boundary of the asymptotic series for large FNU.
    !-----------------------------------------------------------------------
    r1m4 = D1MACH(4)
    tol = MAX(r1m4,1.E-18_DP)
    atol = 100._DP*tol
    aa = -LOG10(r1m4)
    k1 = I1MACH(12)
    k2 = I1MACH(13)
    r1m5 = D1MACH(5)
    k = MIN(ABS(k1),ABS(k2))
    elim = 2.303_DP*(k*r1m5-3._DP)
    ab = aa*2.303_DP
    alim = elim + MAX(-ab,-41.45_DP)
    dig = MIN(aa,18._DP)
    fnul = 10._DP + 6._DP*(dig-3._DP)
    rl = 1.2_DP*dig + 3._DP
    slak = 3._DP + 4._DP*(-LOG10(tol)-7._DP)/11._DP
    slak = MAX(slak,3._DP)
    ertol = tol*10._DP**slak
    rm = 0.5_DP*(alim+elim)
    rm = MIN(rm,200._DP)
    rm = MAX(rm,rl+10._DP)
    r2 = MIN(fnul,rm)
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99002)
      99002 FORMAT (' PARAMETERS'/5X,'TOL ',8X,'ELIM',8X,'ALIM',8X,'RL  ',8X,'FNUL',&
        8X,'DIG')
      WRITE (Lun,99003) tol, elim, alim, rl, fnul, dig
      99003 FORMAT (6D12.4/)
    END IF
    !-----------------------------------------------------------------------
    !     Set other constants needed in the tests.
    !-----------------------------------------------------------------------
    fpi = ATAN(1._DP)
    hpi = fpi + fpi
    pi = hpi + hpi
    rfpi = 1._DP/fpi
    znr = 0._DP
    zni = -rfpi
    !-----------------------------------------------------------------------
    !     Generate angles for construction of complex Z to be used in tests.
    !-----------------------------------------------------------------------
    !     KDO(K), K = 1,IL  determines which of the IL angles in -PI to PI
    !     are used to compute values of Z.
    !       KDO(K) = 0  means that the index K will be used for one or two
    !                   values of Z, depending on the choice of KEPS(K)
    !              = 1  means that the index K and the corresponding angle
    !                   will be skipped
    !     KEPS(K), K = 1,IL determines which of the angles get incremented
    !     up and down to put values of Z in regions where different
    !     formulae are used.
    !       KEPS(K)  = 0  means that the angle will be used without change
    !                = 1  means that the angle will be incremented up and
    !                   down by EPS
    !     The angles to be used are stored in the T(I) array, I = 1,ITL.
    !-----------------------------------------------------------------------
    IF( MQC/=2 ) THEN
      nl = 2
      il = 5
      DO i = 1, il
        keps(i) = 0
        kdo(i) = 0
      END DO
      nul = 5
      xnu(1) = 0._DP
      xnu(2) = 1._DP
      xnu(3) = 2._DP
      xnu(4) = 0.5_DP*fnul
      xnu(5) = fnul + 1.1_DP
    ELSE
      nl = 4
      il = 13
      DO i = 1, il
        kdo(i) = 0
        keps(i) = 0
      END DO
      kdo(2) = 1
      kdo(6) = 1
      kdo(8) = 1
      kdo(12) = 1
      keps(3) = 1
      keps(4) = 1
      keps(5) = 1
      keps(9) = 1
      keps(10) = 1
      keps(11) = 1
      nul = 6
      xnu(1) = 0._DP
      xnu(2) = 0.6_DP
      xnu(3) = 1.3_DP
      xnu(4) = 2._DP
      xnu(5) = 0.5_DP*fnul
      xnu(6) = fnul + 1.1_DP
    END IF
    i = 2
    eps = 0.01_DP
    film = il - 1
    t(1) = -pi + eps
    DO k = 2, il
      IF( kdo(k)==0 ) THEN
        t(i) = pi*(-il+2*k-1)/film
        IF( keps(k)/=0 ) THEN
          ts = t(i)
          t(i) = ts - eps
          i = i + 1
          t(i) = ts + eps
        ELSE
          i = i + 1
        END IF
      END IF
    END DO
    itl = i - 1
    !-----------------------------------------------------------------------
    !     Test values of Z in -PI<arg(Z)<=PI.
    !-----------------------------------------------------------------------
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99004)
      99004 FORMAT (' CHECKS IN THE (Z,FNU) SPACE'/)
    END IF
    lflg = 0
    DO kode = 1, 2
      DO n = 1, nl
        n1 = n + 1
        DO nu = 1, nul
          fnu = xnu(nu)
          DO icase = 1, 3
            irb = MIN(icase,2)
            DO ir = irb, 3
              !-------------- switch (icase)
              SELECT CASE (icase)
                CASE (2)
                  r = (2._DP*(3-ir)+r2*(ir-1))/2._DP
                CASE (3)
                  IF( r2>=rm ) EXIT
                  r = (r2*(3-ir)+rm*(ir-1))/2._DP
                CASE DEFAULT
                  r = (eps*(3-ir)+2._DP*(ir-1))/2._DP
              END SELECT
              !-------------- end switch
              DO it = 1, itl
                ct = COS(t(it))
                st = SIN(t(it))
                IF( ABS(ct)<atol ) ct = 0._DP
                IF( ABS(st)<atol ) st = 0._DP
                zr = r*ct
                zi = r*st
                IF( fnu>=2._DP ) THEN
                  !------------------ Check for possible overflow condition
                  cvr = -zi
                  cvi = zr
                  CALL ZUOIK(cvr,cvi,fnu,kode,2,n1,wr,wi,nz2,tol,elim,alim)
                  !------------------ Overflow detected? - skip test for this case
                  IF( nz2==(-1) ) CYCLE
                  cvr = -cvr
                  cvi = -cvi
                  CALL ZUOIK(cvr,cvi,fnu,kode,2,n1,wr,wi,nz2,tol,elim,alim)
                  !------------------ Overflow detected? - skip test for this case
                  IF( nz2==(-1) ) CYCLE
                END IF
                !---------------- No overflow - calculate H1(Z,FNU) and H2(Z,FNU)
                CALL ZBESH(zr,zi,fnu,kode,1,n1,yr,yi,nz1,ierr)
                !---------------- Underflow? - skip test for this case
                IF( nz1==0 ) THEN
                  CALL ZBESH(zr,zi,fnu,kode,2,n1,wr,wi,nz2,ierr)
                  !---------------- Underflow? - skip test for this case
                  IF( nz2==0 ) THEN
                    !-----------------------------------------------------------------------
                    !     Compare ZN/Z with the Wronskian of H1(Z,FNU) and H2(Z,FNU).
                    !     ZN = -4i/PI
                    !-----------------------------------------------------------------------
                    CALL ZDIV(znr,zni,zr,zi,cvr,cvi)
                    mflg = 0
                    DO i = 1, n
                      !-----------------------------------------------------------------------
                      !     Error relative to maximum term
                      !-----------------------------------------------------------------------
                      aw = ZABS(wr(i+1),wi(i+1))
                      ay = ZABS(yr(i),yi(i))
                      az = LOG(aw) + LOG(ay)
                      az = ABS(az)
                      IF( az<=alim ) THEN
                        !-------------------- No scaling problem - do error analysis
                        av = ZABS(cvr,cvi)
                        cwr = wr(i)*yr(i+1) - wi(i)*yi(i+1)
                        cwi = wr(i)*yi(i+1) + wi(i)*yr(i+1)
                        cyr = wr(i+1)*yr(i) - wi(i+1)*yi(i)
                        cyi = wr(i+1)*yi(i) + wi(i+1)*yr(i)
                        cyr = cwr - cyr - cvr
                        cyi = cwi - cyi - cvi
                        acy = aw*ay
                        acw = ZABS(wr(i),wi(i))*ZABS(yr(i+1),yi(i+1))
                        av = MAX(acw,acy,av)
                        er = ZABS(cyr,cyi)/av
                        aer(i) = er
                        IF( er>ertol ) mflg = 1
                      END IF
                    END DO
                    IF( mflg/=0 ) THEN
                      IF( lflg==0 ) THEN
                        IF( Kprint>=2 ) THEN
                          WRITE (Lun,99005) ertol
                          99005 FORMAT (' CASES WHICH VIOLATE THE RELATIVE ',&
                            'ERROR TEST WITH ERTOL = ',D12.4/)
                          WRITE (Lun,99006)
                          99006 FORMAT (' INPUT TO ZBESH   Z, FNU, KODE, N')
                        END IF
                        IF( Kprint>=3 ) THEN
                          WRITE (Lun,99007)
                          99007 FORMAT (' COMPARE -4i/(PI*Z) WITH WRONSKIAN OF',&
                            ' H1(Z,FNU) AND H2(Z,FNU)')
                          WRITE (Lun,99008)
                          99008 FORMAT (' RESULTS FROM ZBESH FOR FUNCTION H1'/&
                            '         AND FUNCTION H2')
                          WRITE (Lun,99009)
                          99009 FORMAT (' TEST CASE INDICES'/)
                        END IF
                      END IF
                      lflg = lflg + 1
                      IF( Kprint>=2 ) THEN
                        WRITE (Lun,99010) zr, zi, fnu, kode, n
                        99010 FORMAT ('   INPUT:    Z=',2D12.4,4X,'FNU=',D12.4,4X,&
                          'KODE=',I3,4X,'N=',I3)
                      END IF
                      IF( Kprint>=3 ) THEN
                        WRITE (Lun,99011) (aer(k),k=1,n)
                        99011 FORMAT ('   ERROR:   AER(K)=',4D12.4)
                        kk = MAX(nz1,nz2) + 1
                        kk = MIN(n,kk)
                        WRITE (Lun,99012) nz1, yr(kk), yi(kk), nz2, wr(kk), wi(kk)
                        99012 FORMAT (' RESULTS:  NZ1=',I3,4X,'Y(KK)=',2D12.4/11X,&
                          'NZ2=',I3,4X,'W(KK)=',2D12.4)
                        WRITE (Lun,99013) it, ir, icase
                        99013 FORMAT ('    CASE:   IT=',I3,4X,'IR=',I3,4X,'ICASE=',I3/)
                      END IF
                    END IF
                  END IF
                END IF
              END DO
            END DO
          END DO
        END DO
      END DO
    END DO
    IF( Kprint>=2 ) THEN
      IF( lflg==0 ) THEN
        WRITE (Lun,99014)
        99014 FORMAT (' QUICK CHECKS OK')
      ELSE
        WRITE (Lun,99015) lflg
        99015 FORMAT (' ***',I5,' FAILURE(S) FOR ZBESH IN THE (Z,FNU)',' PLANE')
      END IF
    END IF
    Ipass = 0
    IF( lflg==0 ) Ipass = 1
    IF( Ipass==1 .AND. Kprint>=2 ) THEN
      WRITE (Lun,99016)
      99016 FORMAT (/' ****** ZBESH  PASSED ALL TESTS  ******'/)
    END IF
    IF( Ipass==0 .AND. Kprint>=1 ) THEN
      WRITE (Lun,99017)
      99017 FORMAT (/' ****** ZBESH  FAILED SOME TESTS ******'/)
    END IF
  END SUBROUTINE ZQCBH
  !** ZQCBI
  SUBROUTINE ZQCBI(Lun,Kprint,Ipass)
    !> Quick check for SLATEC subroutine
    !            ZBESI
    !***
    ! **Library:**   SLATEC
    !***
    ! **Category:**  C10B4
    !***
    ! **Type:**      COMPLEX (CQCBI-C, ZQCBI-Z)
    !***
    ! **Keywords:**  QUICK CHECK, ZBESI
    !***
    ! **Author:**  Amos, Don, (SNL)
    !           Goudy, Sue, (SNL)
    !           Walton, Lee, (SNL)
    !***
    ! **Description:**
    !
    !- Usage:
    !
    !        INTEGER  LUN, KPRINT, IPASS
    !
    !        CALL ZQCBI (LUN, KPRINT, IPASS)
    !
    !- Arguments:
    !
    !     LUN    :IN  is the unit number to which output is to be written.
    !
    !     KPRINT :IN  controls the amount of output, as specified in the
    !                 SLATEC Guidelines.
    !
    !     IPASS  :OUT indicates whether the test passed or failed.
    !                 A value of one is good, indicating no failures.
    !
    !- Description:
    !
    !                 *** A DOUBLE PRECISION ROUTINE ***
    !
    !   ZQCBI is a quick check routine for the complex I Bessel function
    !    generated by subroutine ZBESI.
    !
    !   ZQCBI generates sequences crossing formula boundaries which
    !    are started by one formula and terminated in a region where
    !    another formula applies. The terminated value is checked by
    !    the formula appropriate to that region.
    !
    !***
    ! **References:**  Abramowitz, M. and Stegun, I. A., Handbook
    !                 of Mathematical Functions, Dover Publications,
    !                 New York, 1964.
    !               Amos, D. E., A Subroutine Package for Bessel
    !                 Functions of a Complex Argument and Nonnegative
    !                 Order, SAND85-1018, May, 1985.
    !***
    ! **Routines called:**  ZBESI, ZBESK, ZWRSK, ZABS, ZDIV, I1MACH, D1MACH

    !* REVISION HISTORY  (YYMMDD)
    !   830501  DATE WRITTEN
    !   890831  Revised to meet new SLATEC standards
    USE slatec, ONLY : ZBESI, ZBESK, ZWRSK, ZABS, ZDIV, I1MACH, D1MACH
    !
    !*Internal Notes:
    !   Machine constants are defined by functions I1MACH and D1MACH.
    !
    !   The parameter MQC can have values 1 (the default) for a faster,
    !   less definitive test or 2 for a slower, more definitive test.
    !
    !**End
    !
    !  Set test complexity parameter.
    INTEGER, PARAMETER :: MQC = 1
    !  Declare arguments.
    !
    INTEGER :: Lun, Kprint, Ipass
    !
    !  Declare local variables.
    !
    REAL(DP) :: ckr(20), cki(20), coner, conei, csgnr, csgni, cwr, cwi, &
      cyr, cyi, wr(20), wi(20), yr(20), yi(20), zr, zi, znr, zni, ztr, zti
    REAL(DP) :: aa, ab, aer(20), alim, arg, atol, aw, carg, ct, &
      dig, elim, eps, er, ertol, film, fnu, fnul, gnu, &
      hpi, pi, r, rl, rlt, rm, r1, r1m4, r1m5, r2, &
      sarg, slak, st, sti, str, t(20), tol, ts, zscr, zzr
    INTEGER :: i, icase, ierr, il, inu, iprnt, ir, it, itl, k, kdo(20), &
      keps(20), kk, kode, k1, k2, lflg, mflg, n, nl, nzi, nzk, nz1, nz2, n1
    !
    !* FIRST EXECUTABLE STATEMENT  ZQCBI
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99001)
      99001 FORMAT (' QUICK CHECK ROUTINE FOR THE I BESSEL FUNCTION FROM ','ZBESI'/)
    END IF
    !-----------------------------------------------------------------------
    !     Set parameters related to machine constants.
    !     TOL is the approximate unit roundoff limited to 1.0D-18.
    !     ELIM is the approximate exponential over- and underflow limit.
    !     exp(-ELIM)<exp(-ALIM)=exp(-ELIM)/TOL    and
    !     exp(ELIM)>exp(ALIM)=exp(ELIM)*TOL       are intervals near
    !     underflow and overflow limits where scaled arithmetic is done.
    !     RL is the lower boundary of the asymptotic expansion for large Z.
    !     DIG = number of base 10 digits in TOL = 10**(-DIG).
    !     FNUL is the lower boundary of the asymptotic series for large FNU.
    !-----------------------------------------------------------------------
    r1m4 = D1MACH(4)
    tol = MAX(r1m4,1.E-18_DP)
    atol = 100._DP*tol
    aa = -LOG10(r1m4)
    k1 = I1MACH(12)
    k2 = I1MACH(13)
    r1m5 = D1MACH(5)
    k = MIN(ABS(k1),ABS(k2))
    elim = 2.303_DP*(k*r1m5-3._DP)
    ab = aa*2.303_DP
    alim = elim + MAX(-ab,-41.45_DP)
    dig = MIN(aa,18._DP)
    fnul = 10._DP + 6._DP*(dig-3._DP)
    rl = 1.2_DP*dig + 3._DP
    slak = 3._DP + 4._DP*(-LOG10(tol)-7._DP)/11._DP
    slak = MAX(slak,3._DP)
    ertol = tol*10._DP**slak
    rm = 0.5_DP*(alim+elim)
    rm = MIN(rm,200._DP)
    rm = MAX(rm,rl+10._DP)
    r2 = MIN(rm,fnul)
    r1 = 2._DP*SQRT(fnul+1._DP)
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99002)
      99002 FORMAT (' PARAMETERS'/5X,'TOL ',8X,'ELIM',8X,'ALIM',8X,'RL  ',8X,'FNUL',&
        8X,'DIG')
      WRITE (Lun,99003) tol, elim, alim, rl, fnul, dig
      99003 FORMAT (1X,6D12.4/)
    END IF
    !-----------------------------------------------------------------------
    !     Set other constants needed in the tests.
    !-----------------------------------------------------------------------
    zzr = 1._DP/tol
    coner = 1._DP
    conei = 0._DP
    hpi = 2._DP*ATAN(1._DP)
    pi = hpi + hpi
    !-----------------------------------------------------------------------
    !     Generate angles for construction of complex Z to be used in tests.
    !-----------------------------------------------------------------------
    !     KDO(K), K = 1,IL  determines which of the IL angles in -PI to PI
    !     are used to compute values of Z.
    !       KDO(K) = 0  means that the index K will be used for one or two
    !                   values of Z, depending on the choice of KEPS(K)
    !              = 1  means that the index K and the corresponding angle
    !                   will be skipped
    !     KEPS(K), K = 1,IL determines which of the angles get incremented
    !     up and down to put values of Z in regions where different
    !     formulae are used.
    !       KEPS(K)  = 0  means that the angle will be used without change
    !                = 1  means that the angle will be incremented up and
    !                   down by EPS
    !     The angles to be used are stored in the T(I) array, I = 1,ITL.
    !-----------------------------------------------------------------------
    IF( MQC/=2 ) THEN
      nl = 2
      il = 5
      DO i = 1, il
        keps(i) = 0
        kdo(i) = 0
      END DO
    ELSE
      nl = 4
      il = 13
      DO i = 1, il
        kdo(i) = 0
        keps(i) = 0
      END DO
      kdo(2) = 1
      kdo(6) = 1
      kdo(8) = 1
      kdo(12) = 1
      keps(3) = 1
      keps(4) = 1
      keps(5) = 1
      keps(9) = 1
      keps(10) = 1
      keps(11) = 1
    END IF
    i = 2
    eps = 0.01_DP
    film = il - 1
    t(1) = -pi + eps
    DO k = 2, il
      IF( kdo(k)==0 ) THEN
        t(i) = pi*(-il+2*k-1)/film
        IF( keps(k)/=0 ) THEN
          ts = t(i)
          t(i) = ts - eps
          i = i + 1
          t(i) = ts + eps
        ELSE
          i = i + 1
        END IF
      END IF
    END DO
    itl = i - 1
    !-----------------------------------------------------------------------
    !     Test values of Z in -PI<arg(Z)<=PI near formula boundaries.
    !-----------------------------------------------------------------------
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99004)
      99004 FORMAT (' CHECKS ACROSS FORMULA BOUNDARIES')
    END IF
    lflg = 0
    DO icase = 1, 6
      DO kode = 1, 2
        DO n = 1, nl
          n1 = n + 2
          !-----------------------------------------------------------------------
          !     Set values for R = magnitude of Z and for FNU to test computation
          !     methods for the various regions of the (Z,FNU) plane.
          !-----------------------------------------------------------------------
          DO ir = 1, 3
            !------------ switch (icase)
            SELECT CASE (icase)
              CASE (2)
                r = (rl*(3-ir)+r2*(ir-1))/2._DP
                gnu = SQRT(r+r) - 0.2_DP - (n-1)
                fnu = MAX(0._DP,gnu)
              CASE (3)
                IF( r2>=rm ) GOTO 100
                r = (r2*(3-ir)+rm*(ir-1))/2._DP
                gnu = SQRT(r+r) - 0.2_DP - (n-1)
                fnu = MAX(0._DP,gnu)
              CASE (4)
                IF( r1>=rl ) GOTO 100
                r = (r1*(3-ir)+rl*(ir-1))/2._DP
                fnu = fnul - 0.2_DP - (n-1)
              CASE (5)
                r = (rl*(3-ir)+r2*(ir-1))/2._DP
                fnu = fnul - 0.2_DP - (n-1)
              CASE (6)
                IF( r2>=rm ) GOTO 100
                r = (r2*(3-ir)+rm*(ir-1))/2._DP
                fnu = fnul - 0.2_DP - (n-1)
              CASE DEFAULT
                r = (2._DP*(3-ir)+rl*(ir-1))/2._DP
                gnu = r*r/4._DP - 0.2_DP - (n-1)
                fnu = MAX(0._DP,gnu)
            END SELECT
            !------------ end switch
            DO it = 1, itl
              ct = COS(t(it))
              st = SIN(t(it))
              IF( ABS(ct)<atol ) ct = 0._DP
              IF( ABS(st)<atol ) st = 0._DP
              zr = r*ct
              zi = r*st
              CALL ZBESI(zr,zi,fnu,kode,n1,yr,yi,nz1,ierr)
              IF( nz1==0 ) THEN
                !-----------------------------------------------------------------------
                !     Compare values from ZBESI with values from ZWRSK, an alternative
                !     method for calculating the complex Bessel I function.
                !-----------------------------------------------------------------------
                znr = zr
                zni = zi
                IF( zr>=0._DP ) THEN
                  CALL ZWRSK(znr,zni,fnu,kode,n,wr,wi,nz2,ckr,cki,tol,elim,alim)
                  IF( nz2/=0 ) CYCLE
                ELSE
                  znr = -zr
                  zni = -zi
                  inu = INT(fnu)
                  arg = (fnu-inu)*pi
                  IF( zi<0._DP ) arg = -arg
                  carg = COS(arg)
                  sarg = SIN(arg)
                  csgnr = carg
                  csgni = sarg
                  IF( MOD(inu,2)==1 ) THEN
                    csgnr = -csgnr
                    csgni = -csgni
                  END IF
                  CALL ZWRSK(znr,zni,fnu,kode,n,wr,wi,nz2,ckr,cki,tol,elim,alim)
                  IF( nz2/=0 ) CYCLE
                  DO i = 1, n
                    str = wr(i)*csgnr - wi(i)*csgni
                    wi(i) = wr(i)*csgni + wi(i)*csgnr
                    wr(i) = str
                    csgnr = -csgnr
                    csgni = -csgni
                  END DO
                END IF
                mflg = 0
                DO i = 1, n
                  ab = fnu + i - 1
                  aa = MAX(2._DP,ab)
                  ztr = wr(i)
                  zti = wi(i)
                  IF( ABS(ztr)>1._DP .OR. ABS(zti)>1._DP ) THEN
                    zscr = tol
                  ELSE
                    zscr = zzr
                    !------------------ ZZR = 1._DP/TOL
                  END IF
                  cwr = wr(i)*zscr
                  cwi = wi(i)*zscr
                  cyr = yr(i)*zscr
                  cyi = yi(i)*zscr
                  str = cyr - cwr
                  sti = cyi - cwi
                  er = ZABS(str,sti)
                  aw = ZABS(cwr,cwi)
                  IF( aw==0._DP ) THEN
                    er = ZABS(yr(i),yi(i))
                  ELSEIF( zr/=0._DP ) THEN
                    er = er/aw
                  ELSEIF( ABS(zi)<aa ) THEN
                    er = er/aw
                  ELSE
                    str = yr(i) - wr(i)
                    sti = yi(i) - wi(i)
                    er = ZABS(str,sti)
                  END IF
                  aer(i) = er
                  IF( er>ertol ) mflg = 1
                END DO
                !-----------------------------------------------------------------------
                !     Write failure reports for KPRINT>=2 and KPRINT>=3
                !-----------------------------------------------------------------------
                IF( mflg/=0 ) THEN
                  IF( lflg==0 ) THEN
                    IF( Kprint>=2 ) THEN
                      WRITE (Lun,99005) ertol
                      99005 FORMAT (/' CASES WHICH UNDERFLOW OR VIOLATE THE ',&
                        'RELATIVE ERROR TEST'/' WITH ERTOL = ',D12.4/)
                      WRITE (Lun,99006)
                      99006 FORMAT (' INPUT TO ZBESI   Z, FNU, KODE, N')
                    END IF
                    IF( Kprint>=3 ) THEN
                      WRITE (Lun,99007)
                      99007 FORMAT (' ERROR TEST ON RESULTS FROM ZBESI AND ',&
                        'ZWRSK   AER(K)')
                      WRITE (Lun,99008)
                      99008 FORMAT (' RESULTS FROM ZBESI   NZ1, Y(KK)'/,&
                        ' RESULTS FROM ZWRSK   NZ2, W(KK)')
                      WRITE (Lun,99009)
                      99009 FORMAT (' TEST CASE INDICES   IT, IR, ICASE'/)
                    END IF
                  END IF
                  lflg = lflg + 1
                  IF( Kprint>=2 ) THEN
                    WRITE (Lun,99010) zr, zi, fnu, kode, n
                    99010 FORMAT ('   INPUT:    Z=',2D12.4,4X,'FNU=',D12.4,4X,&
                      'KODE=',I3,4X,'N=',I3)
                  END IF
                  IF( Kprint>=3 ) THEN
                    WRITE (Lun,99011) (aer(k),k=1,n)
                    99011 FORMAT ('   ERROR:  AER(K)=',4D12.4)
                    kk = MAX(nz1,nz2) + 1
                    kk = MIN(n,kk)
                    WRITE (Lun,99012) nz1, yr(kk), yi(kk), nz2, wr(kk), wi(kk)
                    99012 FORMAT (' RESULTS:  NZ1=',I3,4X,'Y(KK)=',2D12.4,/11X,&
                      'NZ2=',I3,4X,'W(KK)=',2D12.4)
                    WRITE (Lun,99013) it, ir, icase
                    99013 FORMAT ('    CASE:   IT=',I3,4X,'IR=',I3,4X,'ICASE=',I3/)
                  END IF
                END IF
              END IF
            END DO
          END DO
        END DO
      END DO
      100 CONTINUE
    END DO
    IF( Kprint>=2 ) THEN
      IF( lflg==0 ) THEN
        WRITE (Lun,99019)
      ELSE
        WRITE (Lun,99014) lflg
        99014 FORMAT (' ***',I5,' FAILURE(S) FOR ZBESI CHECKS NEAR FORMULA ',&
          'BOUNDARIES')
      END IF
    END IF
    !
    !
    iprnt = 0
    IF( MQC/=1 ) THEN
      !-----------------------------------------------------------------------
      !     Checks near underflow limits on series(I=1) and uniform
      !     asymptotic expansion(I=2)
      !     Compare 1/Z with I(Z,FNU)*K(Z,FNU+1) + I(Z,FNU+1)*K(Z,FNU) and
      !     report cases for which the relative error is greater than ERTOL.
      !-----------------------------------------------------------------------
      IF( Kprint>=2 ) THEN
        WRITE (Lun,99015)
        99015 FORMAT (/' CHECKS NEAR UNDERFLOW AND OVERFLOW LIMITS'/)
      END IF
      zr = 1.4_DP
      zi = 1.4_DP
      kode = 1
      n = 20
      DO i = 1, 2
        fnu = 10.2_DP
        DO
          !-----------------------------------------------------------------------
          !       Adjust FNU by repeating until 0<NZI<10
          !-----------------------------------------------------------------------
          CALL ZBESI(zr,zi,fnu,kode,n,yr,yi,nzi,ierr)
          IF( nzi==0 ) THEN
            fnu = fnu + 5._DP
            CYCLE
          ELSEIF( nzi>=10 ) THEN
            fnu = fnu - 1._DP
            CYCLE
          END IF
          !------ End repeat
          CALL ZBESK(zr,zi,fnu,kode,2,wr,wi,nzk,ierr)
          CALL ZDIV(coner,conei,zr,zi,ztr,zti)
          cyr = wr(1)*yr(2) - wi(1)*yi(2)
          cyi = wr(1)*yi(2) + wi(1)*yr(2)
          cwr = wr(2)*yr(1) - wi(2)*yi(1)
          cwi = wr(2)*yi(1) + wi(2)*yr(1)
          cwr = cwr + cyr - ztr
          cwi = cwi + cyi - zti
          er = ZABS(cwr,cwi)/ZABS(ztr,zti)
          !-----------------------------------------------------------------------
          !     Write failure reports for KPRINT>=2 and KPRINT>=3
          !-----------------------------------------------------------------------
          IF( er>=ertol ) THEN
            IF( iprnt==0 ) THEN
              IF( Kprint>=2 ) WRITE (Lun,99020)
              IF( Kprint>=3 ) WRITE (Lun,99021)
            END IF
            iprnt = 1
            IF( Kprint>=2 ) WRITE (Lun,99022) zr, zi, fnu, kode, n
            IF( Kprint>=3 ) THEN
              WRITE (Lun,99023) ztr, zti, cwr + cyr, cwi + cyi
              WRITE (Lun,99024) er
            END IF
          END IF
          rlt = rl + rl
          zr = rlt
          zi = 0._DP
          EXIT
        END DO
      END DO
      !-----------------------------------------------------------------------
      !     Check near overflow limits
      !     Compare 1/Z with I(Z,FNU)*K(Z,FNU+1) + I(Z,FNU+1)*K(Z,FNU) and
      !     report cases for which the relative error is greater than ERTOL.
      !-----------------------------------------------------------------------
      zr = elim
      zi = 0._DP
      fnu = 0._DP
      DO
        !-----------------------------------------------------------------------
        !     Adjust FNU by repeating until NZK<10
        !     N = 20 set before DO 280 loop
        !-----------------------------------------------------------------------
        CALL ZBESK(zr,zi,fnu,kode,n,yr,yi,nzk,ierr)
        IF( nzk>=10 ) THEN
          IF( nzk==n ) THEN
            fnu = fnu + 3._DP
          ELSE
            fnu = fnu + 2._DP
          END IF
          CYCLE
        END IF
        !---- End repeat
        gnu = fnu + (n-2)
        CALL ZBESI(zr,zi,gnu,kode,2,wr,wi,nzi,ierr)
        CALL ZDIV(coner,conei,zr,zi,ztr,zti)
        cyr = yr(n-1)*wr(2) - yi(n-1)*wi(2)
        cyi = yr(n-1)*wi(2) + yi(n-1)*wr(2)
        cwr = yr(n)*wr(1) - yi(n)*wi(1)
        cwi = yr(n)*wi(1) + yi(n)*wr(1)
        cwr = cwr + cyr - ztr
        cwi = cwi + cyi - zti
        er = ZABS(cwr,cwi)/ZABS(ztr,zti)
        IF( er>=ertol ) THEN
          IF( iprnt==0 ) THEN
            IF( Kprint>=2 ) WRITE (Lun,99020)
            IF( Kprint>=3 ) WRITE (Lun,99021)
          END IF
          iprnt = 1
          IF( Kprint>=2 ) WRITE (Lun,99022) zr, zi, fnu, kode, n
          IF( Kprint>=3 ) THEN
            WRITE (Lun,99023) ztr, zti, cwr + cyr, cwi + cyi
            WRITE (Lun,99024) er
          END IF
        END IF
        IF( Kprint>=2 ) THEN
          IF( iprnt==0 ) THEN
            WRITE (Lun,99019)
            ! 99986 FORMAT (' QUICK CHECKS OK')
          ELSE
            WRITE (Lun,99016)
            99016 FORMAT (' ***',5X,'FAILURE(S) FOR ZBESI NEAR UNDERFLOW AND ',&
              'OVERFLOW LIMITS')
          END IF
        END IF
        EXIT
      END DO
    END IF
    Ipass = 0
    IF( iprnt==0 .AND. lflg==0 ) Ipass = 1
    IF( Ipass==1 .AND. Kprint>=2 ) THEN
      WRITE (Lun,99017)
      99017 FORMAT (/' ****** ZBESI  PASSED ALL TESTS  ******'/)
    END IF
    IF( Ipass==0 .AND. Kprint>=1 ) THEN
      WRITE (Lun,99018)
      99018 FORMAT (/' ****** ZBESI  FAILED SOME TESTS ******'/)
    END IF
    99019 FORMAT (' QUICK CHECKS OK')
    99020 FORMAT (' INPUT TO ZBESI   Z, FNU, KODE, N')
    99021 FORMAT (' COMPARE 1/Z WITH WRONSKIAN(ZBESI(Z,FNU),','ZBESK(Z,FNU))'/)
    99022 FORMAT (' INPUT: Z=',2D12.4,3X,'FNU=',D12.4,3X,'KODE=',I3,3X,'N=',I3)
    99023 FORMAT (' RESULTS:',15X,'1/Z=',2D12.4/10X,'WRON(ZBESI,ZBESK)=',2D12.4)
    99024 FORMAT (' RELATIVE ERROR:',9X,'ER=',D12.4/)
  END SUBROUTINE ZQCBI
  !** ZQCBJ
  SUBROUTINE ZQCBJ(Lun,Kprint,Ipass)
    !> Quick check for SLATEC subroutine
    !            ZBESJ
    !***
    ! **Library:**   SLATEC
    !***
    ! **Category:**  C10A4
    !***
    ! **Type:**      COMPLEX (CQCBJ-C, ZQCBJ-Z)
    !***
    ! **Keywords:**  QUICK CHECK, ZBESJ
    !***
    ! **Author:**  Amos, Don, (SNL)
    !           Goudy, Sue, (SNL)
    !           Walton, Lee, (SNL)
    !***
    ! **Description:**
    !
    !- Usage:
    !
    !        INTEGER  LUN, KPRINT, IPASS
    !
    !        CALL ZQCBJ (LUN, KPRINT, IPASS)
    !
    !- Arguments:
    !
    !     LUN    :IN  is the unit number to which output is to be written.
    !
    !     KPRINT :IN  controls the amount of output, as specified in the
    !                 SLATEC Guidelines.
    !
    !     IPASS  :OUT indicates whether the test passed or failed.
    !                 A value of one is good, indicating no failures.
    !
    !- Description:
    !
    !                 *** A DOUBLE PRECISION ROUTINE ***
    !
    !   ZQCBJ is a quick check routine for the complex J Bessel function
    !    generated by subroutine ZBESJ.
    !
    !   ZQCBJ generates sequences of J Bessel functions from ZBESJ
    !    and checks them against the evaluation from the formula
    !
    !            J(FNU,Z) = 0.5*( H(1,FNU,Z) + H(2,FNU,Z) )
    !
    !    where -PI<arg(Z)<=PI for abs(Z)>=FNU.
    !
    !   For abs(Z)<FNU, the first N members of a sequence of length
    !    N+16 are checked against a corresponding N member sequence where
    !    both sequences are generated by ZBESJ beginning at order FNU.
    !
    !***
    ! **References:**  Abramowitz, M. and Stegun, I. A., Handbook
    !                 of Mathematical Functions, Dover Publications,
    !                 New York, 1964.
    !               Amos, D. E., A Subroutine Package for Bessel
    !                 Functions of a Complex Argument and Nonnegative
    !                 Order, SAND85-1018, May, 1985.
    !***
    ! **Routines called:**  ZBESH, ZBESJ, ZABS, ZEXP, I1MACH, D1MACH

    !* REVISION HISTORY  (YYMMDD)
    !   830501  DATE WRITTEN
    !   890831  Revised to meet new SLATEC standards
    !   930122  Added ZEXP to EXTERNAL statement.  (RWC)
    USE slatec, ONLY : ZBESH, ZBESJ, ZABS, ZEXP, I1MACH, D1MACH
    !
    !*Internal Notes:
    !   Machine constants are defined by functions I1MACH and D1MACH.
    !
    !   The parameter MQC can have values 1 (the default) for a faster,
    !   less definitive test or 2 for a slower, more definitive test.
    !
    !**End
    !
    !  Set test complexity parameter.
    INTEGER, PARAMETER :: MQC = 1
    !  Declare arguments.
    !
    INTEGER :: Lun, Kprint, Ipass
    !
    !  Declare local variables.
    !
    REAL(DP) :: coe1r, coe1i, coe2r, coe2i, cwr, cwi, halfr, &
      halfi, vr(20), vi(20), wr(20), wi(20), yr(20), yi(20), zr, zi
    REAL(DP) :: aa, ab, aer(20), ai, alim, ar, atol, av, cc, ct, &
      dd, dig, elim, eps, er, ertol, film, fnu, fnul, &
      gnu, hpi, pi, r, rl, rm, r1m4, r1m5, r2, slak, st, str, t(20), tol, ts, xnu(20)
    INTEGER :: i, icase, ierr, il, ir, irb, it, itl, k, kdo(20), keps(20), &
      kk, kode, k1, k2, lflg, m, mflg, n, nl, nu, nul, nz, nz1, nz2
    !
    !* FIRST EXECUTABLE STATEMENT  ZQCBJ
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99001)
      99001 FORMAT (' QUICK CHECK ROUTINE FOR THE J BESSEL FUNCTION FROM ','ZBESJ'/)
    END IF
    !-----------------------------------------------------------------------
    !     Set parameters related to machine constants.
    !     TOL is the approximate unit roundoff limited to 1.0D-18.
    !     ELIM is the approximate exponential over- and underflow limit.
    !     exp(-ELIM)<exp(-ALIM)=exp(-ELIM)/TOL    and
    !     exp(ELIM)>exp(ALIM)=exp(ELIM)*TOL       are intervals near
    !     underflow and overflow limits where scaled arithmetic is done.
    !     RL is the lower boundary of the asymptotic expansion for large Z.
    !     DIG = number of base 10 digits in TOL = 10**(-DIG).
    !     FNUL is the lower boundary of the asymptotic series for large FNU.
    !-----------------------------------------------------------------------
    r1m4 = D1MACH(4)
    tol = MAX(r1m4,1.E-18_DP)
    atol = 100._DP*tol
    aa = -LOG10(r1m4)
    k1 = I1MACH(12)
    k2 = I1MACH(13)
    r1m5 = D1MACH(5)
    k = MIN(ABS(k1),ABS(k2))
    elim = 2.303_DP*(k*r1m5-3._DP)
    ab = aa*2.303_DP
    alim = elim + MAX(-ab,-41.45_DP)
    dig = MIN(aa,18._DP)
    fnul = 10._DP + 6._DP*(dig-3._DP)
    rl = 1.2_DP*dig + 3._DP
    slak = 3._DP + 4._DP*(-LOG10(tol)-7._DP)/11._DP
    slak = MAX(slak,3._DP)
    ertol = tol*10._DP**slak
    rm = 0.5_DP*(alim+elim)
    rm = MIN(rm,200._DP)
    rm = MAX(rm,rl+10._DP)
    r2 = MIN(rm,fnul)
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99002)
      99002 FORMAT (' PARAMETERS'/5X,'TOL ',8X,'ELIM',8X,'ALIM',8X,'RL  ',8X,'FNUL',&
        8X,'DIG')
      WRITE (Lun,99003) tol, elim, alim, rl, fnul, dig
      99003 FORMAT (1X,6D12.4/)
    END IF
    !-----------------------------------------------------------------------
    !     Set other constants needed in the tests.
    !-----------------------------------------------------------------------
    halfr = 0.5_DP
    halfi = 0._DP
    hpi = 2._DP*ATAN(1._DP)
    pi = hpi + hpi
    !-----------------------------------------------------------------------
    !     Generate angles for construction of complex Z to be used in tests.
    !-----------------------------------------------------------------------
    !     KDO(K), K = 1,IL  determines which of the IL angles in -PI to PI
    !     are used to compute values of Z.
    !       KDO(K) = 0  means that the index K will be used for one or two
    !                   values of Z, depending on the choice of KEPS(K)
    !              = 1  means that the index K and the corresponding angle
    !                   will be skipped
    !     KEPS(K), K = 1,IL determines which of the angles get incremented
    !     up and down to put values of Z in regions where different
    !     formulae are used.
    !       KEPS(K)  = 0  means that the angle will be used without change
    !                = 1  means that the angle will be incremented up and
    !                   down by EPS
    !     The angles to be used are stored in the T(I) array, I = 1,ITL.
    !-----------------------------------------------------------------------
    IF( MQC/=2 ) THEN
      nl = 2
      il = 5
      DO i = 1, il
        keps(i) = 0
        kdo(i) = 0
      END DO
      nul = 5
      xnu(1) = 0._DP
      xnu(2) = 1._DP
      xnu(3) = 2._DP
      xnu(4) = 0.5_DP*fnul
      xnu(5) = fnul + 1.1_DP
    ELSE
      nl = 4
      il = 13
      DO i = 1, il
        kdo(i) = 0
        keps(i) = 0
      END DO
      kdo(2) = 1
      kdo(6) = 1
      kdo(8) = 1
      kdo(12) = 1
      keps(3) = 1
      keps(4) = 1
      keps(5) = 1
      keps(9) = 1
      keps(10) = 1
      keps(11) = 1
      nul = 6
      xnu(1) = 0._DP
      xnu(2) = 0.6_DP
      xnu(3) = 1.3_DP
      xnu(4) = 2._DP
      xnu(5) = 0.5_DP*fnul
      xnu(6) = fnul + 1.1_DP
    END IF
    i = 2
    eps = 0.01_DP
    film = il - 1
    t(1) = -pi + eps
    DO k = 2, il
      IF( kdo(k)==0 ) THEN
        t(i) = pi*(-il+2*k-1)/film
        IF( keps(k)==0 ) THEN
          ts = t(i)
          t(i) = ts - eps
          i = i + 1
          t(i) = ts + eps
        ELSE
          i = i + 1
        END IF
      END IF
    END DO
    itl = i - 1
    !-----------------------------------------------------------------------
    !     Test values of Z in -PI<arg(Z)<=PI.
    !-----------------------------------------------------------------------
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99004)
      99004 FORMAT (' CHECKS IN THE (Z,FNU) SPACE'/)
    END IF
    lflg = 0
    DO kode = 1, 2
      DO n = 1, nl
        DO nu = 1, nul
          fnu = xnu(nu)
          DO icase = 1, 3
            irb = MIN(2,icase)
            DO ir = irb, 4
              !-------------- switch (icase)
              SELECT CASE (icase)
                CASE (2)
                  r = (2._DP*(4-ir)+r2*(ir-1))/3._DP
                CASE (3)
                  IF( r2>=rm ) EXIT
                  r = (r2*(4-ir)+rm*(ir-1))/3._DP
                CASE DEFAULT
                  r = (eps*(4-ir)+2._DP*(ir-1))/3._DP
              END SELECT
              !-------------- end switch
              gnu = fnu + (n-1)
              DO it = 1, itl
                ct = COS(t(it))
                st = SIN(t(it))
                IF( ABS(ct)<atol ) ct = 0._DP
                IF( ABS(st)<atol ) st = 0._DP
                zr = r*ct
                zi = r*st
                IF( r>=gnu ) THEN
                  !------------------ Cases for abs(Z)>=FNU+N-1
                  CALL ZBESJ(zr,zi,fnu,kode,n,vr,vi,nz,ierr)
                  !------------------ Underflow - skip test for this case.
                  IF( nz/=0 ) CYCLE
                  CALL ZBESH(zr,zi,fnu,kode,1,n,wr,wi,nz1,ierr)
                  CALL ZBESH(zr,zi,fnu,kode,2,n,yr,yi,nz2,ierr)
                  IF( kode==2 ) THEN
                    !-------------------- Adjust scaling of H functions.
                    cc = -zi - ABS(zi)
                    IF( cc>(-alim) ) THEN
                      cwr = cc
                      cwi = zr
                      CALL ZEXP(cwr,cwi,coe1r,coe1i)
                    ELSE
                      coe1r = 0._DP
                      coe1i = 0._DP
                    END IF
                    dd = zi - ABS(zi)
                    IF( dd>(-alim) ) THEN
                      cwr = dd
                      cwi = -zr
                      CALL ZEXP(cwr,cwi,coe2r,coe2i)
                    ELSE
                      coe2r = 0._DP
                      coe2i = 0._DP
                    END IF
                    DO kk = 1, n
                      str = yr(kk)*coe2r - yi(kk)*coe2i
                      yi(kk) = yr(kk)*coe2i + yi(kk)*coe2r
                      yr(kk) = str
                      str = wr(kk)*coe1r - wi(kk)*coe1i
                      wi(kk) = wr(kk)*coe1i + wi(kk)*coe1r
                      wr(kk) = str
                    END DO
                  END IF
                ELSE
                  !------------------ Cases for abs(Z)<FNU+N-1
                  m = n + 16
                  CALL ZBESJ(zr,zi,fnu,kode,m,vr,vi,nz,ierr)
                  !------------------ Underflow at end of sequence - skip test
                  IF( nz>10 ) CYCLE
                  CALL ZBESJ(zr,zi,fnu,kode,n,wr,wi,nz,ierr)
                  DO kk = 1, n
                    yr(kk) = wr(kk)
                    yi(kk) = wi(kk)
                  END DO
                END IF
                !-----------------------------------------------------------------------
                !     If abs(Z)>=FNU+N-1 then the error test compares J(Z<FNU) with
                !     0.5*(H1(Z,FNU) + H2(Z,FNU)).
                !     If abs(Z)<FNU+N-1 then the error test ensures that calculations
                !     begun in one region of the (Z,FNU) plane and carried into another
                !     region do not diverge from calculations carried out entirely in
                !     one region.  This is an internal consistency check.
                !-----------------------------------------------------------------------
                mflg = 0
                DO i = 1, n
                  ab = fnu + i - 1
                  aa = MAX(2._DP,ab)
                  cwr = (wr(i)+yr(i))*halfr - (wi(i)+yi(i))*halfi
                  cwi = (wr(i)+yr(i))*halfi + (wi(i)+yi(i))*halfr
                  av = ZABS(vr(i),vi(i))
                  ar = cwr - vr(i)
                  ai = cwi - vi(i)
                  er = ZABS(ar,ai)
                  IF( av/=0._DP ) THEN
                    IF( zi==0._DP ) THEN
                      IF( ABS(zr)<aa ) er = er/av
                    ELSE
                      er = er/av
                    END IF
                  END IF
                  aer(i) = er
                  IF( er>ertol ) mflg = 1
                END DO
                IF( mflg/=0 ) THEN
                  IF( lflg==0 ) THEN
                    IF( Kprint>=2 ) THEN
                      WRITE (Lun,99005) ertol
                      99005 FORMAT (' CASES WHICH VIOLATE THE RELATIVE ',&
                        'ERROR TEST WITH ERTOL=',D12.4/)
                      WRITE (Lun,99006)
                      99006 FORMAT (' INPUT TO ZBESJ   Z, FNU, KODE, N')
                    END IF
                    IF( Kprint>=3 ) THEN
                      IF( r>=gnu ) THEN
                        WRITE (Lun,99007)
                        99007 FORMAT (' COMPARE WITH AVERAGE OF H1 AND H2 ',&
                          'FUNCTIONS FOR THE SAME INPUT')
                        WRITE (Lun,99008)
                        99008 FORMAT (' RESULTS FROM ZBESJ    NZ, V(KK)')
                        WRITE (Lun,99009)
                        99009 FORMAT (' RESULTS FROM ZBESH   NZ1, W(KK)')
                        WRITE (Lun,99010)
                        99010 FORMAT (' RESULTS FROM ZBESH   NZ2, Y(KK)')
                      ELSE
                        WRITE (Lun,99011)
                        99011 FORMAT (' RESULTS FROM ZBESJ    NZ, W(KK)')
                      END IF
                      WRITE (Lun,99012)
                      99012 FORMAT (' TEST CASE INDICES   IR, IT, ICASE'/)
                    END IF
                  END IF
                  lflg = lflg + 1
                  IF( Kprint>=2 ) THEN
                    WRITE (Lun,99013) zr, zi, fnu, kode, n
                    99013 FORMAT ('   INPUT:   Z=',2D12.4,3X,'FNU=',D12.4,3X,&
                      'KODE=',I3,3X,'N=',I3)
                  END IF
                  IF( Kprint>=3 ) THEN
                    WRITE (Lun,99014) (aer(k),k=1,n)
                    99014 FORMAT ('   ERROR:   AER(K)=',4D12.4)
                    IF( r>=gnu ) THEN
                      kk = MAX(nz1,nz2) + 1
                      kk = MIN(n,kk)
                      WRITE (Lun,99015) nz, vr(kk), vi(kk)
                      99015 FORMAT (' RESULTS:   NZ=',I3,3X,'V(KK)=',2D12.4)
                      WRITE (Lun,99016) nz1, wr(kk), wi(kk)
                      99016 FORMAT (' RESULTS:  NZ1=',I3,3X,'W(KK)=',2D12.4)
                      WRITE (Lun,99017) nz2, yr(kk), yi(kk)
                      99017 FORMAT (' RESULTS:  NZ2=',I3,3X,'Y(KK)=',2D12.4)
                    ELSE
                      kk = n - nz
                      WRITE (Lun,99018) nz, wr(kk), wi(kk)
                      99018 FORMAT (' RESULTS:   NZ=',I3,3X,'W(KK)=',2D12.4)
                    END IF
                    WRITE (Lun,99019) ir, it, icase
                    99019 FORMAT ('    CASE:  IR=',I3,3X,'IT=',I3,3X,'ICASE=',I3/)
                  END IF
                END IF
              END DO
            END DO
          END DO
        END DO
      END DO
    END DO
    IF( Kprint>=2 ) THEN
      IF( lflg==0 ) THEN
        WRITE (Lun,99020)
        99020 FORMAT (' QUICK CHECKS OK')
      ELSE
        WRITE (Lun,99021) lflg
        99021 FORMAT (' ***',I5,' FAILURE(S) FOR ZBESJ IN THE (Z,FNU)',' PLANE')
      END IF
    END IF
    Ipass = 0
    IF( lflg==0 ) Ipass = 1
    IF( Ipass==1 .AND. Kprint>=2 ) THEN
      WRITE (Lun,99022)
      99022 FORMAT (/' ****** ZBESJ  PASSED ALL TESTS  ******'/)
    END IF
    IF( Ipass==0 .AND. Kprint>=1 ) THEN
      WRITE (Lun,99023)
      99023 FORMAT (/' ****** ZBESJ  FAILED SOME TESTS ******'/)
    END IF
  END SUBROUTINE ZQCBJ
  !** ZQCBK
  SUBROUTINE ZQCBK(Lun,Kprint,Ipass)
    !> Quick check for SLATEC subroutine
    !            ZBESK
    !***
    ! **Library:**   SLATEC
    !***
    ! **Category:**  C10B4
    !***
    ! **Type:**      COMPLEX (CQCBK-C, ZQCBK-Z)
    !***
    ! **Keywords:**  QUICK CHECK, ZBESK
    !***
    ! **Author:**  Amos, Don, (SNL)
    !           Goudy, Sue, (SNL)
    !           Walton, Lee, (SNL)
    !***
    ! **Description:**
    !
    !- Usage:
    !
    !        INTEGER  LUN, KPRINT, IPASS
    !
    !        CALL ZQCBK (LUN, KPRINT, IPASS)
    !
    !- Arguments:
    !
    !     LUN    :IN  is the unit number to which output is to be written.
    !
    !     KPRINT :IN  controls the amount of output, as specified in the
    !                 SLATEC Guidelines.
    !
    !     IPASS  :OUT indicates whether the test passed or failed.
    !                 A value of one is good, indicating no failures.
    !
    !- Description:
    !
    !                  *** A DOUBLE PRECISION ROUTINE ***
    !
    !   ZQCBK is a quick check routine for the complex K Bessel function
    !    generated by subroutine ZBESK.
    !
    !   ZQCBK generates sequences of I and K Bessel functions from
    !    ZBESI and ZBESK and checks them against the Wronskian evaluation
    !    in the (Z,FNU) space.
    !
    !***
    ! **References:**  Abramowitz, M. and Stegun, I. A., Handbook
    !                 of Mathematical Functions, Dover Publications,
    !                 New York, 1964.
    !               Amos, D. E., A Subroutine Package for Bessel
    !                 Functions of a Complex Argument and Nonnegative
    !                 Order, SAND85-1018, May, 1985.
    !***
    ! **Routines called:**  ZBESI, ZBESK, ZABS, ZDIV, ZEXP, I1MACH, D1MACH

    !* REVISION HISTORY  (YYMMDD)
    !   830501  DATE WRITTEN
    !   890831  Revised to meet new SLATEC standard
    !   930122  Added ZEXP to EXTERNAL Statement.  (RWC)
    USE slatec, ONLY : ZBESI, ZBESK, ZABS, ZDIV, ZEXP, I1MACH, D1MACH
    !
    !*Internal Notes:
    !   Machine constants are defined by functions I1MACH and D1MACH.
    !
    !   The parameter MQC can have values 1 (the default) for a faster,
    !   less definitive test or 2 for a slower, more definitive test.
    !
    !**End
    !
    !  Set test complexity parameter.
    INTEGER, PARAMETER :: MQC = 1
    !  Declare arguments.
    !
    INTEGER :: Lun, Kprint, Ipass
    !
    !  Declare local variables.
    !
    REAL(DP) :: coner, conei, csgnr, csgni, cvr, cvi, cwr, cwi, &
      cyr, cyi, wr(20), wi(20), yr(20), yi(20), zr, zi, znr, zni
    REAL(DP) :: aa, ab, aer(20), alim, arg, atol, axx, ct, dig, &
      elim, eps, er, ertol, ffnu, film, fnu, fnul, &
      hpi, pi, r, rl, rm, r1m4, r1m5, r2, slak, st, sti, str, t(20), tol, ts, xnu(20)
    INTEGER :: i, icase, ierr, ifnu, il, ir, irb, it, itl, k, kdo(20), &
      keps(20), kk, kode, k1, k2, lflg, mflg, n, nl, nu, nul, nz1, nz2, n1
    !
    !* FIRST EXECUTABLE STATEMENT  ZQCBK
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99001)
      99001 FORMAT (' QUICK CHECK ROUTINE FOR THE K BESSEL FUNCTION FROM ','ZBESK'/)
    END IF
    !-----------------------------------------------------------------------
    !     Set parameters related to machine constants.
    !     TOL is the approximate unit roundoff limited to 1.0D-18.
    !     ELIM is the approximate exponential over- and underflow limit.
    !     exp(-ELIM)<exp(-ALIM)=exp(-ELIM)/TOL    and
    !     exp(ELIM)>exp(ALIM)=exp(ELIM)*TOL       are intervals near
    !     underflow and overflow limits where scaled arithmetic is done.
    !     RL is the lower boundary of the asymptotic expansion for large Z.
    !     DIG = number of base 10 digits in TOL = 10**(-DIG).
    !     FNUL is the lower boundary of the asymptotic series for large FNU.
    !-----------------------------------------------------------------------
    r1m4 = D1MACH(4)
    tol = MAX(r1m4,1.E-18_DP)
    atol = 100._DP*tol
    aa = -LOG10(r1m4)
    k1 = I1MACH(12)
    k2 = I1MACH(13)
    r1m5 = D1MACH(5)
    k = MIN(ABS(k1),ABS(k2))
    elim = 2.303_DP*(k*r1m5-3._DP)
    ab = aa*2.303_DP
    alim = elim + MAX(-ab,-41.45_DP)
    dig = MIN(aa,18._DP)
    fnul = 10._DP + 6._DP*(dig-3._DP)
    rl = 1.2_DP*dig + 3._DP
    slak = 3._DP + 4._DP*(-LOG10(tol)-7._DP)/11._DP
    slak = MAX(slak,3._DP)
    ertol = tol*10._DP**slak
    rm = 0.5_DP*(alim+elim)
    rm = MIN(rm,200._DP)
    rm = MAX(rm,rl+10._DP)
    r2 = MIN(rm,fnul)
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99002)
      99002 FORMAT (' PARAMETERS'/5X,'TOL ',8X,'ELIM',8X,'ALIM',8X,'RL  ',8X,'FNUL',&
        8X,'DIG')
      WRITE (Lun,99003) tol, elim, alim, rl, fnul, dig
      99003 FORMAT (1X,6D12.4/)
    END IF
    !-----------------------------------------------------------------------
    !     Set other constants needed in the tests.
    !-----------------------------------------------------------------------
    coner = 1._DP
    conei = 0._DP
    hpi = 2._DP*ATAN(1._DP)
    pi = hpi + hpi
    !-----------------------------------------------------------------------
    !     Generate angles for construction of complex Z to be used in tests.
    !-----------------------------------------------------------------------
    !     KDO(K), K = 1,IL  determines which of the IL angles in -PI to PI
    !     are used to compute values of Z.
    !       KDO(K) = 0  means that the index K will be used for one or two
    !                   values of Z, depending on the choice of KEPS(K)
    !              = 1  means that the index K and the corresponding angle
    !                   will be skipped
    !     KEPS(K), K = 1,IL determines which of the angles get incremented
    !     up and down to put values of Z in regions where different
    !     formulae are used.
    !       KEPS(K)  = 0  means that the angle will be used without change
    !                = 1  means that the angle will be incremented up and
    !                   down by EPS
    !     The angles to be used are stored in the T(I) array, I = 1,ITL.
    !-----------------------------------------------------------------------
    IF( MQC/=2 ) THEN
      nl = 2
      il = 5
      DO i = 1, il
        keps(i) = 0
        kdo(i) = 0
      END DO
      nul = 5
      xnu(1) = 0._DP
      xnu(2) = 1._DP
      xnu(3) = 2._DP
      xnu(4) = 0.5_DP*fnul
      xnu(5) = fnul + 1.1_DP
    ELSE
      nl = 4
      il = 13
      DO i = 1, il
        kdo(i) = 0
        keps(i) = 0
      END DO
      kdo(2) = 1
      kdo(6) = 1
      kdo(8) = 1
      kdo(12) = 1
      keps(3) = 1
      keps(4) = 1
      keps(5) = 1
      keps(9) = 1
      keps(10) = 1
      keps(11) = 1
      nul = 6
      xnu(1) = 0._DP
      xnu(2) = 0.6_DP
      xnu(3) = 1.3_DP
      xnu(4) = 2._DP
      xnu(5) = 0.5_DP*fnul
      xnu(6) = fnul + 1.1_DP
    END IF
    i = 2
    eps = 0.01_DP
    film = il - 1
    t(1) = -pi + eps
    DO k = 2, il
      IF( kdo(k)==0 ) THEN
        t(i) = pi*(-il+2*k-1)/film
        IF( keps(k)/=0 ) THEN
          ts = t(i)
          t(i) = ts - eps
          i = i + 1
          t(i) = ts + eps
        ELSE
          i = i + 1
        END IF
      END IF
    END DO
    itl = i - 1
    !-----------------------------------------------------------------------
    !     Test values of Z IN -PI<arg(Z)<=PI near formula boundaries.
    !-----------------------------------------------------------------------
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99004)
      99004 FORMAT (' CHECKS IN THE (Z,FNU) SPACE')
    END IF
    lflg = 0
    DO kode = 1, 2
      DO n = 1, nl
        n1 = n + 1
        DO nu = 1, nul
          fnu = xnu(nu)
          ifnu = INT(fnu)
          ffnu = fnu - ifnu
          arg = pi*ffnu
          csgnr = COS(arg)
          csgni = SIN(arg)
          IF( MOD(ifnu,2)==1 ) THEN
            csgnr = -csgnr
            csgni = -csgni
          END IF
          DO icase = 1, 3
            irb = MIN(2,icase)
            DO ir = irb, 4
              !-------------- switch (icase)
              SELECT CASE (icase)
                CASE (2)
                  r = (2._DP*(4-ir)+r2*(ir-1))/3._DP
                CASE (3)
                  IF( r2>=rm ) EXIT
                  r = (r2*(4-ir)+rm*(ir-1))/3._DP
                CASE DEFAULT
                  r = (eps*(4-ir)+2._DP*(ir-1))/3._DP
              END SELECT
              !-------------- end switch
              DO it = 1, itl
                ct = COS(t(it))
                st = SIN(t(it))
                IF( ABS(ct)<atol ) ct = 0._DP
                IF( ABS(st)<atol ) st = 0._DP
                zr = r*ct
                zi = r*st
                CALL ZBESI(zr,zi,fnu,kode,n1,wr,wi,nz2,ierr)
                !---------------- Underflow? - skip test for this case.
                IF( nz2==0 ) THEN
                  !-----------------------------------------------------------------------
                  !     In the left half plane, the analytic continuation formula for K
                  !     introduces an I function. The dominant terms in the Wronskian
                  !     I(FNU,Z)*I(FNU+1,Z) cancel out, giving losses of significance.
                  !     This cancellation can be done analytically to give a Wronskian in
                  !     terms of I in the left half plane and K in the right half plane.
                  !-----------------------------------------------------------------------
                  IF( icase==1 .OR. ct>=0._DP ) THEN
                    !------------------ Z is in the right half plane
                    CALL ZBESK(zr,zi,fnu,kode,n1,yr,yi,nz1,ierr)
                    CALL ZDIV(coner,conei,zr,zi,cvr,cvi)
                    IF( kode==2 ) THEN
                      !-------------------- Adjust Wronskian due to scaled I and K functions
                      axx = ABS(zr)
                      znr = -axx
                      zni = 0._DP
                      cvr = znr + zr
                      cvi = zni + zi
                      CALL ZEXP(cvr,cvi,str,sti)
                      CALL ZDIV(str,sti,zr,zi,cvr,cvi)
                    END IF
                  ELSE
                    !------------------ Z is in the left half plane
                    znr = -zr
                    zni = -zi
                    CALL ZBESK(znr,zni,fnu,kode,n1,yr,yi,nz1,ierr)
                    znr = csgnr
                    zni = csgni
                    !------------------ CSGNR and CSGNI set near top of DO 180 loop
                    IF( st>0._DP .OR. (st==0._DP .AND. ct<0._DP) ) zni = -zni
                    DO kk = 1, n1
                      str = yr(kk)*znr - yi(kk)*zni
                      yi(kk) = yr(kk)*zni + yi(kk)*znr
                      yr(kk) = str
                      znr = -znr
                      zni = -zni
                    END DO
                    CALL ZDIV(coner,conei,zr,zi,cvr,cvi)
                    IF( kode==2 ) THEN
                      !-------------------- Adjust Wronskian due to scaled I and K functions
                      axx = ABS(zr)
                      znr = -axx
                      zni = 0._DP
                      cvr = znr - zr
                      cvi = zni - zi
                      CALL ZEXP(cvr,cvi,str,sti)
                      CALL ZDIV(str,sti,zr,zi,cvr,cvi)
                    END IF
                  END IF
                  mflg = 0
                  DO i = 1, n
                    cwr = wr(i)*yr(i+1) - wi(i)*yi(i+1)
                    cwi = wr(i)*yi(i+1) + wi(i)*yr(i+1)
                    cyr = wr(i+1)*yr(i) - wi(i+1)*yi(i)
                    cyi = wr(i+1)*yi(i) + wi(i+1)*yr(i)
                    cyr = cyr + cwr - cvr
                    cyi = cyi + cwi - cvi
                    er = ZABS(cyr,cyi)/ZABS(cvr,cvi)
                    aer(i) = er
                    IF( er>ertol ) mflg = 1
                  END DO
                  IF( mflg/=0 ) THEN
                    IF( lflg==0 ) THEN
                      IF( Kprint>=2 ) THEN
                        WRITE (Lun,99005) ertol
                        99005 FORMAT (/' CASES WHICH OR VIOLATE THE RELATIVE',&
                          ' ERROR TEST WITH ERTOL = ',D12.4/)
                        WRITE (Lun,99006)
                        99006 FORMAT (' INPUT TO ZBESK   Z, FNU, KODE, N')
                      END IF
                      IF( Kprint>=3 ) THEN
                        WRITE (Lun,99007)
                        99007 FORMAT (' ERROR TEST ON THE WRONSKIAN OF ',&
                          'ZBESI(Z,FNU) AND ZBESK(Z,FNU)')
                        WRITE (Lun,99008)
                        99008 FORMAT (' RESULTS FROM ZBESK   NZ1, Y(KK)'/,&
                          ' RESULTS FROM ZBESI   NZ2, W(KK)')
                        WRITE (Lun,99009)
                        99009 FORMAT (' TEST CASE INDICES   IT, IR, ICASE'/)
                      END IF
                    END IF
                    lflg = lflg + 1
                    IF( Kprint>=2 ) THEN
                      WRITE (Lun,99010) zr, zi, fnu, kode, n
                      99010 FORMAT ('   INPUT:    Z=',2D12.4,4X,'FNU=',D12.4,4X,&
                        'KODE=',I3,4X,'N=',I3)
                    END IF
                    IF( Kprint>=3 ) THEN
                      WRITE (Lun,99011) (aer(k),k=1,n)
                      99011 FORMAT ('   ERROR:  AER(K)=',4D12.4)
                      kk = MAX(nz1,nz2) + 1
                      kk = MIN(n,kk)
                      WRITE (Lun,99012) nz1, yr(kk), yi(kk), nz2, wr(kk), wi(kk)
                      99012 FORMAT (' RESULTS:  NZ1=',I3,4X,'Y(KK)=',2D12.4,/11X,&
                        'NZ2=',I3,4X,'W(KK)=',2D12.4)
                      WRITE (Lun,99013) it, ir, icase
                      99013 FORMAT ('    CASE:   IT=',I3,4X,'IR=',I3,4X,'ICASE=',I3/)
                    END IF
                  END IF
                END IF
              END DO
            END DO
          END DO
        END DO
      END DO
    END DO
    IF( Kprint>=2 ) THEN
      IF( lflg==0 ) THEN
        WRITE (Lun,99014)
        99014 FORMAT (' QUICK CHECKS OK')
      ELSE
        WRITE (Lun,99015) lflg
        99015 FORMAT (' ***',I5,' FAILURE(S) FOR ZBESK NEAR FORMULA ','BOUNDARIES')
      END IF
    END IF
    Ipass = 0
    IF( lflg==0 ) Ipass = 1
    IF( Ipass==1 .AND. Kprint>=2 ) THEN
      WRITE (Lun,99016)
      99016 FORMAT (/' ****** ZBESK  PASSED ALL TESTS  ******'/)
    END IF
    IF( Ipass==0 .AND. Kprint>=1 ) THEN
      WRITE (Lun,99017)
      99017 FORMAT (/' ****** ZBESK  FAILED SOME TESTS ******'/)
    END IF
  END SUBROUTINE ZQCBK
  !** ZQCBY
  SUBROUTINE ZQCBY(Lun,Kprint,Ipass)
    !> Quick check for SLATEC subroutine
    !            ZBESY
    !***
    ! **Library:**   SLATEC
    !***
    ! **Category:**  C10A4
    !***
    ! **Type:**      COMPLEX (CQCBY-C, ZQCBY-Z)
    !***
    ! **Keywords:**  QUICK CHECK, ZBESY
    !***
    ! **Author:**  Amos, Don, (SNL)
    !           Goudy, Sue, (SNL)
    !           Walton, Lee, (SNL)
    !***
    ! **Description:**
    !
    !- Usage:
    !
    !        INTEGER  LUN, KPRINT, IPASS
    !
    !        CALL ZQCBY (LUN, KPRINT, IPASS)
    !
    !- Arguments:
    !
    !     LUN    :IN  is the unit number to which output is to be written.
    !
    !     KPRINT :IN  controls the amount of output, as specified in the
    !                 SLATEC Guidelines.
    !
    !     IPASS  :OUT indicates whether the test passed or failed.
    !                 A value of one is good, indicating no failures.
    !
    !- Description:
    !
    !                 *** A DOUBLE PRECISION ROUTINE ***
    !
    !   ZQCBY is a quick check routine for the complex Y Bessel function
    !    generated by subroutine ZBESY.
    !
    !   ZQCBY generates sequences of Y Bessel functions from ZBESY
    !    and checks them against the evaluation from the formula
    !
    !    Y(FNU,Z*ROT) = C(FNU+1)*I(FNU,Z)-(2/PI)*CONJG(C(FNU))*K(FNU,Z)
    !
    !    where ROT = EXP(PI*I/2), C(FNU)=EXP(PI*FNU*I/2), I**2=-1
    !
    !    and -PI<ARG(Z)<=PI/2, in the (Z,FNU) space.
    !
    !***
    ! **References:**  Abramowitz, M. and Stegun, I. A., Handbook
    !                 of Mathematical Functions, Dover Publications,
    !                 New York, 1964.
    !               Amos, D. E., A Subroutine Package for Bessel
    !                 Functions of a Complex Argument and Nonnegative
    !                 Order, SAND85-1018, May, 1985.
    !***
    ! **Routines called:**  ZBESI, ZBESK, ZBESY, ZABS, ZEXP, I1MACH, D1MACH

    !* REVISION HISTORY  (YYMMDD)
    !   830501  DATE WRITTEN
    !   890831  Revised to meet new SLATEC standards
    !   930122  Added ZEXP to EXTERNAL Statement.  (RWC)
    USE slatec, ONLY : ZBESI, ZBESK, ZBESY, ZABS, ZEXP, I1MACH, D1MACH
    !
    !*Internal Notes:
    !   Machine constants are defined by functions I1MACH and D1MACH.
    !
    !   The parameter MQC can have values 1 (the default) for a faster,
    !   less definitive test or 2 for a slower, more definitive test.
    !
    !**End
    !
    !  Set test complexity parameter.
    INTEGER, PARAMETER :: MQC = 1
    !  Declare arguments.
    INTEGER :: Lun, Kprint, Ipass
    !
    !  Declare local variables.
    !
    REAL(DP) :: coe1r, coe1i, coe2r, coe2i, csgnr, csgni, cspnr, cspni, cwr, &
      cwi, cwrkr(20), cwrki(20), vr(20), vi(20), wr(20), wi(20), yr(20), yi(20), &
      zr, zi, znr, zni
    REAL(DP) :: aa, ab, aer(20), ai, alim, ar, arg, atol, av, cc, &
      ct, dig, elim, eps, er, ertol, ffnu, film, fnu, &
      fnul, hpi, pi, ptr, r, rhpi, rl, rm, r1m4, &
      r1m5, r2, slak, st, sti, str, t(20), tol, ts, xnu(20)
    INTEGER :: i, icase, ierr, ifnu, il, ir, irb, it, itl, i4, k, &
      kdo(20), keps(20), kk, kode, k1, k2, lflg, mflg, n, nl, nu, nul, nz, nz1, nz2
    REAL(DP), PARAMETER :: cipr(4) = [ 1._DP, 0._DP, -1._DP, 0._DP ]
    REAL(DP), PARAMETER :: cipi(4) = [ 0._DP, 1._DP, 0._DP, -1._DP ]
    !
    !* FIRST EXECUTABLE STATEMENT  ZQCBY
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99001)
      99001 FORMAT (' QUICK CHECK ROUTINE FOR THE Y BESSEL FUNCTION FROM ','ZBESY'/)
    END IF
    !-----------------------------------------------------------------------
    !     Set parameters related to machine constants.
    !     TOL is the approximate unit roundoff limited to 1.0D-18.
    !     ELIM is the approximate exponential over- and underflow limit.
    !     exp(-ELIM)<exp(-ALIM)=exp(-ELIM)/TOL    and
    !     exp(ELIM)>exp(ALIM)=exp(ELIM)*TOL       are intervals near
    !     underflow and overflow limits where scaled arithmetic is done.
    !     RL is the lower boundary of the asymptotic expansion for large Z.
    !     DIG = number of base 10 digits in TOL = 10**(-DIG).
    !     FNUL is the lower boundary of the asymptotic series for large FNU.
    !-----------------------------------------------------------------------
    r1m4 = D1MACH(4)
    tol = MAX(r1m4,1.E-18_DP)
    atol = 100._DP*tol
    aa = -LOG10(r1m4)
    k1 = I1MACH(12)
    k2 = I1MACH(13)
    r1m5 = D1MACH(5)
    k = MIN(ABS(k1),ABS(k2))
    elim = 2.303_DP*(k*r1m5-3._DP)
    ab = aa*2.303_DP
    alim = elim + MAX(-ab,-41.45_DP)
    dig = MIN(aa,18._DP)
    fnul = 10._DP + 6._DP*(dig-3._DP)
    rl = 1.2_DP*dig + 3._DP
    slak = 3._DP + 4._DP*(-LOG10(tol)-7._DP)/11._DP
    slak = MAX(slak,3._DP)
    ertol = tol*10._DP**slak
    rm = 0.5_DP*(alim+elim)
    rm = MIN(rm,200._DP)
    rm = MAX(rm,rl+10._DP)
    r2 = MIN(rm,fnul)
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99002)
      99002 FORMAT (' PARAMETERS'/5X,'TOL ',8X,'ELIM',8X,'ALIM',8X,'RL  ',8X,'FNUL',&
        8X,'DIG')
      WRITE (Lun,99003) tol, elim, alim, rl, fnul, dig
      99003 FORMAT (1X,6D12.4/)
    END IF
    !-----------------------------------------------------------------------
    !     Set other constants needed in the tests.
    !-----------------------------------------------------------------------
    hpi = 2._DP*ATAN(1._DP)
    rhpi = 1._DP/hpi
    pi = hpi + hpi
    !-----------------------------------------------------------------------
    !     Generate angles for construction of complex Z to be used in tests.
    !-----------------------------------------------------------------------
    !     KDO(K), K = 1,IL  determines which of the IL angles in -PI to PI
    !     are used to compute values of Z.
    !       KDO(K) = 0  means that the index K will be used for one or two
    !                   values of Z, depending on the choice of KEPS(K)
    !              = 1  means that the index K and the corresponding angle
    !                   will be skipped
    !     KEPS(K), K = 1,IL determines which of the angles get incremented
    !     up and down to put values of Z in regions where different
    !     formulae are used.
    !       KEPS(K)  = 0  means that the angle will be used without change
    !                = 1  means that the angle will be incremented up and
    !                   down by EPS
    !     The angles to be used are stored in the T(I) array, I = 1,ITL.
    !-----------------------------------------------------------------------
    IF( MQC/=2 ) THEN
      nl = 2
      il = 5
      DO i = 1, il
        keps(i) = 0
        kdo(i) = 0
      END DO
      kdo(5) = 1
      nul = 5
      xnu(1) = 0._DP
      xnu(2) = 1._DP
      xnu(3) = 2._DP
      xnu(4) = 0.5_DP*fnul
      xnu(5) = fnul + 1.2_DP
    ELSE
      nl = 4
      il = 13
      DO i = 1, il
        kdo(i) = 0
        keps(i) = 0
      END DO
      kdo(2) = 1
      kdo(6) = 1
      kdo(8) = 1
      kdo(11) = 1
      kdo(12) = 1
      kdo(13) = 1
      keps(3) = 1
      keps(4) = 1
      keps(5) = 1
      keps(9) = 1
      nul = 6
      xnu(1) = 0._DP
      xnu(2) = 0.6_DP
      xnu(3) = 1.3_DP
      xnu(4) = 2._DP
      xnu(5) = 0.5_DP*fnul
      xnu(6) = fnul + 1.2_DP
    END IF
    i = 2
    eps = 0.01_DP
    film = il - 1
    t(1) = -pi + eps
    DO k = 2, il
      IF( kdo(k)==0 ) THEN
        t(i) = pi*(-il+2*k-1)/film
        IF( keps(k)/=0 ) THEN
          ts = t(i)
          t(i) = ts - eps
          i = i + 1
          t(i) = ts + eps
        ELSE
          i = i + 1
        END IF
      END IF
    END DO
    itl = i - 1
    !-----------------------------------------------------------------------
    !     Test values of Z in -PI/2<arg(Z)<=PI
    !-----------------------------------------------------------------------
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99004)
      99004 FORMAT (' CHECKS IN THE (Z,FNU) SPACE')
    END IF
    lflg = 0
    DO kode = 1, 2
      DO n = 1, nl
        DO nu = 1, nul
          !-----------------------------------------------------------------------
          !     Construct values which will be used to set
          !           COE1 = exp(i*(FNU+1)*PI/2) and
          !           COE2 = (2/pi)*exp(-i*FNU*PI/2).
          !-----------------------------------------------------------------------
          fnu = xnu(nu)
          ifnu = INT(fnu)
          ffnu = fnu - ifnu
          arg = hpi*ffnu
          csgnr = COS(arg)
          csgni = SIN(arg)
          i4 = MOD(ifnu,4) + 1
          str = csgnr*cipr(i4) - csgni*cipi(i4)
          csgni = csgnr*cipi(i4) + csgni*cipr(i4)
          csgnr = str
          cspnr = csgnr*rhpi
          cspni = -csgni*rhpi
          !---------- CSGN=CSGN*CI in CQCBY
          str = -csgni
          csgni = csgnr
          csgnr = str
          DO icase = 1, 3
            irb = MIN(2,icase)
            DO ir = irb, 4
              !-------------- switch (icase)
              SELECT CASE (icase)
                CASE (2)
                  r = (2._DP*(4-ir)+r2*(ir-1))/3._DP
                CASE (3)
                  IF( r2>=rm ) EXIT
                  r = (r2*(4-ir)+rm*(ir-1))/3._DP
                CASE DEFAULT
                  r = (eps*(4-ir)+2._DP*(ir-1))/3._DP
              END SELECT
              !-------------- end switch
              DO it = 1, itl
                ct = COS(t(it))
                st = SIN(t(it))
                IF( ABS(ct)<atol ) ct = 0._DP
                IF( ABS(st)<atol ) st = 0._DP
                zr = r*ct
                zi = r*st
                CALL ZBESI(zr,zi,fnu,kode,n,wr,wi,nz2,ierr)
                !---------------- Underflow in ZBESI - skip test for this case.
                IF( nz2==0 ) THEN
                  CALL ZBESK(zr,zi,fnu,kode,n,yr,yi,nz1,ierr)
                  !---------------- Underflow in ZBESK - skip test for this case.
                  IF( nz1==0 ) THEN
                    znr = -zi
                    zni = zr
                    CALL ZBESY(znr,zni,fnu,kode,n,vr,vi,nz,cwrkr,cwrki,ierr)
                    !---------------- Underflow in ZBESY - skip test for this case.
                    IF( nz==0 ) THEN
                      coe1r = csgnr
                      coe1i = csgni
                      coe2r = cspnr
                      coe2i = cspni
                      IF( kode==2 ) THEN
                        !------------------ Adjust scale for I and K functions.
                        cc = -zr - ABS(zr)
                        IF( cc>(-alim) ) THEN
                          znr = cc
                          zni = -zi
                          CALL ZEXP(znr,zni,str,sti)
                          ptr = str*coe2r - sti*coe2i
                          coe2i = str*coe2i + sti*coe2r
                          coe2r = ptr
                        ELSE
                          !-------------------- Scaling problem - skip test for this case
                          coe2r = 0._DP
                          coe2i = 0._DP
                          CYCLE
                        END IF
                      END IF
                      DO kk = 1, n
                        str = yr(kk)*coe2r - yi(kk)*coe2i
                        yi(kk) = yr(kk)*coe2i + yi(kk)*coe2r
                        yr(kk) = str
                        str = wr(kk)*coe1r - wi(kk)*coe1i
                        wi(kk) = wr(kk)*coe1i + wi(kk)*coe1r
                        wr(kk) = str
                        str = -coe1i
                        coe1i = coe1r
                        coe1r = str
                        str = coe2i
                        coe2i = -coe2r
                        coe2r = str
                      END DO
                      !-----------------------------------------------------------------------
                      !     Compare Y(ZN,FNU) with COE1*I(Z,FNU)-COE2*K(Z,FNU).
                      !-----------------------------------------------------------------------
                      mflg = 0
                      DO i = 1, n
                        ab = fnu + i - 1
                        aa = MAX(0.5_DP,ab)
                        cwr = wr(i) - yr(i)
                        cwi = wi(i) - yi(i)
                        av = ZABS(vr(i),vi(i))
                        ar = cwr - vr(i)
                        ai = cwi - vi(i)
                        er = ZABS(ar,ai)
                        IF( av/=0._DP ) THEN
                          IF( zni/=0._DP ) THEN
                            er = er/av
                          ELSEIF( znr>0._DP ) THEN
                            IF( ABS(znr)<aa ) er = er/av
                          ELSEIF( ABS(ffnu-0.5_DP)<0.125_DP ) THEN
                            IF( ABS(znr)<aa ) er = er/av
                          ELSE
                            er = er/av
                          END IF
                        END IF
                        aer(i) = er
                        IF( er>ertol ) mflg = 1
                      END DO
                      IF( mflg/=0 ) THEN
                        IF( lflg==0 ) THEN
                          IF( Kprint>=2 ) THEN
                            WRITE (Lun,99005) ertol
                            99005 FORMAT (/' CASES WHICH VIOLATE THE RELATIVE ',&
                              'ERROR TEST WITH ERTOL = ',D12.4/)
                            WRITE (Lun,99006)
                            99006 FORMAT (' INPUT TO ZBESY   ZN, FNU, KODE, N')
                          END IF
                          IF( Kprint>=3 ) THEN
                            WRITE (Lun,99007)
                            99007 FORMAT (' COMPARE Y(ZN,FNU) WITH COE1*I(Z,FNU)',&
                              '-COE2*K(Z,FNU)')
                            WRITE (Lun,99008)
                            99008 FORMAT (' Z = ZN*EXP(-i*PI/2)'/&
                              ' COE1 = EXP(i*(FNU+1)*PI/2)  ',&
                              ' COE2 = (2/PI)*EXP(-i*FNU*PI/2)')
                            WRITE (Lun,99009)
                            99009 FORMAT (' RESULTS FROM ZBESY   V(KK)'/9X,&
                              'FROM ZBESI   W(KK)'/9X,&
                              'FROM ZBESK   Y(KK)')
                            WRITE (Lun,99010)
                            99010 FORMAT (' TEST CASE INDICES   IR, IT, ICASE'/)
                          END IF
                        END IF
                        lflg = lflg + 1
                        IF( Kprint>=2 ) THEN
                          WRITE (Lun,99011) znr, zni, fnu, kode, n
                          99011 FORMAT ('   INPUT:   ZN=',2D12.4,3X,'FNU=',D12.4,3X,&
                            'KODE=',I3,3X,'N=',I3)
                        END IF
                        IF( Kprint>=3 ) THEN
                          WRITE (Lun,99012) (aer(k),k=1,n)
                          99012 FORMAT ('   ERROR:   AER(K)=',4D12.4)
                          WRITE (Lun,99013) zr, zi, coe1r, coe1i, coe2r, coe2r
                          99013 FORMAT (12X,'Z=',2D12.4/12X,'COE1=',2D12.4,3X,&
                            'COE2=',2D12.4)
                          kk = MAX(nz1,nz2) + 1
                          kk = MIN(n,kk)
                          WRITE (Lun,99014) vr(kk), vi(kk), wr(kk), wi(kk)&
                            , yr(kk), yi(kk)
                          99014 FORMAT (' RESULTS:   V(KK)=',2D12.4/12X,'W(KK)=',&
                            2D12.4/12X,'Y(KK)=',2D12.4)
                          WRITE (Lun,99015) ir, it, icase
                          99015 FORMAT ('    CASE:   IR=',I3,3X,'IT=',I3,3X,&
                            'ICASE=',I3/)
                        END IF
                      END IF
                    END IF
                  END IF
                END IF
              END DO
            END DO
          END DO
        END DO
      END DO
    END DO
    IF( Kprint>=2 ) THEN
      IF( lflg==0 ) THEN
        WRITE (Lun,99016)
        99016 FORMAT (' QUICK CHECKS OK')
      ELSE
        WRITE (Lun,99017) lflg
        99017 FORMAT (' ***',I5,' FAILURE(S) FOR ZBESY IN THE (Z,FNU) ','PLANE')
      END IF
    END IF
    Ipass = 0
    IF( lflg==0 ) Ipass = 1
    IF( Ipass==1 .AND. Kprint>=2 ) THEN
      WRITE (Lun,99018)
      99018 FORMAT (/' ****** ZBESY  PASSED ALL TESTS  ******'/)
    END IF
    IF( Ipass==0 .AND. Kprint>=1 ) THEN
      WRITE (Lun,99019)
      99019 FORMAT (/' ****** ZBESY  FAILED SOME TESTS ******'/)
    END IF
  END SUBROUTINE ZQCBY
END MODULE TEST10_MOD
!** TEST10
PROGRAM TEST10
  USE TEST10_MOD, ONLY : ZQCAI, ZQCBH, ZQCBI, ZQCBJ, ZQCBK, ZQCBY
  USE slatec, ONLY : I1MACH, XSETF, XSETUN, XERMAX
  USE common_mod, ONLY : GET_ARGUMENT
  IMPLICIT NONE
  !> Driver for testing SLATEC subprograms.
  !***
  ! **Library:**   SLATEC
  !***
  ! **Category:**  C7A, C10A4, C10B4, C10D
  !***
  ! **Type:**      DOUBLE PRECISION (TEST09-S, TEST10-D)
  !***
  ! **Keywords:**  QUICK CHECK DRIVER
  !***
  ! **Author:**  SLATEC Common Mathematical Library Committee
  !***
  ! **Description:**
  !
  !- Usage:
  !     One input data record is required
  !         READ (LIN, '(I1)') KPRINT
  !
  !- Arguments:
  !     KPRINT = 0  Quick checks - No printing.
  !                 Driver       - Short pass or fail message printed.
  !              1  Quick checks - No message printed for passed tests,
  !                                short message printed for failed tests.
  !                 Driver       - Short pass or fail message printed.
  !              2  Quick checks - Print short message for passed tests,
  !                                fuller information for failed tests.
  !                 Driver       - Pass or fail message printed.
  !              3  Quick checks - Print complete quick check results.
  !                 Driver       - Pass or fail message printed.
  !
  !- Description:
  !     Driver for testing SLATEC subprograms
  !               ZABS, ZAIRY, ZBESH, ZBESI, ZBESJ, ZBESK, ZBESY, ZBIRY,
  !               ZDIV, ZEXP, ZSQRT, ZUOIK, ZWRSK
  !
  !***
  ! **References:**  Fong, Kirby W., Jefferson, Thomas H., Suyehiro,
  !                 Tokihiko, Walton, Lee, Guidelines to the SLATEC Common
  !                 Mathematical Library, March 21, 1989.
  !***
  ! **Routines called:**  I1MACH, XERMAX, XSETF, XSETUN, ZQCAI, ZQCBH, ZQCBI,
  !                    ZQCBJ, ZQCBK, ZQCBY

  !* REVISION HISTORY  (YYMMDD)
  !   910411  DATE WRITTEN
  !   920128  Category corrected.  (WRB)

  INTEGER :: ipass, kprint, lin, lun, nfail
  !* FIRST EXECUTABLE STATEMENT  TEST10
  lun = I1MACH(2)
  lin = I1MACH(1)
  nfail = 0
  !
  !     Read KPRINT parameter
  !
  CALL GET_ARGUMENT(kprint)
  CALL XERMAX(1000)
  CALL XSETUN(lun)
  IF( kprint<=1 ) THEN
    CALL XSETF(0)
  ELSE
    CALL XSETF(1)
  END IF
  !
  !     Test Double Precision Complex Bessel Functions.
  !
  CALL ZQCAI(lun,kprint,ipass)
  IF( ipass==0 ) nfail = nfail + 1
  CALL ZQCBH(lun,kprint,ipass)
  IF( ipass==0 ) nfail = nfail + 1
  CALL ZQCBI(lun,kprint,ipass)
  IF( ipass==0 ) nfail = nfail + 1
  CALL ZQCBJ(lun,kprint,ipass)
  IF( ipass==0 ) nfail = nfail + 1
  CALL ZQCBK(lun,kprint,ipass)
  IF( ipass==0 ) nfail = nfail + 1
  CALL ZQCBY(lun,kprint,ipass)
  IF( ipass==0 ) nfail = nfail + 1
  !
  !     Write PASS or FAIL message
  !
  IF( nfail==0 ) THEN
    WRITE (lun,99001)
    99001 FORMAT (/' --------------TEST10 PASSED ALL TESTS----------------')
  ELSE
    WRITE (lun,99002) nfail
    99002 FORMAT (/' ************* WARNING -- ',I5,&
      ' TEST(S) FAILED IN PROGRAM TEST10  *************')
  END IF
  STOP
END PROGRAM TEST10
