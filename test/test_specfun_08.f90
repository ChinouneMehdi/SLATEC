MODULE TEST09_MOD
  USE service, ONLY : SP, DP
  IMPLICIT NONE

CONTAINS
  !** CQCAI
  SUBROUTINE CQCAI(Lun,Kprint,Ipass)
    !> Quick check for SLATEC subroutines
    !            CAIRY, CBIRY
    !***
    ! **Library:**   SLATEC
    !***
    ! **Category:**  C10D
    !***
    ! **Type:**      COMPLEX (CQCAI-C, ZQCAI-Z)
    !***
    ! **Keywords:**  QUICK CHECK, CAIRY, CBIRY
    !***
    ! **Author:**  Amos, Don, (SNL)
    !           Goudy, Sue, (SNL)
    !           Walton, Lee, (SNL)
    !***
    ! **Description:**
    !
    !- Usage:
    !
    !        INTEGER  LUN, KPRINT, IPASS
    !
    !        CALL CQCAI (LUN, KPRINT, IPASS)
    !
    !- Arguments:
    !
    !     LUN    :IN  is the unit number to which output is to be written.
    !
    !     KPRINT :IN  controls the amount of output, as specified in the
    !                 SLATEC Guidelines.
    !
    !     IPASS  :OUT indicates whether the test passed or failed.
    !                 A value of one is good, indicating no failures.
    !
    !- Description:
    !
    !   CQCAI is a quick check routine for the complex Airy functions
    !    generated by subroutines CAIRY and CBIRY.
    !
    !   CQCAI generates Airy functions and their derivatives from CAIRY
    !    and CBIRY and checks them against the Wronskian evaluation
    !    in the Z plane.
    !
    !***
    ! **References:**  Abramowitz, M. and Stegun, I. A., Handbook
    !                 of Mathematical Functions, Dover Publications,
    !                 New York, 1964.
    !               Amos, D. E., A Subroutine Package for Bessel
    !                 Functions of a Complex Argument and Nonnegative
    !                 Order, SAND85-1018, May, 1985.
    !***
    ! **Routines called:**  CAIRY, CBIRY, I1MACH, R1MACH

    !* REVISION HISTORY  (YYMMDD)
    !   830501  DATE WRITTEN
    !   890831  Revised to meet new SLATEC standards
    !
    USE slatec, ONLY : CAIRY, CBIRY, I1MACH, R1MACH
    !
    !*Internal Notes:
    !   Machine constants are defined by functions I1MACH and R1MACH.
    !
    !   The parameter MQC can have values 1 (the default) for a faster,
    !   less definitive test or 2 for a slower, more definitive test.
    !
    !**End
    !
    !  Set test complexity parameter.
    INTEGER, PARAMETER :: MQC = 1
    !  Declare arguments.
    !
    INTEGER :: Lun, Kprint, Ipass
    !
    !  Declare local variables.
    !
    COMPLEX(SP) :: con1, con2, con3, cv, cw, cy, w(20), y(20), z, zr
    REAL(SP) :: aa, ab, acw, acy, alim, arg, arzr, atol, av, a1, a2, ct, &
      c23, dig, elim, eps, er, ertol, film, fnul, fpi, hpi, pi, &
      pi3, r, rl, rm, rpi, rtpi, rzr, r1m4, r1m5, slak, spi, &
      st, t(20), tol, tpi, tpi3, ts
    INTEGER :: i, icase, icl, ierr, il, ir, irb, irset, it, itl, k, &
      kdo(20), keps(20), kode, k1, k2, lflg, nz1, nz2, nz3, nz4
    !
    !* FIRST EXECUTABLE STATEMENT  CQCAI
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99001)
      99001 FORMAT (' QUICK CHECK ROUTINE FOR THE AIRY FUNCTIONS FROM ',&
        'CAIRY AND CBIRY'/)
    END IF
    !-----------------------------------------------------------------------
    !     Set parameters related to machine constants.
    !     TOL is the approximate unit roundoff limited to 1.0E-18.
    !     ELIM is the approximate exponential over- and underflow limit.
    !     exp(-ELIM)<exp(-ALIM)=exp(-ELIM)/TOL    and
    !     exp(ELIM)>exp(ALIM)=exp(ELIM)*TOL       are intervals near
    !     underflow and overflow limits where scaled arithmetic is done.
    !     RL is the lower boundary of the asymptotic expansion for large Z.
    !     DIG = number of base 10 digits in TOL = 10**(-DIG).
    !     FNUL is the lower boundary of the asymptotic series for large FNU.
    !-----------------------------------------------------------------------
    r1m4 = R1MACH(4)
    tol = MAX(r1m4,1.E-18_SP)
    atol = 100._SP*tol
    aa = -LOG10(r1m4)
    k1 = I1MACH(12)
    k2 = I1MACH(13)
    r1m5 = R1MACH(5)
    k = MIN(ABS(k1),ABS(k2))
    elim = 2.303_SP*(k*r1m5-3._SP)
    ab = aa*2.303_SP
    alim = elim + MAX(-ab,-41.45_SP)
    dig = MIN(aa,18._SP)
    slak = 3._SP + 4._SP*(-LOG10(tol)-7._SP)/11._SP
    slak = MAX(slak,3._SP)
    ertol = tol*10._SP**slak
    rl = 1.2_SP*dig + 3._SP
    rm = 0.5_SP*(alim+elim)
    rm = MIN(rm,200._SP)
    rm = MAX(rm,rl+10._SP)
    fnul = 10._SP + 6._SP*(dig-3._SP)
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99002)
      99002 FORMAT (' PARAMETERS'/5X,'TOL ',8X,'ELIM',8X,'ALIM',8X,'RL  ',8X,'FNUL',&
        8X,'DIG')
      WRITE (Lun,99003) tol, elim, alim, rl, fnul, dig
      99003 FORMAT (6E12.4/)
    END IF
    !-----------------------------------------------------------------------
    !     Generate angles for construction of complex Z to be used in tests.
    !-----------------------------------------------------------------------
    fpi = ATAN(1._SP)
    hpi = fpi + fpi
    pi = hpi + hpi
    tpi = pi + pi
    rpi = 1._SP/pi
    tpi3 = tpi/3._SP
    spi = pi/6._SP
    pi3 = spi + spi
    rtpi = 1._SP/tpi
    a1 = rtpi*COS(spi)
    a2 = rtpi*SIN(spi)
    con1 = CMPLX(COS(tpi3),SIN(tpi3),SP)
    con2 = CMPLX(a1,-a2,SP)
    con3 = CMPLX(rpi,0._SP,SP)
    c23 = 2._SP/3._SP
    !-----------------------------------------------------------------------
    !     KDO(K), K = 1,IL  determines which of the IL angles in -PI to PI
    !     are used to compute values of Z.
    !       KDO(K) = 0  means that the index K will be used for one or two
    !                   values of Z, depending on the choice of KEPS(K)
    !              = 1  means that the index K and the corresponding angle
    !                   will be skipped
    !     KEPS(K), K = 1,IL determines which of the angles get incremented
    !     up and down to put values of Z in regions where different
    !     formulae are used.
    !       KEPS(K)  = 0  means that the angle will be used without change
    !                = 1  means that the angle will be incremented up and
    !                   down by EPS
    !     The angles to be used are stored in the T(I) array, I = 1,ITL.
    !-----------------------------------------------------------------------
    IF( MQC/=2 ) THEN
      icl = 1
      il = 5
      DO i = 1, il
        kdo(i) = 0
        keps(i) = 0
      END DO
    ELSE
      icl = 2
      il = 7
      DO i = 1, il
        kdo(i) = 0
        keps(i) = 0
      END DO
      keps(2) = 1
      keps(3) = 1
      keps(5) = 1
      keps(6) = 1
    END IF
    i = 2
    eps = 0.01_SP
    film = il - 1
    t(1) = -pi + eps
    DO k = 2, il
      IF( kdo(k)==0 ) THEN
        t(i) = pi*(-il+2*k-1)/film
        IF( keps(k)/=0 ) THEN
          ts = t(i)
          t(i) = ts - eps
          i = i + 1
          t(i) = ts + eps
        END IF
        i = i + 1
      END IF
    END DO
    itl = i - 1
    !-----------------------------------------------------------------------
    !     Test values of Z in -PI<arg(Z)<=PI near formula boundaries.
    !-----------------------------------------------------------------------
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99004)
      99004 FORMAT (' CHECKS IN THE Z PLANE'/)
    END IF
    lflg = 0
    DO icase = 1, icl
      !-----------------------------------------------------------------------
      !     ICASE = 1 computes wron(AI(Z),BI(Z))     =CON3
      !     ICASE = 2 computes wron(AI(Z),AI(Z*CON1))=CON2
      !-----------------------------------------------------------------------
      DO kode = 1, 2
        DO irset = 1, 3
          irb = MIN(irset,2)
          DO ir = irb, 4
            !------------ switch (irset)
            SELECT CASE (irset)
              CASE (2)
                r = (2._SP*(4-ir)+rl*(ir-1))/3._SP
              CASE (3)
                r = (rl*(4-ir)+rm*(ir-1))/3._SP
              CASE DEFAULT
                r = 2._SP*(ir-1)/3._SP
            END SELECT
            !------------ end switch
            DO it = 1, itl
              !----------------------------------------------------------------------
              !     The following values are set before the DO 30 loop:
              !            C23 = 2/3
              !           CON1 = cmplx(cos(2PI/3),sin(2PI/3))
              !           CON2 = cmplx(cos(PI/6),-sin(PI/6)/2PI
              !           CON3 = cmplx(1/PI,0)
              !----------------------------------------------------------------------
              ct = COS(t(it))
              st = SIN(t(it))
              IF( ABS(ct)<atol ) ct = 0._SP
              IF( ABS(st)<atol ) st = 0._SP
              z = CMPLX(r*ct,r*st,SP)
              zr = CMPLX(c23,0._SP,SP)*z*SQRT(z)
              rzr = REAL(zr)
              arzr = ABS(rzr)
              !-------------- Check for possible underflow or overflow
              IF( arzr/=0._SP ) THEN
                arg = -arzr - 0.5_SP*LOG(arzr) + 0.226_SP
                arg = arg + arg
                !---------------- Skip test for this case?
                IF( arg<(-elim) ) CYCLE
              END IF
              CALL CAIRY(z,0,kode,y(1),nz1,ierr)
              CALL CAIRY(z,1,kode,y(2),nz2,ierr)
              IF( icase==1 ) THEN
                !---------------- Compare 1/PI with Wronskian of CAIRY(Z) and CBIRY(Z).
                CALL CBIRY(z,0,kode,w(1),ierr)
                CALL CBIRY(z,1,kode,w(2),ierr)
                IF( kode==2 ) THEN
                  !-----------------------------------------------------------------------
                  !     When KODE = 2, the scaling factor exp(-zeta1-zeta2) is 1.0 for
                  !     -PI<arg(Z)<=PI/3 and exp(-2.0*zeta1) for PI/3<arg(Z)
                  !     <=PI where zeta1 = zeta2 in this range. This is due to the fact
                  !     that arg(Z*CON1) is taken to be in (-PI,PI) by the principal
                  !     square root.
                  !-----------------------------------------------------------------------
                  !------------------ Adjust scaling factor.
                  cv = CMPLX(arzr,0._SP,SP) - zr
                  cv = EXP(cv)
                  w(1) = w(1)*cv
                  w(2) = w(2)*cv
                END IF
                cv = con3
              ELSE
                !---------------- Compare exp(-i*PI/6)/2PI with Wronskian of CAIRY(Z)
                !                 and CAIRY(Z*exp(2i*PI/3)).
                cv = z*con1
                CALL CAIRY(cv,0,kode,w(1),nz3,ierr)
                CALL CAIRY(cv,1,kode,w(2),nz4,ierr)
                IF( kode==2 ) THEN
                  IF( t(it)>=pi3 ) THEN
                    !-------------------- Adjust scaling factor.
                    cv = zr + zr
                    cv = EXP(-cv)
                    w(1) = w(1)*cv
                    w(2) = w(2)*cv
                  END IF
                END IF
                w(2) = w(2)*con1
                cv = con2
              END IF
              !-----------------------------------------------------------------------
              !     Error relative to maximum term
              !-----------------------------------------------------------------------
              av = ABS(cv)
              cw = y(1)*w(2)
              cy = y(2)*w(1)
              cy = cw - cy - cv
              acy = ABS(y(1))*ABS(w(2))
              acw = ABS(w(1))*ABS(y(2))
              av = MAX(acw,acy,av)
              er = ABS(cy)/av
              IF( er>=ertol ) THEN
                IF( lflg==0 ) THEN
                  IF( Kprint>=2 ) THEN
                    WRITE (Lun,99005) ertol
                    99005 FORMAT (' CASES WHICH VIOLATE THE RELATIVE ERROR',&
                      ' TEST WITH ERTOL = ',E12.4/)
                    WRITE (Lun,99006)
                    99006 FORMAT (' INPUT TO CAIRY AND ERROR')
                  END IF
                  IF( Kprint>=3 ) THEN
                    WRITE (Lun,99007)
                    99007 FORMAT (' COMPARISON VALUE AND WRONSKIAN')
                    WRITE (Lun,99008)
                    99008 FORMAT (' RESULTS FROM CAIRY AND/OR CBIRY')
                    WRITE (Lun,99009)
                    99009 FORMAT (' TEST CASE INDICES'/)
                  END IF
                END IF
                lflg = 1
                IF( Kprint>=2 ) THEN
                  WRITE (Lun,99010) z, er
                  99010 FORMAT (12X,'INPUT:    Z=',2E12.4,5X,'ERROR:   ER=',E12.4)
                END IF
                IF( Kprint>=3 ) THEN
                  WRITE (Lun,99011) cv, cy
                  99011 FORMAT (' COMPARISON VALUE:   CV=',2E12.4/8X,&
                    'WRONSKIAN:   CY=',2E12.4)
                  WRITE (Lun,99012) nz1, y(1), nz2, y(2)
                  99012 FORMAT (10X,'RESULTS:  NZ1=',I3,4X,'Y(1)=',2E12.4/20X,&
                    'NZ2=',I3,4X,'Y(2)=',2E12.4)
                  IF( icase==1 ) THEN
                    WRITE (Lun,99013) w(1), w(2)
                    99013 FORMAT (31X,'W(1)=',2E12.4/31X,'W(2)=',2E12.4)
                  ELSE
                    WRITE (Lun,99014) nz3, w(1), nz4, w(2)
                    99014 FORMAT (20X,'NZ3=',I3,4X,'W(1)=',2E12.4/20X,'NZ4=',I3,4X,&
                      'W(2)=',2E12.4)
                  END IF
                  WRITE (Lun,99015) it, ir, irset, icase
                  99015 FORMAT (13X,'CASE:   IT=',I3,4X,'IR=',I3,4X,'IRSET=',I3,4X,&
                    'ICASE=',I3,4X/)
                END IF
              END IF
            END DO
          END DO
        END DO
      END DO
    END DO
    IF( Kprint>=2 ) THEN
      IF( lflg==0 ) THEN
        WRITE (Lun,99016)
        99016 FORMAT (' QUICK CHECKS OK')
      ELSE
        WRITE (Lun,99017)
        99017 FORMAT (' ***',5X,'FAILURE(S) FOR CAIRY IN THE Z PLANE')
      END IF
    END IF
    Ipass = 0
    IF( lflg==0 ) Ipass = 1
    IF( Ipass==1 .AND. Kprint>=2 ) THEN
      WRITE (Lun,99018)
      99018 FORMAT (/' ****** CAIRY  PASSED ALL TESTS  ******'/)
    END IF
    IF( Ipass==0 .AND. Kprint>=1 ) THEN
      WRITE (Lun,99019)
      99019 FORMAT (/' ****** CAIRY  FAILED SOME TESTS ******'/)
    END IF
  END SUBROUTINE CQCAI
  !** CQCBH
  SUBROUTINE CQCBH(Lun,Kprint,Ipass)
    !> Quick check for SLATEC subroutine
    !            CBESH
    !***
    ! **Library:**   SLATEC
    !***
    ! **Category:**  C10A4
    !***
    ! **Type:**      COMPLEX (CQCBH-C, ZQCBH-Z)
    !***
    ! **Keywords:**  QUICK CHECK, CBESH
    !***
    ! **Author:**  Amos, Don, (SNL)
    !           Goudy, Sue, (SNL)
    !           Walton, Lee, (SNL)
    !***
    ! **Description:**
    !
    !- Usage:
    !
    !        INTEGER  LUN, KPRINT, IPASS
    !
    !        CALL CQCBH (LUN, KPRINT, IPASS)
    !
    !- Arguments:
    !
    !     LUN    :IN  is the unit number to which output is to be written.
    !
    !     KPRINT :IN  controls the amount of output, as specified in the
    !                 SLATEC Guidelines.
    !
    !     IPASS  :OUT indicates whether the test passed or failed.
    !                 A value of one is good, indicating no failures.
    !
    !- Description:
    !
    !   CQCBH is a quick check routine for the complex H Bessel functions
    !    generated by subroutine CBESH.
    !
    !   CQCBH generates sequences of H Bessel functions for kinds 1 and 2
    !    from CBESH and checks them against the Wronskian evaluation
    !    in the (Z,FNU) space.
    !
    !***
    ! **References:**  Abramowitz, M. and Stegun, I. A., Handbook
    !                 of Mathematical Functions, Dover Publications,
    !                 New York, 1964.
    !               Amos, D. E., A Subroutine Package for Bessel
    !                 Functions of a Complex Argument and Nonnegative
    !                 Order, SAND85-1018, May, 1985.
    !***
    ! **Routines called:**  CBESH, CUOIK, I1MACH, R1MACH

    !* REVISION HISTORY  (YYMMDD)
    !   830501  DATE WRITTEN
    !   890831  Revised to meet new SLATEC standards
    !
    USE slatec, ONLY : CBESH, CUOIK, I1MACH, R1MACH
    !
    !*Internal Notes:
    !   Machine constants are defined by functions I1MACH and R1MACH.
    !
    !   The parameter MQC can have values 1 (the default) for a faster,
    !   less definitive test or 2 for a slower, more definitive test.
    !
    !**End
    !
    !  Set test complexity parameter.
    INTEGER, PARAMETER :: MQC = 1
    !  Declare arguments.
    !
    INTEGER :: Lun, Kprint, Ipass
    !
    !  Declare local variables.
    !
    COMPLEX(SP) :: cv, cw, cy, w(20), y(20), z, zn
    REAL(SP) :: aa, ab, acw, acy, aer(20), alim, atol, av, aw, ay, az, ct, &
      dig, elim, eps, er, ertol, film, fnu, fnul, fpi, hpi, pi, &
      r, rfpi, rl, rm, r1m4, r1m5, r2, slak, st, t(20), tol, ts, xnu(20)
    INTEGER :: i, icase, ierr, il, ir, irb, it, itl, k, kdo(20), keps(20), &
      kk, kode, k1, k2, lflg, mflg, n, nl, nu, nul, nz1, nz2, n1
    !
    !* FIRST EXECUTABLE STATEMENT  CQCBH
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99001)
      99001 FORMAT (' QUICK CHECK ROUTINE FOR THE H BESSEL FUNCTIONS FROM ','CBESH'/)
    END IF
    !-----------------------------------------------------------------------
    !     Set parameters related to machine constants.
    !     TOL is the approximate unit roundoff limited to 1.0E-18.
    !     ELIM is the approximate exponential over- and underflow limit.
    !     exp(-ELIM)<exp(-ALIM)=exp(-ELIM)/TOL    and
    !     exp(ELIM)>exp(ALIM)=exp(ELIM)*TOL       are intervals near
    !     underflow and overflow limits where scaled arithmetic is done.
    !     RL is the lower boundary of the asymptotic expansion for large Z.
    !     DIG = number of base 10 digits in TOL = 10**(-DIG).
    !     FNUL is the lower boundary of the asymptotic series for large FNU.
    !-----------------------------------------------------------------------
    r1m4 = R1MACH(4)
    tol = MAX(r1m4,1.E-18_SP)
    atol = 100._SP*tol
    aa = -LOG10(r1m4)
    k1 = I1MACH(12)
    k2 = I1MACH(13)
    r1m5 = R1MACH(5)
    k = MIN(ABS(k1),ABS(k2))
    elim = 2.303_SP*(k*r1m5-3._SP)
    ab = aa*2.303_SP
    alim = elim + MAX(-ab,-41.45_SP)
    dig = MIN(aa,18._SP)
    fnul = 10._SP + 6._SP*(dig-3._SP)
    rl = 1.2_SP*dig + 3._SP
    slak = 3._SP + 4._SP*(-LOG10(tol)-7._SP)/11._SP
    slak = MAX(slak,3._SP)
    ertol = tol*10._SP**slak
    rm = 0.5_SP*(alim+elim)
    rm = MIN(rm,200._SP)
    rm = MAX(rm,rl+10._SP)
    r2 = MIN(fnul,rm)
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99002)
      99002 FORMAT (' PARAMETERS'/5X,'TOL ',8X,'ELIM',8X,'ALIM',8X,'RL  ',8X,'FNUL',&
        8X,'DIG')
      WRITE (Lun,99003) tol, elim, alim, rl, fnul, dig
      99003 FORMAT (6E12.4/)
    END IF
    !-----------------------------------------------------------------------
    !     Set other constants needed in the tests.
    !-----------------------------------------------------------------------
    fpi = ATAN(1._SP)
    hpi = fpi + fpi
    pi = hpi + hpi
    rfpi = 1._SP/fpi
    zn = CMPLX(0._SP,-rfpi,SP)
    !-----------------------------------------------------------------------
    !     Generate angles for construction of complex Z to be used in tests.
    !-----------------------------------------------------------------------
    !     KDO(K), K = 1,IL  determines which of the IL angles in -PI to PI
    !     are used to compute values of Z.
    !       KDO(K) = 0  means that the index K will be used for one or two
    !                   values of Z, depending on the choice of KEPS(K)
    !              = 1  means that the index K and the corresponding angle
    !                   will be skipped
    !     KEPS(K), K = 1,IL determines which of the angles get incremented
    !     up and down to put values of Z in regions where different
    !     formulae are used.
    !       KEPS(K)  = 0  means that the angle will be used without change
    !                = 1  means that the angle will be incremented up and
    !                   down by EPS
    !     The angles to be used are stored in the T(I) array, I = 1,ITL.
    !-----------------------------------------------------------------------
    IF( MQC/=2 ) THEN
      nl = 2
      il = 5
      DO i = 1, il
        keps(i) = 0
        kdo(i) = 0
      END DO
      nul = 5
      xnu(1) = 0._SP
      xnu(2) = 1._SP
      xnu(3) = 2._SP
      xnu(4) = 0.5_SP*fnul
      xnu(5) = fnul + 1.1_SP
    ELSE
      nl = 4
      il = 13
      DO i = 1, il
        kdo(i) = 0
        keps(i) = 0
      END DO
      kdo(2) = 1
      kdo(6) = 1
      kdo(8) = 1
      kdo(12) = 1
      keps(3) = 1
      keps(4) = 1
      keps(5) = 1
      keps(9) = 1
      keps(10) = 1
      keps(11) = 1
      nul = 6
      xnu(1) = 0._SP
      xnu(2) = 0.6_SP
      xnu(3) = 1.3_SP
      xnu(4) = 2._SP
      xnu(5) = 0.5_SP*fnul
      xnu(6) = fnul + 1.1_SP
    END IF
    i = 2
    eps = 0.01_SP
    film = il - 1
    t(1) = -pi + eps
    DO k = 2, il
      IF( kdo(k)==0 ) THEN
        t(i) = pi*(-il+2*k-1)/film
        IF( keps(k)/=0 ) THEN
          ts = t(i)
          t(i) = ts - eps
          i = i + 1
          t(i) = ts + eps
        ELSE
          i = i + 1
        END IF
      END IF
    END DO
    itl = i - 1
    !-----------------------------------------------------------------------
    !     Test values of Z in -PI<arg(Z)<=PI.
    !-----------------------------------------------------------------------
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99004)
      99004 FORMAT (' CHECKS IN THE (Z,FNU) SPACE'/)
    END IF
    lflg = 0
    DO kode = 1, 2
      DO n = 1, nl
        n1 = n + 1
        DO nu = 1, nul
          fnu = xnu(nu)
          DO icase = 1, 3
            irb = MIN(icase,2)
            DO ir = irb, 3
              !-------------- switch (icase)
              SELECT CASE (icase)
                CASE (2)
                  r = (2._SP*(3-ir)+r2*(ir-1))/2._SP
                CASE (3)
                  IF( r2>=rm ) EXIT
                  r = (r2*(3-ir)+rm*(ir-1))/2._SP
                CASE DEFAULT
                  r = (eps*(3-ir)+2._SP*(ir-1))/2._SP
              END SELECT
              !-------------- end switch
              DO it = 1, itl
                ct = COS(t(it))
                st = SIN(t(it))
                IF( ABS(ct)<atol ) ct = 0._SP
                IF( ABS(st)<atol ) st = 0._SP
                z = CMPLX(r*ct,r*st,SP)
                IF( fnu>=2._SP ) THEN
                  !------------------ Check for possible overflow condition
                  cv = z*(0._SP,1._SP)
                  CALL CUOIK(cv,fnu,kode,2,n1,w,nz2,tol,elim,alim)
                  !------------------ Overflow detected? - skip test for this case
                  IF( nz2==(-1) ) CYCLE
                  cv = -cv
                  CALL CUOIK(cv,fnu,kode,2,n1,w,nz2,tol,elim,alim)
                  !------------------ Overflow detected? - skip test for this case
                  IF( nz2==(-1) ) CYCLE
                END IF
                !---------------- No overflow - calculate H1(Z,FNU) and H2(Z,FNU)
                CALL CBESH(z,fnu,kode,1,n1,y,nz1,ierr)
                !---------------- Underflow? - skip test for this case
                IF( nz1==0 ) THEN
                  CALL CBESH(z,fnu,kode,2,n1,w,nz2,ierr)
                  !---------------- Underflow? - skip test for this case
                  IF( nz2==0 ) THEN
                    !-----------------------------------------------------------------------
                    !     Compare ZN/Z with the Wronskian of H1(Z,FNU) and H2(Z,FNU).
                    !     ZN = -4i/PI
                    !-----------------------------------------------------------------------
                    cv = zn/z
                    mflg = 0
                    DO i = 1, n
                      !-----------------------------------------------------------------------
                      !     Error relative to maximum term
                      !-----------------------------------------------------------------------
                      aw = ABS(w(i+1))
                      ay = ABS(y(i))
                      az = LOG(aw) + LOG(ay)
                      az = ABS(az)
                      IF( az<=alim ) THEN
                        !-------------------- No scaling problem - do error analysis
                        av = ABS(cv)
                        cw = w(i)*y(i+1)
                        cy = w(i+1)*y(i)
                        cy = cw - cy - cv
                        acy = aw*ay
                        acw = ABS(w(i))*ABS(y(i+1))
                        av = MAX(acw,acy,av)
                        er = ABS(cy)/av
                        aer(i) = er
                        IF( er>ertol ) mflg = 1
                      END IF
                    END DO
                    IF( mflg/=0 ) THEN
                      IF( lflg==0 ) THEN
                        IF( Kprint>=2 ) THEN
                          WRITE (Lun,99005) ertol
                          99005 FORMAT (' CASES WHICH VIOLATE THE RELATIVE ',&
                            'ERROR TEST WITH ERTOL = ',E12.4/)
                          WRITE (Lun,99006)
                          99006 FORMAT (' INPUT TO CBESH   Z, FNU, KODE, N')
                        END IF
                        IF( Kprint>=3 ) THEN
                          WRITE (Lun,99007)
                          99007 FORMAT (' COMPARE -4i/(PI*Z) WITH WRONSKIAN OF',&
                            ' H1(Z,FNU) AND H2(Z,FNU)')
                          WRITE (Lun,99008)
                          99008 FORMAT (' RESULTS FROM CBESH FOR FUNCTION H1'/&
                            '         AND FUNCTION H2')
                          WRITE (Lun,99009)
                          99009 FORMAT (' TEST CASE INDICES'/)
                        END IF
                      END IF
                      lflg = lflg + 1
                      IF( Kprint>=2 ) THEN
                        WRITE (Lun,99010) z, fnu, kode, n
                        99010 FORMAT ('   INPUT:    Z=',2E12.4,4X,'FNU=',E12.4,4X,&
                          'KODE=',I3,4X,'N=',I3)
                      END IF
                      IF( Kprint>=3 ) THEN
                        WRITE (Lun,99011) (aer(k),k=1,n)
                        99011 FORMAT ('   ERROR:   AER(K)=',4E12.4)
                        kk = MAX(nz1,nz2) + 1
                        kk = MIN(n,kk)
                        WRITE (Lun,99012) nz1, y(kk), nz2, w(kk)
                        99012 FORMAT (' RESULTS:  NZ1=',I3,4X,'Y(KK)=',2E12.4/11X,&
                          'NZ2=',I3,4X,'W(KK)=',2E12.4)
                        WRITE (Lun,99013) it, ir, icase
                        99013 FORMAT ('    CASE:   IT=',I3,4X,'IR=',I3,4X,'ICASE=',I3/)
                      END IF
                    END IF
                  END IF
                END IF
              END DO
            END DO
          END DO
        END DO
      END DO
    END DO
    IF( Kprint>=2 ) THEN
      IF( lflg==0 ) THEN
        WRITE (Lun,99014)
        99014 FORMAT (' QUICK CHECKS OK')
      ELSE
        WRITE (Lun,99015) lflg
        99015 FORMAT (' ***',I5,' FAILURE(S) FOR CBESH IN THE (Z,FNU)',' PLANE')
      END IF
    END IF
    Ipass = 0
    IF( lflg==0 ) Ipass = 1
    IF( Ipass==1 .AND. Kprint>=2 ) THEN
      WRITE (Lun,99016)
      99016 FORMAT (/' ****** CBESH  PASSED ALL TESTS  ******'/)
    END IF
    IF( Ipass==0 .AND. Kprint>=1 ) THEN
      WRITE (Lun,99017)
      99017 FORMAT (/' ****** CBESH  FAILED SOME TESTS ******'/)
    END IF
  END SUBROUTINE CQCBH
  !** CQCBI
  SUBROUTINE CQCBI(Lun,Kprint,Ipass)
    !> Quick check for SLATEC subroutine
    !            CBESI
    !***
    ! **Library:**   SLATEC
    !***
    ! **Category:**  C10B4
    !***
    ! **Type:**      COMPLEX (CQCBI-C, ZQCBI-Z)
    !***
    ! **Keywords:**  QUICK CHECK, CBESI
    !***
    ! **Author:**  Amos, Don, (SNL)
    !           Goudy, Sue, (SNL)
    !           Walton, Lee, (SNL)
    !***
    ! **Description:**
    !
    !- Usage:
    !
    !        INTEGER  LUN, KPRINT, IPASS
    !
    !        CALL CQCBI (LUN, KPRINT, IPASS)
    !
    !- Arguments:
    !
    !     LUN    :IN  is the unit number to which output is to be written.
    !
    !     KPRINT :IN  controls the amount of output, as specified in the
    !                 SLATEC Guidelines.
    !
    !     IPASS  :OUT indicates whether the test passed or failed.
    !                 A value of one is good, indicating no failures.
    !
    !- Description:
    !
    !   CQCBI is a quick check routine for the complex I Bessel function
    !    generated by subroutine CBESI.
    !
    !   CQCBI generates sequences crossing formula boundaries which
    !    are started by one formula and terminated in a region where
    !    another formula applies. The terminated value is checked by
    !    the formula appropriate to that region.
    !
    !***
    ! **References:**  Abramowitz, M. and Stegun, I. A., Handbook
    !                 of Mathematical Functions, Dover Publications,
    !                 New York, 1964.
    !               Amos, D. E., A Subroutine Package for Bessel
    !                 Functions of a Complex Argument and Nonnegative
    !                 Order, SAND85-1018, May, 1985.
    !***
    ! **Routines called:**  CBESI, CBESK, CWRSK, I1MACH, R1MACH

    !* REVISION HISTORY  (YYMMDD)
    !   830501  DATE WRITTEN
    !   890831  Revised to meet new SLATEC standards
    !
    USE slatec, ONLY : CBESI, CBESK, CWRSK, I1MACH, R1MACH
    !
    !*Internal Notes:
    !   Machine constants are defined by functions I1MACH and R1MACH.
    !
    !   The parameter MQC can have values 1 (the default) for a faster,
    !   less definitive test or 2 for a slower, more definitive test.
    !
    !**End
    !
    !  Set test complexity parameter.
    INTEGER, PARAMETER :: MQC = 1
    !  Declare arguments.
    !
    INTEGER :: Lun, Kprint, Ipass
    !
    !  Declare local variables.
    !
    COMPLEX(SP) :: ck(20), cone, csgn, cw, cy, w(20), y(20), z, zn, zsc, zt, zz
    REAL(SP) :: aa, ab, aer(20), alim, arg, atol, aw, carg, ct, dig, elim, &
      eps, er, ertol, film, fnu, fnul, gnu, hpi, pi, r, rl, &
      rlt, rm, r1, r1m4, r1m5, r2, sarg, slak, st, t(20), tol, ts, xx, yy
    INTEGER :: i, icase, ierr, il, inu, iprnt, ir, it, itl, k, kdo(20), &
      keps(20), kk, kode, k1, k2, lflg, mflg, n, nl, nzi, nzk, nz1, nz2, n1
    !
    !* FIRST EXECUTABLE STATEMENT  CQCBI
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99001)
      99001 FORMAT (' QUICK CHECK ROUTINE FOR THE I BESSEL FUNCTION FROM ','CBESI'/)
    END IF
    !-----------------------------------------------------------------------
    !     Set parameters related to machine constants.
    !     TOL is the approximate unit roundoff limited to 1.0E-18.
    !     ELIM is the approximate exponential over- and underflow limit.
    !     exp(-ELIM)<exp(-ALIM)=exp(-ELIM)/TOL    and
    !     exp(ELIM)>exp(ALIM)=exp(ELIM)*TOL       are intervals near
    !     underflow and overflow limits where scaled arithmetic is done.
    !     RL is the lower boundary of the asymptotic expansion for large Z.
    !     DIG = number of base 10 digits in TOL = 10**(-DIG).
    !     FNUL is the lower boundary of the asymptotic series for large FNU.
    !-----------------------------------------------------------------------
    r1m4 = R1MACH(4)
    tol = MAX(r1m4,1.E-18_SP)
    atol = 100._SP*tol
    aa = -LOG10(r1m4)
    k1 = I1MACH(12)
    k2 = I1MACH(13)
    r1m5 = R1MACH(5)
    k = MIN(ABS(k1),ABS(k2))
    elim = 2.303_SP*(k*r1m5-3._SP)
    ab = aa*2.303_SP
    alim = elim + MAX(-ab,-41.45_SP)
    dig = MIN(aa,18._SP)
    fnul = 10._SP + 6._SP*(dig-3._SP)
    rl = 1.2_SP*dig + 3._SP
    slak = 3._SP + 4._SP*(-LOG10(tol)-7._SP)/11._SP
    slak = MAX(slak,3._SP)
    ertol = tol*10._SP**slak
    rm = 0.5_SP*(alim+elim)
    rm = MIN(rm,200._SP)
    rm = MAX(rm,rl+10._SP)
    r2 = MIN(rm,fnul)
    r1 = 2._SP*SQRT(fnul+1._SP)
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99002)
      99002 FORMAT (' PARAMETERS'/5X,'TOL ',8X,'ELIM',8X,'ALIM',8X,'RL  ',8X,'FNUL',&
        8X,'DIG')
      WRITE (Lun,99003) tol, elim, alim, rl, fnul, dig
      99003 FORMAT (1X,6E12.4/)
    END IF
    !-----------------------------------------------------------------------
    !     Set other constants needed in the tests.
    !-----------------------------------------------------------------------
    zz = CMPLX(1._SP/tol,0._SP,SP)
    cone = CMPLX(1._SP,0._SP,SP)
    hpi = 2._SP*ATAN(1._SP)
    pi = hpi + hpi
    !-----------------------------------------------------------------------
    !     Generate angles for construction of complex Z to be used in tests.
    !-----------------------------------------------------------------------
    !     KDO(K), K = 1,IL  determines which of the IL angles in -PI to PI
    !     are used to compute values of Z.
    !       KDO(K) = 0  means that the index K will be used for one or two
    !                   values of Z, depending on the choice of KEPS(K)
    !              = 1  means that the index K and the corresponding angle
    !                   will be skipped
    !     KEPS(K), K = 1,IL determines which of the angles get incremented
    !     up and down to put values of Z in regions where different
    !     formulae are used.
    !       KEPS(K)  = 0  means that the angle will be used without change
    !                = 1  means that the angle will be incremented up and
    !                   down by EPS
    !     The angles to be used are stored in the T(I) array, I = 1,ITL.
    !-----------------------------------------------------------------------
    IF( MQC/=2 ) THEN
      nl = 2
      il = 5
      DO i = 1, il
        keps(i) = 0
        kdo(i) = 0
      END DO
    ELSE
      nl = 4
      il = 13
      DO i = 1, il
        kdo(i) = 0
        keps(i) = 0
      END DO
      kdo(2) = 1
      kdo(6) = 1
      kdo(8) = 1
      kdo(12) = 1
      keps(3) = 1
      keps(4) = 1
      keps(5) = 1
      keps(9) = 1
      keps(10) = 1
      keps(11) = 1
    END IF
    i = 2
    eps = 0.01_SP
    film = il - 1
    t(1) = -pi + eps
    DO k = 2, il
      IF( kdo(k)==0 ) THEN
        t(i) = pi*(-il+2*k-1)/film
        IF( keps(k)/=0 ) THEN
          ts = t(i)
          t(i) = ts - eps
          i = i + 1
          t(i) = ts + eps
        ELSE
          i = i + 1
        END IF
      END IF
    END DO
    itl = i - 1
    !-----------------------------------------------------------------------
    !     Test values of Z in -PI<arg(Z)<=PI near formula boundaries.
    !-----------------------------------------------------------------------
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99004)
      99004 FORMAT (' CHECKS ACROSS FORMULA BOUNDARIES')
    END IF
    lflg = 0
    DO icase = 1, 6
      DO kode = 1, 2
        DO n = 1, nl
          n1 = n + 2
          !-----------------------------------------------------------------------
          !     Set values for R = magnitude of Z and for FNU to test computation
          !     methods for the various regions of the (Z,FNU) plane.
          !-----------------------------------------------------------------------
          DO ir = 1, 3
            !------------ switch (icase)
            SELECT CASE (icase)
              CASE (2)
                r = (rl*(3-ir)+r2*(ir-1))/2._SP
                gnu = SQRT(r+r) - 0.2_SP - (n-1)
                fnu = MAX(0._SP,gnu)
              CASE (3)
                IF( r2>=rm ) GOTO 100
                r = (r2*(3-ir)+rm*(ir-1))/2._SP
                gnu = SQRT(r+r) - 0.2_SP - (n-1)
                fnu = MAX(0._SP,gnu)
              CASE (4)
                IF( r1>=rl ) GOTO 100
                r = (r1*(3-ir)+rl*(ir-1))/2._SP
                fnu = fnul - 0.2_SP - (n-1)
              CASE (5)
                r = (rl*(3-ir)+r2*(ir-1))/2._SP
                fnu = fnul - 0.2_SP - (n-1)
              CASE (6)
                IF( r2>=rm ) GOTO 100
                r = (r2*(3-ir)+rm*(ir-1))/2._SP
                fnu = fnul - 0.2_SP - (n-1)
              CASE DEFAULT
                r = (2._SP*(3-ir)+rl*(ir-1))/2._SP
                gnu = r*r/4._SP - 0.2_SP - (n-1)
                fnu = MAX(0._SP,gnu)
            END SELECT
            !------------ end switch
            DO it = 1, itl
              ct = COS(t(it))
              st = SIN(t(it))
              IF( ABS(ct)<atol ) ct = 0._SP
              IF( ABS(st)<atol ) st = 0._SP
              z = CMPLX(r*ct,r*st,SP)
              xx = REAL(z)
              yy = AIMAG(z)
              CALL CBESI(z,fnu,kode,n1,y,nz1,ierr)
              IF( nz1==0 ) THEN
                !-----------------------------------------------------------------------
                !     Compare values from CBESI with values from CWRSK, an alternative
                !     method for calculating the complex Bessel I function.
                !-----------------------------------------------------------------------
                zn = z
                IF( xx>=0._SP ) THEN
                  CALL CWRSK(zn,fnu,kode,n,w,nz2,ck,tol,elim,alim)
                  IF( nz2/=0 ) CYCLE
                ELSE
                  zn = -z
                  inu = INT(fnu)
                  arg = (fnu-inu)*pi
                  IF( yy<0._SP ) arg = -arg
                  carg = COS(arg)
                  sarg = SIN(arg)
                  csgn = CMPLX(carg,sarg,SP)
                  IF( MOD(inu,2)==1 ) csgn = -csgn
                  CALL CWRSK(zn,fnu,kode,n,w,nz2,ck,tol,elim,alim)
                  IF( nz2/=0 ) CYCLE
                  DO i = 1, n
                    w(i) = w(i)*csgn
                    csgn = -csgn
                  END DO
                END IF
                mflg = 0
                DO i = 1, n
                  ab = fnu + i - 1
                  aa = MAX(2._SP,ab)
                  zt = w(i)
                  IF( ABS(zt)>1._SP ) THEN
                    zsc = CMPLX(tol,0._SP,SP)
                  ELSE
                    zsc = zz
                    !------------------ ZZ = CMPLX(1.0/TOL,0.0)
                  END IF
                  cw = w(i)*zsc
                  cy = y(i)*zsc
                  er = ABS(cy-cw)
                  aw = ABS(cw)
                  IF( aw==0._SP ) THEN
                    er = ABS(y(i))
                  ELSEIF( xx/=0._SP ) THEN
                    er = er/aw
                  ELSEIF( ABS(yy)<aa ) THEN
                    er = er/aw
                  ELSE
                    er = ABS(w(i)-y(i))
                  END IF
                  aer(i) = er
                  IF( er>=ertol ) mflg = 1
                END DO
                !-----------------------------------------------------------------------
                !     Write failure reports for KPRINT>=2 and KPRINT>=3
                !-----------------------------------------------------------------------
                IF( mflg/=0 ) THEN
                  IF( lflg==0 ) THEN
                    IF( Kprint>=2 ) THEN
                      WRITE (Lun,99005) ertol
                      99005 FORMAT (/' CASES WHICH UNDERFLOW OR VIOLATE THE ',&
                        'RELATIVE ERROR TEST'/' WITH ERTOL = ',E12.4/)
                      WRITE (Lun,99006)
                      99006 FORMAT (' INPUT TO CBESI   Z, FNU, KODE, N')
                    END IF
                    IF( Kprint>=3 ) THEN
                      WRITE (Lun,99007)
                      99007 FORMAT (' ERROR TEST ON RESULTS FROM CBESI AND ',&
                        'CWRSK   AER(K)')
                      WRITE (Lun,99008)
                      99008 FORMAT (' RESULTS FROM CBESI   NZ1, Y(KK)'/,&
                        ' RESULTS FROM CWRSK   NZ2, W(KK)')
                      WRITE (Lun,99009)
                      99009 FORMAT (' TEST CASE INDICES   IT, IR, ICASE'/)
                    END IF
                  END IF
                  lflg = lflg + 1
                  IF( Kprint>=2 ) THEN
                    WRITE (Lun,99010) z, fnu, kode, n
                    99010 FORMAT ('   INPUT:    Z=',2E12.4,4X,'FNU=',E12.4,4X,&
                      'KODE=',I3,4X,'N=',I3)
                  END IF
                  IF( Kprint>=3 ) THEN
                    WRITE (Lun,99011) (aer(k),k=1,n)
                    99011 FORMAT ('   ERROR:  AER(K)=',4E12.4)
                    kk = MAX(nz1,nz2) + 1
                    kk = MIN(n,kk)
                    WRITE (Lun,99012) nz1, y(kk), nz2, w(kk)
                    99012 FORMAT (' RESULTS:  NZ1=',I3,4X,'Y(KK)=',2E12.4,/11X,&
                      'NZ2=',I3,4X,'W(KK)=',2E12.4)
                    WRITE (Lun,99013) it, ir, icase
                    99013 FORMAT ('    CASE:   IT=',I3,4X,'IR=',I3,4X,'ICASE=',I3/)
                  END IF
                END IF
              END IF
            END DO
          END DO
        END DO
      END DO
      100 CONTINUE
    END DO
    IF( Kprint>=2 ) THEN
      IF( lflg==0 ) THEN
        WRITE (Lun,99019)
      ELSE
        WRITE (Lun,99014) lflg
        99014 FORMAT (' ***',I5,' FAILURE(S) FOR CBESI CHECKS NEAR FORMULA ',&
          'BOUNDARIES')
      END IF
    END IF
    !
    !
    iprnt = 0
    IF( MQC/=1 ) THEN
      !-----------------------------------------------------------------------
      !     Checks near underflow limits on series(I=1) and uniform
      !     asymptotic expansion(I=2)
      !     Compare 1/Z with I(Z,FNU)*K(Z,FNU+1) + I(Z,FNU+1)*K(Z,FNU) and
      !     report cases for which the relative error is greater than ERTOL.
      !-----------------------------------------------------------------------
      IF( Kprint>=2 ) THEN
        WRITE (Lun,99015)
        99015 FORMAT (/' CHECKS NEAR UNDERFLOW AND OVERFLOW LIMITS'/)
      END IF
      z = (1.4_SP,1.4_SP)
      kode = 1
      n = 20
      DO i = 1, 2
        fnu = 10.2_SP
        DO
          !-----------------------------------------------------------------------
          !       Adjust FNU by repeating until 0<NZI<10
          !-----------------------------------------------------------------------
          CALL CBESI(z,fnu,kode,n,y,nzi,ierr)
          IF( nzi==0 ) THEN
            fnu = fnu + 5._SP
            CYCLE
          ELSEIF( nzi>=10 ) THEN
            fnu = fnu - 1._SP
            CYCLE
          END IF
          !------ End repeat
          CALL CBESK(z,fnu,kode,2,w,nzk,ierr)
          zt = cone/z
          cy = w(1)*y(2)
          cw = w(2)*y(1)
          cw = cw + cy - zt
          er = ABS(cw)/ABS(zt)
          !-----------------------------------------------------------------------
          !     Write failure reports for KPRINT>=2 and KPRINT>=3
          !-----------------------------------------------------------------------
          IF( er>=ertol ) THEN
            IF( iprnt==0 ) THEN
              IF( Kprint>=2 ) WRITE (Lun,99020)
              IF( Kprint>=3 ) WRITE (Lun,99021)
            END IF
            iprnt = 1
            IF( Kprint>=2 ) WRITE (Lun,99022) z, fnu, kode, n
            IF( Kprint>=3 ) THEN
              WRITE (Lun,99023) zt, cw + cy
              WRITE (Lun,99024) er
            END IF
          END IF
          rlt = rl + rl
          z = CMPLX(rlt,0._SP,SP)
          EXIT
        END DO
      END DO
      !-----------------------------------------------------------------------
      !     Check near overflow limits
      !     Compare 1/Z with I(Z,FNU)*K(Z,FNU+1) + I(Z,FNU+1)*K(Z,FNU) and
      !     report cases for which the relative error is greater than ERTOL.
      !-----------------------------------------------------------------------
      z = CMPLX(elim,0._SP,SP)
      fnu = 0._SP
      DO
        !-----------------------------------------------------------------------
        !     Adjust FNU by repeating until NZK<10
        !     N = 20 set before DO 280 loop
        !-----------------------------------------------------------------------
        CALL CBESK(z,fnu,kode,n,y,nzk,ierr)
        IF( nzk>=10 ) THEN
          IF( nzk==n ) THEN
            fnu = fnu + 3._SP
          ELSE
            fnu = fnu + 2._SP
          END IF
          CYCLE
        END IF
        !---- End repeat
        gnu = fnu + (n-2)
        CALL CBESI(z,gnu,kode,2,w,nzi,ierr)
        zt = cone/z
        cy = y(n-1)*w(2)
        cw = y(n)*w(1)
        cw = cw + cy - zt
        er = ABS(cw)/ABS(zt)
        IF( er>=ertol ) THEN
          IF( iprnt==0 ) THEN
            IF( Kprint>=2 ) WRITE (Lun,99020)
            IF( Kprint>=3 ) WRITE (Lun,99021)
          END IF
          iprnt = 1
          IF( Kprint>=2 ) WRITE (Lun,99022) z, fnu, kode, n
          IF( Kprint>=3 ) THEN
            WRITE (Lun,99023) zt, cw + cy
            WRITE (Lun,99024) er
          END IF
        END IF
        IF( Kprint>=2 ) THEN
          IF( iprnt==0 ) THEN
            WRITE (Lun,99019)
            ! 99986 FORMAT (' QUICK CHECKS OK')
          ELSE
            WRITE (Lun,99016)
            99016 FORMAT (' ***',5X,'FAILURE(S) FOR CBESI NEAR UNDERFLOW AND ',&
              'OVERFLOW LIMITS')
          END IF
        END IF
        EXIT
      END DO
    END IF
    Ipass = 0
    IF( iprnt==0 .AND. lflg==0 ) Ipass = 1
    IF( Ipass==1 .AND. Kprint>=2 ) THEN
      WRITE (Lun,99017)
      99017 FORMAT (/' ****** CBESI  PASSED ALL TESTS  ******'/)
    END IF
    IF( Ipass==0 .AND. Kprint>=1 ) THEN
      WRITE (Lun,99018)
      99018 FORMAT (/' ****** CBESI  FAILED SOME TESTS ******'/)
    END IF
    99019 FORMAT (' QUICK CHECKS OK')
    99020 FORMAT (' INPUT TO CBESI   Z, FNU, KODE, N')
    99021 FORMAT (' COMPARE 1/Z WITH WRONSKIAN(CBESI(Z,FNU),','CBESK(Z,FNU))'/)
    99022 FORMAT (' INPUT: Z=',2E12.4,3X,'FNU=',E12.4,3X,'KODE=',I3,3X,'N=',I3)
    99023 FORMAT (' RESULTS:',15X,'1/Z=',2E12.4/10X,'WRON(CBESI,CBESK)=',2E12.4)
    99024 FORMAT (' RELATIVE ERROR:',9X,'ER=',E12.4/)
  END SUBROUTINE CQCBI
  !** CQCBJ
  SUBROUTINE CQCBJ(Lun,Kprint,Ipass)
    !> Quick check for SLATEC subroutine
    !            CBESJ
    !***
    ! **Library:**   SLATEC
    !***
    ! **Category:**  C10A4
    !***
    ! **Type:**      COMPLEX (CQCBJ-C, ZQCBJ-Z)
    !***
    ! **Keywords:**  QUICK CHECK, CBESJ
    !***
    ! **Author:**  Amos, Don, (SNL)
    !           Goudy, Sue, (SNL)
    !           Walton, Lee, (SNL)
    !***
    ! **Description:**
    !
    !- Usage:
    !
    !        INTEGER  LUN, KPRINT, IPASS
    !
    !        CALL CQCBJ (LUN, KPRINT, IPASS)
    !
    !- Arguments:
    !
    !     LUN    :IN  is the unit number to which output is to be written.
    !
    !     KPRINT :IN  controls the amount of output, as specified in the
    !                 SLATEC Guidelines.
    !
    !     IPASS  :OUT indicates whether the test passed or failed.
    !                 A value of one is good, indicating no failures.
    !
    !- Description:
    !
    !   CQCBJ is a quick check routine for the complex J Bessel function
    !    generated by subroutine CBESJ.
    !
    !   CQCBJ generates sequences of J Bessel functions from CBESJ
    !    and checks them against the evaluation from the formula
    !
    !            J(FNU,Z) = 0.5*( H(1,FNU,Z) + H(2,FNU,Z) )
    !
    !    where -PI<arg(Z)<=PI for abs(Z)>=FNU.
    !
    !   For abs(Z)<FNU, the first N members of a sequence of length
    !    N+16 are checked against a corresponding N member sequence where
    !    both sequences are generated by CBESJ beginning at order FNU.
    !
    !***
    ! **References:**  Abramowitz, M. and Stegun, I. A., Handbook
    !                 of Mathematical Functions, Dover Publications,
    !                 New York, 1964.
    !               Amos, D. E., A Subroutine Package for Bessel
    !                 Functions of a Complex Argument and Nonnegative
    !                 Order, SAND85-1018, May, 1985.
    !***
    ! **Routines called:**  CBESH, CBESJ, I1MACH, R1MACH

    !* REVISION HISTORY  (YYMMDD)
    !   830501  DATE WRITTEN
    !   890831  Revised to meet new SLATEC standards
    !
    USE slatec, ONLY : CBESH, CBESJ, I1MACH, R1MACH
    !
    !*Internal Notes:
    !   Machine constants are defined by functions I1MACH and R1MACH.
    !
    !   The parameter MQC can have values 1 (the default) for a faster,
    !   less definitive test or 2 for a slower, more definitive test.
    !
    !**End
    !
    !  Set test complexity parameter.
    INTEGER, PARAMETER :: MQC = 1
    !  Declare arguments.
    !
    INTEGER :: Lun, Kprint, Ipass
    !
    !  Declare local variables.
    !
    COMPLEX(SP) :: chalf, coe1, coe2, cw, v(20), w(20), y(20), z
    REAL(SP) :: aa, ab, aer(20), alim, atol, av, cc, ct, dd, dig, elim, eps, &
      er, ertol, film, fnu, fnul, gnu, hpi, pi, r, rl, rm, &
      r1m4, r1m5, r2, slak, st, t(20), tol, ts, xnu(20), xx, yy
    INTEGER :: i, icase, ierr, il, ir, irb, it, itl, k, kdo(20), keps(20), &
      kk, kode, k1, k2, lflg, m, mflg, n, nl, nu, nul, nz, nz1, nz2
    !
    !* FIRST EXECUTABLE STATEMENT  CQCBJ
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99001)
      99001 FORMAT (' QUICK CHECK ROUTINE FOR THE J BESSEL FUNCTION FROM ','CBESJ'/)
    END IF
    !-----------------------------------------------------------------------
    !     Set parameters related to machine constants.
    !     TOL is the approximate unit roundoff limited to 1.0E-18.
    !     ELIM is the approximate exponential over- and underflow limit.
    !     exp(-ELIM)<exp(-ALIM)=exp(-ELIM)/TOL    and
    !     exp(ELIM)>exp(ALIM)=exp(ELIM)*TOL       are intervals near
    !     underflow and overflow limits where scaled arithmetic is done.
    !     RL is the lower boundary of the asymptotic expansion for large Z.
    !     DIG = number of base 10 digits in TOL = 10**(-DIG).
    !     FNUL is the lower boundary of the asymptotic series for large FNU.
    !-----------------------------------------------------------------------
    r1m4 = R1MACH(4)
    tol = MAX(r1m4,1.E-18_SP)
    atol = 100._SP*tol
    aa = -LOG10(r1m4)
    k1 = I1MACH(12)
    k2 = I1MACH(13)
    r1m5 = R1MACH(5)
    k = MIN(ABS(k1),ABS(k2))
    elim = 2.303_SP*(k*r1m5-3._SP)
    ab = aa*2.303_SP
    alim = elim + MAX(-ab,-41.45_SP)
    dig = MIN(aa,18._SP)
    fnul = 10._SP + 6._SP*(dig-3._SP)
    rl = 1.2_SP*dig + 3._SP
    slak = 3._SP + 4._SP*(-LOG10(tol)-7._SP)/11._SP
    slak = MAX(slak,3._SP)
    ertol = tol*10._SP**slak
    rm = 0.5_SP*(alim+elim)
    rm = MIN(rm,200._SP)
    rm = MAX(rm,rl+10._SP)
    r2 = MIN(rm,fnul)
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99002)
      99002 FORMAT (' PARAMETERS'/5X,'TOL ',8X,'ELIM',8X,'ALIM',8X,'RL  ',8X,'FNUL',&
        8X,'DIG')
      WRITE (Lun,99003) tol, elim, alim, rl, fnul, dig
      99003 FORMAT (1X,6E12.4/)
    END IF
    !-----------------------------------------------------------------------
    !     Set other constants needed in the tests.
    !-----------------------------------------------------------------------
    chalf = (0.5_SP,0._SP)
    hpi = 2._SP*ATAN(1._SP)
    pi = hpi + hpi
    !-----------------------------------------------------------------------
    !     Generate angles for construction of complex Z to be used in tests.
    !-----------------------------------------------------------------------
    !     KDO(K), K = 1,IL  determines which of the IL angles in -PI to PI
    !     are used to compute values of Z.
    !       KDO(K) = 0  means that the index K will be used for one or two
    !                   values of Z, depending on the choice of KEPS(K)
    !              = 1  means that the index K and the corresponding angle
    !                   will be skipped
    !     KEPS(K), K = 1,IL determines which of the angles get incremented
    !     up and down to put values of Z in regions where different
    !     formulae are used.
    !       KEPS(K)  = 0  means that the angle will be used without change
    !                = 1  means that the angle will be incremented up and
    !                   down by EPS
    !     The angles to be used are stored in the T(I) array, I = 1,ITL.
    !-----------------------------------------------------------------------
    IF( MQC/=2 ) THEN
      nl = 2
      il = 5
      DO i = 1, il
        keps(i) = 0
        kdo(i) = 0
      END DO
      nul = 5
      xnu(1) = 0._SP
      xnu(2) = 1._SP
      xnu(3) = 2._SP
      xnu(4) = 0.5_SP*fnul
      xnu(5) = fnul + 1.1_SP
    ELSE
      nl = 4
      il = 13
      DO i = 1, il
        kdo(i) = 0
        keps(i) = 0
      END DO
      kdo(2) = 1
      kdo(6) = 1
      kdo(8) = 1
      kdo(12) = 1
      keps(3) = 1
      keps(4) = 1
      keps(5) = 1
      keps(9) = 1
      keps(10) = 1
      keps(11) = 1
      nul = 6
      xnu(1) = 0._SP
      xnu(2) = 0.6_SP
      xnu(3) = 1.3_SP
      xnu(4) = 2._SP
      xnu(5) = 0.5_SP*fnul
      xnu(6) = fnul + 1.1_SP
    END IF
    i = 2
    eps = 0.01_SP
    film = il - 1
    t(1) = -pi + eps
    DO k = 2, il
      IF( kdo(k)==0 ) THEN
        t(i) = pi*(-il+2*k-1)/film
        IF( keps(k)==0 ) THEN
          ts = t(i)
          t(i) = ts - eps
          i = i + 1
          t(i) = ts + eps
        ELSE
          i = i + 1
        END IF
      END IF
    END DO
    itl = i - 1
    !-----------------------------------------------------------------------
    !     Test values of Z in -PI<arg(Z)<=PI.
    !-----------------------------------------------------------------------
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99004)
      99004 FORMAT (' CHECKS IN THE (Z,FNU) SPACE'/)
    END IF
    lflg = 0
    DO kode = 1, 2
      DO n = 1, nl
        DO nu = 1, nul
          fnu = xnu(nu)
          DO icase = 1, 3
            irb = MIN(2,icase)
            DO ir = irb, 4
              !-------------- switch (icase)
              SELECT CASE (icase)
                CASE (2)
                  r = (2._SP*(4-ir)+r2*(ir-1))/3._SP
                CASE (3)
                  IF( r2>=rm ) EXIT
                  r = (r2*(4-ir)+rm*(ir-1))/3._SP
                CASE DEFAULT
                  r = (eps*(4-ir)+2._SP*(ir-1))/3._SP
              END SELECT
              !-------------- end switch
              gnu = fnu + (n-1)
              DO it = 1, itl
                ct = COS(t(it))
                st = SIN(t(it))
                IF( ABS(ct)<atol ) ct = 0._SP
                IF( ABS(st)<atol ) st = 0._SP
                z = CMPLX(r*ct,r*st,SP)
                xx = REAL(z)
                yy = AIMAG(z)
                IF( r>=gnu ) THEN
                  !------------------ Cases for abs(Z)>=FNU+N-1
                  CALL CBESJ(z,fnu,kode,n,v,nz,ierr)
                  !------------------ Underflow - skip test for this case.
                  IF( nz/=0 ) CYCLE
                  CALL CBESH(z,fnu,kode,1,n,w,nz1,ierr)
                  CALL CBESH(z,fnu,kode,2,n,y,nz2,ierr)
                  IF( kode==2 ) THEN
                    !-------------------- Adjust scaling of H functions.
                    cc = -yy - ABS(yy)
                    IF( cc>(-alim) ) THEN
                      cw = CMPLX(cc,xx,SP)
                      coe1 = EXP(cw)
                    ELSE
                      coe1 = CMPLX(0._SP,0._SP,SP)
                    END IF
                    dd = yy - ABS(yy)
                    IF( dd>(-alim) ) THEN
                      cw = CMPLX(dd,-xx,SP)
                      coe2 = EXP(cw)
                    ELSE
                      coe2 = CMPLX(0._SP,0._SP,SP)
                    END IF
                    DO kk = 1, n
                      y(kk) = y(kk)*coe2
                      w(kk) = w(kk)*coe1
                    END DO
                  END IF
                ELSE
                  !------------------ Cases for abs(Z)<FNU+N-1
                  m = n + 16
                  CALL CBESJ(z,fnu,kode,m,v,nz,ierr)
                  !------------------ Underflow at end of sequence - skip test
                  IF( nz>10 ) CYCLE
                  CALL CBESJ(z,fnu,kode,n,w,nz,ierr)
                  DO kk = 1, n
                    y(kk) = w(kk)
                  END DO
                END IF
                !-----------------------------------------------------------------------
                !     If abs(Z)>=FNU+N-1 then the error test compares J(Z<FNU) with
                !     0.5*(H1(Z,FNU) + H2(Z,FNU)).
                !     If abs(Z)<FNU+N-1 then the error test ensures that calculations
                !     begun in one region of the (Z,FNU) plane and carried into another
                !     region do not diverge from calculations carried out entirely in
                !     one region.  This is an internal consistency check.
                !-----------------------------------------------------------------------
                mflg = 0
                DO i = 1, n
                  ab = fnu + i - 1
                  aa = MAX(2._SP,ab)
                  cw = (w(i)+y(i))*chalf
                  av = ABS(v(i))
                  er = ABS(cw-v(i))
                  IF( av/=0._SP ) THEN
                    IF( yy==0._SP ) THEN
                      IF( ABS(xx)<aa ) er = er/av
                    ELSE
                      er = er/av
                    END IF
                  END IF
                  aer(i) = er
                  IF( er>ertol ) mflg = 1
                END DO
                IF( mflg/=0 ) THEN
                  IF( lflg==0 ) THEN
                    IF( Kprint>=2 ) THEN
                      WRITE (Lun,99005) ertol
                      99005 FORMAT (' CASES WHICH VIOLATE THE RELATIVE ',&
                        'ERROR TEST WITH ERTOL=',E12.4/)
                      WRITE (Lun,99006)
                      99006 FORMAT (' INPUT TO CBESJ   Z, FNU, KODE, N')
                    END IF
                    IF( Kprint>=3 ) THEN
                      IF( r>=gnu ) THEN
                        WRITE (Lun,99007)
                        99007 FORMAT (' COMPARE WITH AVERAGE OF H1 AND H2 ',&
                          'FUNCTIONS FOR THE SAME INPUT')
                        WRITE (Lun,99008)
                        99008 FORMAT (' RESULTS FROM CBESJ    NZ, V(KK)')
                        WRITE (Lun,99009)
                        99009 FORMAT (' RESULTS FROM CBESH   NZ1, W(KK)')
                        WRITE (Lun,99010)
                        99010 FORMAT (' RESULTS FROM CBESH   NZ2, Y(KK)')
                      ELSE
                        WRITE (Lun,99011)
                        99011 FORMAT (' RESULTS FROM CBESJ    NZ, W(KK)')
                      END IF
                      WRITE (Lun,99012)
                      99012 FORMAT (' TEST CASE INDICES   IR, IT, ICASE'/)
                    END IF
                  END IF
                  lflg = lflg + 1
                  IF( Kprint>=2 ) THEN
                    WRITE (Lun,99013) z, fnu, kode, n
                    99013 FORMAT ('   INPUT:   Z=',2E12.4,3X,'FNU=',E12.4,3X,&
                      'KODE=',I3,3X,'N=',I3)
                  END IF
                  IF( Kprint>=3 ) THEN
                    WRITE (Lun,99014) (aer(k),k=1,n)
                    99014 FORMAT ('   ERROR:   AER(K)=',4E12.4)
                    IF( r>=gnu ) THEN
                      kk = MAX(nz1,nz2) + 1
                      kk = MIN(n,kk)
                      WRITE (Lun,99015) nz, v(kk)
                      99015 FORMAT (' RESULTS:   NZ=',I3,3X,'V(KK)=',2E12.4)
                      WRITE (Lun,99016) nz1, w(kk)
                      99016 FORMAT (' RESULTS:  NZ1=',I3,3X,'W(KK)=',2E12.4)
                      WRITE (Lun,99017) nz2, y(kk)
                      99017 FORMAT (' RESULTS:  NZ2=',I3,3X,'Y(KK)=',2E12.4)
                    ELSE
                      kk = n - nz
                      WRITE (Lun,99018) nz, w(kk)
                      99018 FORMAT (' RESULTS:   NZ=',I3,3X,'W(KK)=',2E12.4)
                    END IF
                    WRITE (Lun,99019) ir, it, icase
                    99019 FORMAT ('    CASE:  IR=',I3,3X,'IT=',I3,3X,'ICASE=',I3/)
                  END IF
                END IF
              END DO
            END DO
          END DO
        END DO
      END DO
    END DO
    IF( Kprint>=2 ) THEN
      IF( lflg==0 ) THEN
        WRITE (Lun,99020)
        99020 FORMAT (' QUICK CHECKS OK')
      ELSE
        WRITE (Lun,99021) lflg
        99021 FORMAT (' ***',I5,' FAILURE(S) FOR CBESJ IN THE (Z,FNU)',' PLANE')
      END IF
    END IF
    Ipass = 0
    IF( lflg==0 ) Ipass = 1
    IF( Ipass==1 .AND. Kprint>=2 ) THEN
      WRITE (Lun,99022)
      99022 FORMAT (/' ****** CBESJ  PASSED ALL TESTS  ******'/)
    END IF
    IF( Ipass==0 .AND. Kprint>=1 ) THEN
      WRITE (Lun,99023)
      99023 FORMAT (/' ****** CBESJ  FAILED SOME TESTS ******'/)
    END IF
  END SUBROUTINE CQCBJ
  !** CQCBK
  SUBROUTINE CQCBK(Lun,Kprint,Ipass)
    !> Quick check for SLATEC subroutine
    !            CBESK
    !***
    ! **Library:**   SLATEC
    !***
    ! **Category:**  C10B4
    !***
    ! **Type:**      COMPLEX (CQCBK-C, ZQCBK-Z)
    !***
    ! **Keywords:**  QUICK CHECK, CBESK
    !***
    ! **Author:**  Amos, Don, (SNL)
    !           Goudy, Sue, (SNL)
    !           Walton, Lee, (SNL)
    !***
    ! **Description:**
    !
    !- Usage:
    !
    !        INTEGER  LUN, KPRINT, IPASS
    !
    !        CALL CQCBK (LUN, KPRINT, IPASS)
    !
    !- Arguments:
    !
    !     LUN    :IN  is the unit number to which output is to be written.
    !
    !     KPRINT :IN  controls the amount of output, as specified in the
    !                 SLATEC Guidelines.
    !
    !     IPASS  :OUT indicates whether the test passed or failed.
    !                 A value of one is good, indicating no failures.
    !
    !- Description:
    !
    !   CQCBK is a quick check routine for the complex K Bessel function
    !    generated by subroutine CBESK.
    !
    !   CQCBK generates sequences of I and K Bessel functions from
    !    CBESI and CBESK and checks them against the Wronskian evaluation
    !    in the (Z,FNU) space.
    !
    !***
    ! **References:**  Abramowitz, M. and Stegun, I. A., Handbook
    !                 of Mathematical Functions, Dover Publications,
    !                 New York, 1964.
    !               Amos, D. E., A Subroutine Package for Bessel
    !                 Functions of a Complex Argument and Nonnegative
    !                 Order, SAND85-1018, May, 1985.
    !***
    ! **Routines called:**  CBESI, CBESK, I1MACH, R1MACH

    !* REVISION HISTORY  (YYMMDD)
    !   830501  DATE WRITTEN
    !   890831  Revised to meet new SLATEC standard
    !
    USE slatec, ONLY : CBESI, CBESK, I1MACH, R1MACH
    !
    !*Internal Notes:
    !   Machine constants are defined by functions I1MACH and R1MACH.
    !
    !   The parameter MQC can have values 1 (the default) for a faster,
    !   less definitive test or 2 for a slower, more definitive test.
    !
    !**End
    !
    !  Set test complexity parameter.
    INTEGER, PARAMETER :: MQC = 1
    !  Declare arguments.
    !
    INTEGER :: Lun, Kprint, Ipass
    !
    !  Declare local variables.
    !
    COMPLEX(SP) :: cone, csgn, cv, cw, cy, w(20), y(20), z, zn
    REAL(SP) :: aa, ab, aer(20), alim, arg, atol, axx, ct, dig, elim, eps, &
      er, ertol, ffnu, film, fnu, fnul, hpi, pi, r, rl, rm, &
      r1m4, r1m5, r2, slak, st, t(20), tol, ts, xnu(20), xx
    INTEGER :: i, icase, ierr, ifnu, il, ir, irb, it, itl, k, kdo(20), &
      keps(20), kk, kode, k1, k2, lflg, mflg, n, nl, nu, nul, nz1, nz2, n1
    !
    !* FIRST EXECUTABLE STATEMENT  CQCBK
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99001)
      99001 FORMAT (' QUICK CHECK ROUTINE FOR THE K BESSEL FUNCTION FROM ','CBESK'/)
    END IF
    !-----------------------------------------------------------------------
    !     Set parameters related to machine constants.
    !     TOL is the approximate unit roundoff limited to 1.0E-18.
    !     ELIM is the approximate exponential over- and underflow limit.
    !     exp(-ELIM)<exp(-ALIM)=exp(-ELIM)/TOL    and
    !     exp(ELIM)>exp(ALIM)=exp(ELIM)*TOL       are intervals near
    !     underflow and overflow limits where scaled arithmetic is done.
    !     RL is the lower boundary of the asymptotic expansion for large Z.
    !     DIG = number of base 10 digits in TOL = 10**(-DIG).
    !     FNUL is the lower boundary of the asymptotic series for large FNU.
    !-----------------------------------------------------------------------
    r1m4 = R1MACH(4)
    tol = MAX(r1m4,1.E-18_SP)
    atol = 100._SP*tol
    aa = -LOG10(r1m4)
    k1 = I1MACH(12)
    k2 = I1MACH(13)
    r1m5 = R1MACH(5)
    k = MIN(ABS(k1),ABS(k2))
    elim = 2.303_SP*(k*r1m5-3._SP)
    ab = aa*2.303_SP
    alim = elim + MAX(-ab,-41.45_SP)
    dig = MIN(aa,18._SP)
    fnul = 10._SP + 6._SP*(dig-3._SP)
    rl = 1.2_SP*dig + 3._SP
    slak = 3._SP + 4._SP*(-LOG10(tol)-7._SP)/11._SP
    slak = MAX(slak,3._SP)
    ertol = tol*10._SP**slak
    rm = 0.5_SP*(alim+elim)
    rm = MIN(rm,200._SP)
    rm = MAX(rm,rl+10._SP)
    r2 = MIN(rm,fnul)
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99002)
      99002 FORMAT (' PARAMETERS'/5X,'TOL ',8X,'ELIM',8X,'ALIM',8X,'RL  ',8X,'FNUL',&
        8X,'DIG')
      WRITE (Lun,99003) tol, elim, alim, rl, fnul, dig
      99003 FORMAT (1X,6E12.4/)
    END IF
    !-----------------------------------------------------------------------
    !     Set other constants needed in the tests.
    !-----------------------------------------------------------------------
    cone = (1._SP,0._SP)
    hpi = 2._SP*ATAN(1._SP)
    pi = hpi + hpi
    !-----------------------------------------------------------------------
    !     Generate angles for construction of complex Z to be used in tests.
    !-----------------------------------------------------------------------
    !     KDO(K), K = 1,IL  determines which of the IL angles in -PI to PI
    !     are used to compute values of Z.
    !       KDO(K) = 0  means that the index K will be used for one or two
    !                   values of Z, depending on the choice of KEPS(K)
    !              = 1  means that the index K and the corresponding angle
    !                   will be skipped
    !     KEPS(K), K = 1,IL determines which of the angles get incremented
    !     up and down to put values of Z in regions where different
    !     formulae are used.
    !       KEPS(K)  = 0  means that the angle will be used without change
    !                = 1  means that the angle will be incremented up and
    !                   down by EPS
    !     The angles to be used are stored in the T(I) array, I = 1,ITL.
    !-----------------------------------------------------------------------
    IF( MQC/=2 ) THEN
      nl = 2
      il = 5
      DO i = 1, il
        keps(i) = 0
        kdo(i) = 0
      END DO
      nul = 5
      xnu(1) = 0._SP
      xnu(2) = 1._SP
      xnu(3) = 2._SP
      xnu(4) = 0.5_SP*fnul
      xnu(5) = fnul + 1.1_SP
    ELSE
      nl = 4
      il = 13
      DO i = 1, il
        kdo(i) = 0
        keps(i) = 0
      END DO
      kdo(2) = 1
      kdo(6) = 1
      kdo(8) = 1
      kdo(12) = 1
      keps(3) = 1
      keps(4) = 1
      keps(5) = 1
      keps(9) = 1
      keps(10) = 1
      keps(11) = 1
      nul = 6
      xnu(1) = 0._SP
      xnu(2) = 0.6_SP
      xnu(3) = 1.3_SP
      xnu(4) = 2._SP
      xnu(5) = 0.5_SP*fnul
      xnu(6) = fnul + 1.1_SP
    END IF
    i = 2
    eps = 0.01_SP
    film = il - 1
    t(1) = -pi + eps
    DO k = 2, il
      IF( kdo(k)==0 ) THEN
        t(i) = pi*(-il+2*k-1)/film
        IF( keps(k)/=0 ) THEN
          ts = t(i)
          t(i) = ts - eps
          i = i + 1
          t(i) = ts + eps
        ELSE
          i = i + 1
        END IF
      END IF
    END DO
    itl = i - 1
    !-----------------------------------------------------------------------
    !     Test values of Z IN -PI<arg(Z)<=PI near formula boundaries.
    !-----------------------------------------------------------------------
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99004)
      99004 FORMAT (' CHECKS IN THE (Z,FNU) SPACE')
    END IF
    lflg = 0
    DO kode = 1, 2
      DO n = 1, nl
        n1 = n + 1
        DO nu = 1, nul
          fnu = xnu(nu)
          ifnu = INT(fnu)
          ffnu = fnu - ifnu
          arg = pi*ffnu
          csgn = CMPLX(COS(arg),SIN(arg),SP)
          IF( MOD(ifnu,2)==1 ) csgn = -csgn
          DO icase = 1, 3
            irb = MIN(2,icase)
            DO ir = irb, 4
              !-------------- switch (icase)
              SELECT CASE (icase)
                CASE (2)
                  r = (2._SP*(4-ir)+r2*(ir-1))/3._SP
                CASE (3)
                  IF( r2>=rm ) EXIT
                  r = (r2*(4-ir)+rm*(ir-1))/3._SP
                CASE DEFAULT
                  r = (eps*(4-ir)+2._SP*(ir-1))/3._SP
              END SELECT
              !-------------- end switch
              DO it = 1, itl
                ct = COS(t(it))
                st = SIN(t(it))
                IF( ABS(ct)<atol ) ct = 0._SP
                IF( ABS(st)<atol ) st = 0._SP
                z = CMPLX(r*ct,r*st,SP)
                CALL CBESI(z,fnu,kode,n1,w,nz2,ierr)
                !---------------- Underflow? - skip test for this case.
                IF( nz2==0 ) THEN
                  !-----------------------------------------------------------------------
                  !     In the left half plane, the analytic continuation formula for K
                  !     introduces an I function. The dominant terms in the Wronskian
                  !     I(FNU,Z)*I(FNU+1,Z) cancel out, giving losses of significance.
                  !     This cancellation can be done analytically to give a Wronskian in
                  !     terms of I in the left half plane and K in the right half plane.
                  !-----------------------------------------------------------------------
                  IF( icase==1 .OR. ct>=0._SP ) THEN
                    !------------------ Z is in the right half plane
                    CALL CBESK(z,fnu,kode,n1,y,nz1,ierr)
                    cv = cone/z
                    IF( kode==2 ) THEN
                      !-------------------- Adjust Wronskian due to scaled I and K functions
                      xx = REAL(z)
                      axx = ABS(xx)
                      zn = CMPLX(-axx,0._SP,SP)
                      cv = zn + z
                      cv = EXP(cv)/z
                    END IF
                  ELSE
                    !------------------ Z is in the left half plane
                    zn = -z
                    CALL CBESK(zn,fnu,kode,n1,y,nz1,ierr)
                    zn = csgn
                    !------------------ CSGN set near top of DO 180 loop
                    IF( st>0._SP .OR. (st==0._SP .AND. ct<0._SP) ) zn = CONJG(zn)
                    DO kk = 1, n1
                      y(kk) = y(kk)*zn
                      zn = -zn
                    END DO
                    cv = cone/z
                    IF( kode==2 ) THEN
                      !-------------------- Adjust Wronskian due to scaled I and K functions
                      xx = REAL(z)
                      axx = ABS(xx)
                      zn = CMPLX(-axx,0._SP,SP)
                      cv = zn - z
                      cv = EXP(cv)/z
                    END IF
                  END IF
                  mflg = 0
                  DO i = 1, n
                    cw = w(i)*y(i+1)
                    cy = w(i+1)*y(i)
                    cy = cy + cw - cv
                    er = ABS(cy)/ABS(cv)
                    aer(i) = er
                    IF( er>ertol ) mflg = 1
                  END DO
                  IF( mflg/=0 ) THEN
                    IF( lflg==0 ) THEN
                      IF( Kprint>=2 ) THEN
                        WRITE (Lun,99005) ertol
                        99005 FORMAT (/' CASES WHICH OR VIOLATE THE RELATIVE',&
                          ' ERROR TEST WITH ERTOL = ',E12.4/)
                        WRITE (Lun,99006)
                        99006 FORMAT (' INPUT TO CBESK   Z, FNU, KODE, N')
                      END IF
                      IF( Kprint>=3 ) THEN
                        WRITE (Lun,99007)
                        99007 FORMAT (' ERROR TEST ON THE WRONSKIAN OF ',&
                          'CBESI(Z,FNU) AND CBESK(Z,FNU)')
                        WRITE (Lun,99008)
                        99008 FORMAT (' RESULTS FROM CBESK   NZ1, Y(KK)'/,&
                          ' RESULTS FROM CBESI   NZ2, W(KK)')
                        WRITE (Lun,99009)
                        99009 FORMAT (' TEST CASE INDICES   IT, IR, ICASE'/)
                      END IF
                    END IF
                    lflg = lflg + 1
                    IF( Kprint>=2 ) THEN
                      WRITE (Lun,99010) z, fnu, kode, n
                      99010 FORMAT ('   INPUT:    Z=',2E12.4,4X,'FNU=',E12.4,4X,&
                        'KODE=',I3,4X,'N=',I3)
                    END IF
                    IF( Kprint>=3 ) THEN
                      WRITE (Lun,99011) (aer(k),k=1,n)
                      99011 FORMAT ('   ERROR:  AER(K)=',4E12.4)
                      kk = MAX(nz1,nz2) + 1
                      kk = MIN(n,kk)
                      WRITE (Lun,99012) nz1, y(kk), nz2, w(kk)
                      99012 FORMAT (' RESULTS:  NZ1=',I3,4X,'Y(KK)=',2E12.4,/11X,&
                        'NZ2=',I3,4X,'W(KK)=',2E12.4)
                      WRITE (Lun,99013) it, ir, icase
                      99013 FORMAT ('    CASE:   IT=',I3,4X,'IR=',I3,4X,'ICASE=',I3/)
                    END IF
                  END IF
                END IF
              END DO
            END DO
          END DO
        END DO
      END DO
    END DO
    IF( Kprint>=2 ) THEN
      IF( lflg==0 ) THEN
        WRITE (Lun,99014)
        99014 FORMAT (' QUICK CHECKS OK')
      ELSE
        WRITE (Lun,99015) lflg
        99015 FORMAT (' ***',I5,' FAILURE(S) FOR CBESK NEAR FORMULA ','BOUNDARIES')
      END IF
    END IF
    Ipass = 0
    IF( lflg==0 ) Ipass = 1
    IF( Ipass==1 .AND. Kprint>=2 ) THEN
      WRITE (Lun,99016)
      99016 FORMAT (/' ****** CBESK  PASSED ALL TESTS  ******'/)
    END IF
    IF( Ipass==0 .AND. Kprint>=1 ) THEN
      WRITE (Lun,99017)
      99017 FORMAT (/' ****** CBESK  FAILED SOME TESTS ******'/)
    END IF
  END SUBROUTINE CQCBK
  !** CQCBY
  SUBROUTINE CQCBY(Lun,Kprint,Ipass)
    !> Quick check for SLATEC subroutine
    !            CBESY
    !***
    ! **Library:**   SLATEC
    !***
    ! **Category:**  C10A4
    !***
    ! **Type:**      COMPLEX (CQCBY-C, ZQCBY-Z)
    !***
    ! **Keywords:**  QUICK CHECK, CBESY
    !***
    ! **Author:**  Amos, Don, (SNL)
    !           Goudy, Sue, (SNL)
    !           Walton, Lee, (SNL)
    !***
    ! **Description:**
    !
    !- Usage:
    !
    !        INTEGER  LUN, KPRINT, IPASS
    !
    !        CALL CQCBY (LUN, KPRINT, IPASS)
    !
    !- Arguments:
    !
    !     LUN    :IN  is the unit number to which output is to be written.
    !
    !     KPRINT :IN  controls the amount of output, as specified in the
    !                 SLATEC Guidelines.
    !
    !     IPASS  :OUT indicates whether the test passed or failed.
    !                 A value of one is good, indicating no failures.
    !
    !- Description:
    !
    !   CQCBY is a quick check routine for the complex Y Bessel function
    !    generated by subroutine CBESY.
    !
    !   CQCBY generates sequences of Y Bessel functions from CBESY
    !    and checks them against the evaluation from the formula
    !
    !    Y(FNU,Z*ROT) = C(FNU+1)*I(FNU,Z)-(2/PI)*CONJG(C(FNU))*K(FNU,Z)
    !
    !    where ROT = EXP(PI*I/2), C(FNU)=EXP(PI*FNU*I/2), I**2=-1
    !
    !    and -PI<ARG(Z)<=PI/2, in the (Z,FNU) space.
    !
    !***
    ! **References:**  Abramowitz, M. and Stegun, I. A., Handbook
    !                 of Mathematical Functions, Dover Publications,
    !                 New York, 1964.
    !               Amos, D. E., A Subroutine Package for Bessel
    !                 Functions of a Complex Argument and Nonnegative
    !                 Order, SAND85-1018, May, 1985.
    !***
    ! **Routines called:**  CBESI, CBESK, CBESY, I1MACH, R1MACH

    !* REVISION HISTORY  (YYMMDD)
    !   830501  DATE WRITTEN
    !   890831  Revised to meet new SLATEC standards
    !
    USE slatec, ONLY : CBESI, CBESK, CBESY, I1MACH, R1MACH
    !
    !*Internal Notes:
    !   Machine constants are defined by functions I1MACH and R1MACH.
    !
    !   The parameter MQC can have values 1 (the default) for a faster,
    !   less definitive test or 2 for a slower, more definitive test.
    !
    !**End
    !
    !  Set test complexity parameter.
    INTEGER, PARAMETER :: MQC = 1
    !  Declare arguments.
    !
    INTEGER :: Lun, Kprint, Ipass
    !
    !  Declare local variables.
    !
    COMPLEX(SP) :: ci, coe1, coe2, csgn, cspn, cw, cwrk(20), v(20), w(20), y(20), z, zn
    REAL(SP) :: aa, ab, aer(20), alim, arg, atol, av, cc, ct, dig, elim, eps, &
      er, ertol, ffnu, film, fnu, fnul, hpi, pi, r, rhpi, rl, &
      rm, r1m4, r1m5, r2, slak, st, t(20), tol, ts, xn, xnu(20), xx, yn, yy
    INTEGER :: i, icase, ierr, ifnu, il, ir, irb, it, itl, i4, k, &
      kdo(20), keps(20), kk, kode, k1, k2, lflg, mflg, n, nl, nu, nul, nz, nz1, nz2
    COMPLEX(SP), PARAMETER :: cip(4) = [ (1._SP,0._SP), (0._SP,1._SP), &
      (-1._SP,0._SP), (0._SP,-1._SP) ]
    !
    !* FIRST EXECUTABLE STATEMENT  CQCBY
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99001)
      99001 FORMAT (' QUICK CHECK ROUTINE FOR THE Y BESSEL FUNCTION FROM ','CBESY'/)
    END IF
    !-----------------------------------------------------------------------
    !     Set parameters related to machine constants.
    !     TOL is the approximate unit roundoff limited to 1.0E-18.
    !     ELIM is the approximate exponential over- and underflow limit.
    !     exp(-ELIM)<exp(-ALIM)=exp(-ELIM)/TOL    and
    !     exp(ELIM)>exp(ALIM)=exp(ELIM)*TOL       are intervals near
    !     underflow and overflow limits where scaled arithmetic is done.
    !     RL is the lower boundary of the asymptotic expansion for large Z.
    !     DIG = number of base 10 digits in TOL = 10**(-DIG).
    !     FNUL is the lower boundary of the asymptotic series for large FNU.
    !-----------------------------------------------------------------------
    r1m4 = R1MACH(4)
    tol = MAX(r1m4,1.E-18_SP)
    atol = 100._SP*tol
    aa = -LOG10(r1m4)
    k1 = I1MACH(12)
    k2 = I1MACH(13)
    r1m5 = R1MACH(5)
    k = MIN(ABS(k1),ABS(k2))
    elim = 2.303_SP*(k*r1m5-3._SP)
    ab = aa*2.303_SP
    alim = elim + MAX(-ab,-41.45_SP)
    dig = MIN(aa,18._SP)
    fnul = 10._SP + 6._SP*(dig-3._SP)
    rl = 1.2_SP*dig + 3._SP
    slak = 3._SP + 4._SP*(-LOG10(tol)-7._SP)/11._SP
    slak = MAX(slak,3._SP)
    ertol = tol*10._SP**slak
    rm = 0.5_SP*(alim+elim)
    rm = MIN(rm,200._SP)
    rm = MAX(rm,rl+10._SP)
    r2 = MIN(rm,fnul)
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99002)
      99002 FORMAT (' PARAMETERS'/5X,'TOL ',8X,'ELIM',8X,'ALIM',8X,'RL  ',8X,'FNUL',&
        8X,'DIG')
      WRITE (Lun,99003) tol, elim, alim, rl, fnul, dig
      99003 FORMAT (1X,6E12.4/)
    END IF
    !-----------------------------------------------------------------------
    !     Set other constants needed in the tests.
    !-----------------------------------------------------------------------
    ci = (0._SP,1._SP)
    hpi = 2._SP*ATAN(1._SP)
    rhpi = 1._SP/hpi
    pi = hpi + hpi
    !-----------------------------------------------------------------------
    !     Generate angles for construction of complex Z to be used in tests.
    !-----------------------------------------------------------------------
    !     KDO(K), K = 1,IL  determines which of the IL angles in -PI to PI
    !     are used to compute values of Z.
    !       KDO(K) = 0  means that the index K will be used for one or two
    !                   values of Z, depending on the choice of KEPS(K)
    !              = 1  means that the index K and the corresponding angle
    !                   will be skipped
    !     KEPS(K), K = 1,IL determines which of the angles get incremented
    !     up and down to put values of Z in regions where different
    !     formulae are used.
    !       KEPS(K)  = 0  means that the angle will be used without change
    !                = 1  means that the angle will be incremented up and
    !                   down by EPS
    !     The angles to be used are stored in the T(I) array, I = 1,ITL.
    !-----------------------------------------------------------------------
    IF( MQC/=2 ) THEN
      nl = 2
      il = 5
      DO i = 1, il
        keps(i) = 0
        kdo(i) = 0
      END DO
      kdo(5) = 1
      nul = 5
      xnu(1) = 0._SP
      xnu(2) = 1._SP
      xnu(3) = 2._SP
      xnu(4) = 0.5_SP*fnul
      xnu(5) = fnul + 1.2_SP
    ELSE
      nl = 4
      il = 13
      DO i = 1, il
        kdo(i) = 0
        keps(i) = 0
      END DO
      kdo(2) = 1
      kdo(6) = 1
      kdo(8) = 1
      kdo(11) = 1
      kdo(12) = 1
      kdo(13) = 1
      keps(3) = 1
      keps(4) = 1
      keps(5) = 1
      keps(9) = 1
      nul = 6
      xnu(1) = 0._SP
      xnu(2) = 0.6_SP
      xnu(3) = 1.3_SP
      xnu(4) = 2._SP
      xnu(5) = 0.5_SP*fnul
      xnu(6) = fnul + 1.2_SP
    END IF
    i = 2
    eps = 0.01_SP
    film = il - 1
    t(1) = -pi + eps
    DO k = 2, il
      IF( kdo(k)==0 ) THEN
        t(i) = pi*(-il+2*k-1)/film
        IF( keps(k)/=0 ) THEN
          ts = t(i)
          t(i) = ts - eps
          i = i + 1
          t(i) = ts + eps
        ELSE
          i = i + 1
        END IF
      END IF
    END DO
    itl = i - 1
    !-----------------------------------------------------------------------
    !     Test values of Z in -PI/2<arg(Z)<=PI
    !-----------------------------------------------------------------------
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99004)
      99004 FORMAT (' CHECKS IN THE (Z,FNU) SPACE')
    END IF
    lflg = 0
    DO kode = 1, 2
      DO n = 1, nl
        DO nu = 1, nul
          !-----------------------------------------------------------------------
          !     Construct values which will be used to set
          !           COE1 = exp(i*(FNU+1)*PI/2) and
          !           COE2 = (2/pi)*exp(-i*FNU*PI/2).
          !-----------------------------------------------------------------------
          fnu = xnu(nu)
          ifnu = INT(fnu)
          ffnu = fnu - ifnu
          arg = hpi*ffnu
          csgn = CMPLX(COS(arg),SIN(arg),SP)
          i4 = MOD(ifnu,4) + 1
          csgn = csgn*cip(i4)
          cspn = CONJG(csgn)*CMPLX(rhpi,0._SP,SP)
          csgn = csgn*ci
          DO icase = 1, 3
            irb = MIN(2,icase)
            DO ir = irb, 4
              !-------------- switch (icase)
              SELECT CASE (icase)
                CASE (2)
                  r = (2._SP*(4-ir)+r2*(ir-1))/3._SP
                CASE (3)
                  IF( r2>=rm ) EXIT
                  r = (r2*(4-ir)+rm*(ir-1))/3._SP
                CASE DEFAULT
                  r = (eps*(4-ir)+2._SP*(ir-1))/3._SP
              END SELECT
              !-------------- end switch
              DO it = 1, itl
                ct = COS(t(it))
                st = SIN(t(it))
                IF( ABS(ct)<atol ) ct = 0._SP
                IF( ABS(st)<atol ) st = 0._SP
                z = CMPLX(r*ct,r*st,SP)
                xx = REAL(z)
                yy = AIMAG(z)
                CALL CBESI(z,fnu,kode,n,w,nz2,ierr)
                !---------------- Underflow in CBESI - skip test for this case.
                IF( nz2==0 ) THEN
                  CALL CBESK(z,fnu,kode,n,y,nz1,ierr)
                  !---------------- Underflow in CBESK - skip test for this case.
                  IF( nz1==0 ) THEN
                    zn = z*ci
                    xn = -yy
                    yn = xx
                    CALL CBESY(zn,fnu,kode,n,v,nz,cwrk,ierr)
                    !---------------- Underflow in CBESY - skip test for this case.
                    IF( nz==0 ) THEN
                      coe1 = csgn
                      coe2 = cspn
                      IF( kode==2 ) THEN
                        !------------------ Adjust scale for I and K functions.
                        cc = -xx - ABS(xx)
                        IF( cc>(-alim) ) THEN
                          cw = CMPLX(cc,-yy,SP)
                          coe2 = coe2*EXP(cw)
                        ELSE
                          !-------------------- Scaling problem - skip test for this case
                          coe2 = CMPLX(0._SP,0._SP,SP)
                          CYCLE
                        END IF
                      END IF
                      DO kk = 1, n
                        y(kk) = y(kk)*coe2
                        w(kk) = w(kk)*coe1
                        coe1 = coe1*ci
                        coe2 = -coe2*ci
                      END DO
                      !-----------------------------------------------------------------------
                      !     Compare Y(ZN,FNU) with COE1*I(Z,FNU)-COE2*K(Z,FNU).
                      !-----------------------------------------------------------------------
                      mflg = 0
                      DO i = 1, n
                        ab = fnu + i - 1
                        aa = MAX(0.5_SP,ab)
                        cw = w(i) - y(i)
                        av = ABS(v(i))
                        er = ABS(cw-v(i))
                        IF( av/=0._SP ) THEN
                          IF( yn/=0._SP ) THEN
                            er = er/av
                          ELSEIF( xn>0._SP ) THEN
                            IF( ABS(xn)<aa ) er = er/av
                          ELSEIF( ABS(ffnu-0.5_SP)<0.125_SP ) THEN
                            IF( ABS(xn)<aa ) er = er/av
                          ELSE
                            er = er/av
                          END IF
                        END IF
                        aer(i) = er
                        IF( er>ertol ) mflg = 1
                      END DO
                      IF( mflg/=0 ) THEN
                        IF( lflg==0 ) THEN
                          IF( Kprint>=2 ) THEN
                            WRITE (Lun,99005) ertol
                            99005 FORMAT (/' CASES WHICH VIOLATE THE RELATIVE ',&
                              'ERROR TEST WITH ERTOL = ',E12.4/)
                            WRITE (Lun,99006)
                            99006 FORMAT (' INPUT TO CBESY   ZN, FNU, KODE, N')
                          END IF
                          IF( Kprint>=3 ) THEN
                            WRITE (Lun,99007)
                            99007 FORMAT (' COMPARE Y(ZN,FNU) WITH COE1*I(Z,FNU)',&
                              '-COE2*K(Z,FNU)')
                            WRITE (Lun,99008)
                            99008 FORMAT (' Z = ZN*EXP(-i*PI/2)'/&
                              ' COE1 = EXP(i*(FNU+1)*PI/2)  ',&
                              ' COE2 = (2/PI)*EXP(-i*FNU*PI/2)')
                            WRITE (Lun,99009)
                            99009 FORMAT (' RESULTS FROM CBESY   V(KK)'/9X,&
                              'FROM CBESI   W(KK)'/9X,&
                              'FROM CBESK   Y(KK)')
                            WRITE (Lun,99010)
                            99010 FORMAT (' TEST CASE INDICES   IR, IT, ICASE'/)
                          END IF
                        END IF
                        lflg = lflg + 1
                        IF( Kprint>=2 ) THEN
                          WRITE (Lun,99011) zn, fnu, kode, n
                          99011 FORMAT ('   INPUT:   ZN=',2E12.4,3X,'FNU=',E12.4,3X,&
                            'KODE=',I3,3X,'N=',I3)
                        END IF
                        IF( Kprint>=3 ) THEN
                          WRITE (Lun,99012) (aer(k),k=1,n)
                          99012 FORMAT ('   ERROR:   AER(K)=',4E12.4)
                          WRITE (Lun,99013) z, coe1, coe2
                          99013 FORMAT (12X,'Z=',2E12.4/12X,'COE1=',2E12.4,3X,&
                            'COE2=',2E12.4)
                          kk = MAX(nz1,nz2) + 1
                          kk = MIN(n,kk)
                          WRITE (Lun,99014) v(kk), w(kk), y(kk)
                          99014 FORMAT (' RESULTS:   V(KK)=',2E12.4/12X,'W(KK)=',&
                            2E12.4/12X,'Y(KK)=',2E12.4)
                          WRITE (Lun,99015) ir, it, icase
                          99015 FORMAT ('    CASE:   IR=',I3,3X,'IT=',I3,3X,&
                            'ICASE=',I3/)
                        END IF
                      END IF
                    END IF
                  END IF
                END IF
              END DO
            END DO
          END DO
        END DO
      END DO
    END DO
    IF( Kprint>=2 ) THEN
      IF( lflg==0 ) THEN
        WRITE (Lun,99016)
        99016 FORMAT (' QUICK CHECKS OK')
      ELSE
        WRITE (Lun,99017) lflg
        99017 FORMAT (' ***',I5,' FAILURE(S) FOR CBESY IN THE (Z,FNU) ','PLANE')
      END IF
    END IF
    Ipass = 0
    IF( lflg==0 ) Ipass = 1
    IF( Ipass==1 .AND. Kprint>=2 ) THEN
      WRITE (Lun,99018)
      99018 FORMAT (/' ****** CBESY  PASSED ALL TESTS  ******'/)
    END IF
    IF( Ipass==0 .AND. Kprint>=1 ) THEN
      WRITE (Lun,99019)
      99019 FORMAT (/' ****** CBESY  FAILED SOME TESTS ******'/)
    END IF
  END SUBROUTINE CQCBY
END MODULE TEST09_MOD
!** TEST09
PROGRAM TEST09
  USE TEST09_MOD, ONLY : CQCAI, CQCBH, CQCBI, CQCBJ, CQCBK, CQCBY
  USE slatec, ONLY : I1MACH, XSETF, XSETUN, XERMAX
  USE common_mod, ONLY : GET_ARGUMENT
  IMPLICIT NONE
  !> Driver for testing SLATEC subprograms.
  !***
  ! **Library:**   SLATEC
  !***
  ! **Category:**  C7A, C10A4, C10B4, C10D
  !***
  ! **Type:**      SINGLE PRECISION (TEST09-S, TEST10-D)
  !***
  ! **Keywords:**  QUICK CHECK DRIVER
  !***
  ! **Author:**  SLATEC Common Mathematical Library Committee
  !***
  ! **Description:**
  !
  !- Usage:
  !     One input data record is required
  !         READ (LIN, '(I1)') KPRINT
  !
  !- Arguments:
  !     KPRINT = 0  Quick checks - No printing.
  !                 Driver       - Short pass or fail message printed.
  !              1  Quick checks - No message printed for passed tests,
  !                                short message printed for failed tests.
  !                 Driver       - Short pass or fail message printed.
  !              2  Quick checks - Print short message for passed tests,
  !                                fuller information for failed tests.
  !                 Driver       - Pass or fail message printed.
  !              3  Quick checks - Print complete quick check results.
  !                 Driver       - Pass or fail message printed.
  !
  !- Description:
  !     Driver for testing SLATEC subprograms
  !         CAIRY, CBESH, CBESI, CBESJ, CBESK, CBESY, CBIRY, CUOIK, CWRSK
  !
  !***
  ! **References:**  Fong, Kirby W., Jefferson, Thomas H., Suyehiro,
  !                 Tokihiko, Walton, Lee, Guidelines to the SLATEC Common
  !                 Mathematical Library, March 21, 1989.
  !***
  ! **Routines called:**  CQCAI, CQCBH, CQCBI, CQCBJ, CQCBK, CQCBY, I1MACH,
  !                    XERMAX, XSETF, XSETUN

  !* REVISION HISTORY  (YYMMDD)
  !   910411  DATE WRITTEN
  !   920128  Category corrected.  (WRB)
  INTEGER :: ipass, kprint, lin, lun, nfail
  !* FIRST EXECUTABLE STATEMENT  TEST09
  lun = I1MACH(2)
  lin = I1MACH(1)
  nfail = 0
  !
  !     Read KPRINT parameter
  !
  CALL GET_ARGUMENT(kprint)
  CALL XERMAX(1000)
  CALL XSETUN(lun)
  IF( kprint<=1 ) THEN
    CALL XSETF(0)
  ELSE
    CALL XSETF(1)
  END IF
  !
  !     Test Single Precision Complex Bessel Functions.
  !
  CALL CQCAI(lun,kprint,ipass)
  IF( ipass==0 ) nfail = nfail + 1
  CALL CQCBH(lun,kprint,ipass)
  IF( ipass==0 ) nfail = nfail + 1
  CALL CQCBI(lun,kprint,ipass)
  IF( ipass==0 ) nfail = nfail + 1
  CALL CQCBJ(lun,kprint,ipass)
  IF( ipass==0 ) nfail = nfail + 1
  CALL CQCBK(lun,kprint,ipass)
  IF( ipass==0 ) nfail = nfail + 1
  CALL CQCBY(lun,kprint,ipass)
  IF( ipass==0 ) nfail = nfail + 1
  !
  !     Write PASS or FAIL message
  !
  IF( nfail==0 ) THEN
    WRITE (lun,99001)
    99001 FORMAT (/' --------------TEST09 PASSED ALL TESTS----------------')
  ELSE
    WRITE (lun,99002) nfail
    99002 FORMAT (/' ************* WARNING -- ',I5,&
      ' TEST(S) FAILED IN PROGRAM TEST09  *************')
  END IF
  STOP
END PROGRAM TEST09
