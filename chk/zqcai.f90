!*==ZQCAI.f90  processed by SPAG 6.72Dc at 10:52 on  6 Feb 2019
!DECK ZQCAI
SUBROUTINE ZQCAI(Lun,Kprint,Ipass)
  IMPLICIT NONE
  !*--ZQCAI5
  !***BEGIN PROLOGUE  ZQCAI
  !***SUBSIDIARY
  !***PURPOSE  Quick check for SLATEC subroutines
  !            ZAIRY, ZBIRY
  !***LIBRARY   SLATEC
  !***CATEGORY  C10D
  !***TYPE      COMPLEX (CQCAI-C, ZQCAI-Z)
  !***KEYWORDS  QUICK CHECK, ZAIRY, ZBIRY
  !***AUTHOR  Amos, Don, (SNL)
  !           Goudy, Sue, (SNL)
  !           Walton, Lee, (SNL)
  !***DESCRIPTION
  !
  ! *Usage:
  !
  !        INTEGER  LUN, KPRINT, IPASS
  !
  !        CALL ZQCAI (LUN, KPRINT, IPASS)
  !
  ! *Arguments:
  !
  !     LUN    :IN  is the unit number to which output is to be written.
  !
  !     KPRINT :IN  controls the amount of output, as specified in the
  !                 SLATEC Guidelines.
  !
  !     IPASS  :OUT indicates whether the test passed or failed.
  !                 A value of one is good, indicating no failures.
  !
  ! *Description:
  !
  !               *** A DOUBLE PRECISION ROUTINE ***
  !
  !   ZQCAI is a quick check routine for the complex Airy functions
  !    generated by subroutines ZAIRY and ZBIRY.
  !
  !   ZQCAI generates Airy functions and their derivatives from ZAIRY
  !    and ZBIRY and checks them against the Wronskian evaluation
  !    in the Z plane.
  !
  !***REFERENCES  Abramowitz, M. and Stegun, I. A., Handbook
  !                 of Mathematical Functions, Dover Publications,
  !                 New York, 1964.
  !               Amos, D. E., A Subroutine Package for Bessel
  !                 Functions of a Complex Argument and Nonnegative
  !                 Order, SAND85-1018, May, 1985.
  !***ROUTINES CALLED  ZAIRY, ZBIRY, ZABS, ZSQRT, ZEXP, I1MACH, D1MACH
  !***REVISION HISTORY  (YYMMDD)
  !   830501  DATE WRITTEN
  !   890831  Revised to meet new SLATEC standards
  !   930122  Added ZEXP and ZSQRT to EXTERNAL statement.  (RWC)
  !***END PROLOGUE  ZQCAI
  !
  !*Internal Notes:
  !   Machine constants are defined by functions I1MACH and D1MACH.
  !
  !   The parameter MQC can have values 1 (the default) for a faster,
  !   less definitive test or 2 for a slower, more definitive test.
  !
  !**End
  !
  !  Set test complexity parameter.
  !
  INTEGER MQC
  PARAMETER (MQC=1)
  !
  !  Declare arguments.
  !
  INTEGER Lun , Kprint , Ipass
  !
  !  Declare external functions.
  !
  INTEGER I1MACH
  REAL(8) :: D1MACH , ZABS
  EXTERNAL I1MACH , D1MACH , ZABS , ZEXP , ZSQRT
  !
  !  Declare local variables.
  !
  REAL(8) :: con1r , con1i , con2r , con2i , con3r , con3i , cvr , &
    cvi , cwr , cwi , cyr , cyi , wr , wi , yr , yi , zr , &
    zi , zrr , zri
  REAL(8) :: aa , ab , acw , acy , alim , arg , atol , av , azrr , &
    a1 , a2 , ct , c23 , dig , elim , eps , er , ertol , &
    film , fnul , fpi , hpi , pi , pi3 , ptr , r , rl , rm , &
    rpi , rtpi , r1m4 , r1m5 , slak , spi , st , sti , str , &
    t , tol , tpi , tpi3 , ts
  INTEGER i , icase , icl , ierr , il , ir , irb , irset , it , itl , k , &
    kdo , keps , kode , k1 , k2 , lflg , nz1 , nz2 , nz3 , nz4
  DIMENSION kdo(20) , keps(20) , t(20) , wr(20) , wi(20) , yr(20) , yi(20)
  !
  !***FIRST EXECUTABLE STATEMENT  ZQCAI
  IF ( Kprint>=2 ) THEN
    WRITE (Lun,99001)
    99001   FORMAT (' QUICK CHECK ROUTINE FOR THE AIRY FUNCTIONS FROM ',&
      'ZAIRY AND ZBIRY'/)
  ENDIF
  !-----------------------------------------------------------------------
  !     Set parameters related to machine constants.
  !     TOL is the approximate unit roundoff limited to 1.0D-18.
  !     ELIM is the approximate exponential over- and underflow limit.
  !     exp(-ELIM).lt.exp(-ALIM)=exp(-ELIM)/TOL    and
  !     exp(ELIM).gt.exp(ALIM)=exp(ELIM)*TOL       are intervals near
  !     underflow and overflow limits where scaled arithmetic is done.
  !     RL is the lower boundary of the asymptotic expansion for large Z.
  !     DIG = number of base 10 digits in TOL = 10**(-DIG).
  !     FNUL is the lower boundary of the asymptotic series for large FNU.
  !-----------------------------------------------------------------------
  r1m4 = D1MACH(4)
  tol = MAX(r1m4,1.0D-18)
  atol = 100.0D0*tol
  aa = -LOG10(r1m4)
  k1 = I1MACH(12)
  k2 = I1MACH(13)
  r1m5 = D1MACH(5)
  k = MIN(ABS(k1),ABS(k2))
  elim = 2.303D0*(k*r1m5-3.0D0)
  ab = aa*2.303D0
  alim = elim + MAX(-ab,-41.45D0)
  dig = MIN(aa,18.0D0)
  slak = 3.0D0 + 4.0D0*(-LOG10(tol)-7.0D0)/11.0D0
  slak = MAX(slak,3.0D0)
  ertol = tol*10.0D0**slak
  rl = 1.2D0*dig + 3.0D0
  rm = 0.5D0*(alim+elim)
  rm = MIN(rm,200.0D0)
  rm = MAX(rm,rl+10.0D0)
  fnul = 10.0D0 + 6.0D0*(dig-3.0D0)
  IF ( Kprint>=2 ) THEN
    WRITE (Lun,99002)
    99002   FORMAT (' PARAMETERS'/5X,'TOL ',8X,'ELIM',8X,'ALIM',8X,'RL  ',8X,'FNUL',&
      8X,'DIG')
    WRITE (Lun,99003) tol , elim , alim , rl , fnul , dig
    99003   FORMAT (6D12.4/)
  ENDIF
  !-----------------------------------------------------------------------
  !     Generate angles for construction of complex Z to be used in tests.
  !-----------------------------------------------------------------------
  fpi = ATAN(1.0D0)
  hpi = fpi + fpi
  pi = hpi + hpi
  tpi = pi + pi
  rpi = 1.0D0/pi
  tpi3 = tpi/3.0D0
  spi = pi/6.0D0
  pi3 = spi + spi
  rtpi = 1.0D0/tpi
  a1 = rtpi*COS(spi)
  a2 = rtpi*SIN(spi)
  con1r = COS(tpi3)
  con1i = SIN(tpi3)
  con2r = a1
  con2i = -a2
  con3r = rpi
  con3i = 0.0D0
  c23 = 2.0D0/3.0D0
  !-----------------------------------------------------------------------
  !     KDO(K), K = 1,IL  determines which of the IL angles in -PI to PI
  !     are used to compute values of Z.
  !       KDO(K) = 0  means that the index K will be used for one or two
  !                   values of Z, depending on the choice of KEPS(K)
  !              = 1  means that the index K and the corresponding angle
  !                   will be skipped
  !     KEPS(K), K = 1,IL determines which of the angles get incremented
  !     up and down to put values of Z in regions where different
  !     formulae are used.
  !       KEPS(K)  = 0  means that the angle will be used without change
  !                = 1  means that the angle will be incremented up and
  !                   down by EPS
  !     The angles to be used are stored in the T(I) array, I = 1,ITL.
  !-----------------------------------------------------------------------
  IF ( MQC/=2 ) THEN
    icl = 1
    il = 5
    DO i = 1 , il
      kdo(i) = 0
      keps(i) = 0
    ENDDO
  ELSE
    icl = 2
    il = 7
    DO i = 1 , il
      kdo(i) = 0
      keps(i) = 0
    ENDDO
    keps(2) = 1
    keps(3) = 1
    keps(5) = 1
    keps(6) = 1
  ENDIF
  i = 2
  eps = 0.01D0
  film = il - 1
  t(1) = -pi + eps
  DO k = 2 , il
    IF ( kdo(k)==0 ) THEN
      t(i) = pi*(-il+2*k-1)/film
      IF ( keps(k)/=0 ) THEN
        ts = t(i)
        t(i) = ts - eps
        i = i + 1
        t(i) = ts + eps
      ENDIF
      i = i + 1
    ENDIF
  ENDDO
  itl = i - 1
  !-----------------------------------------------------------------------
  !     Test values of Z in -PI.lt.arg(Z).le.PI near formula boundaries.
  !-----------------------------------------------------------------------
  IF ( Kprint>=2 ) THEN
    WRITE (Lun,99004)
    99004   FORMAT (' CHECKS IN THE Z PLANE'/)
  ENDIF
  lflg = 0
  DO icase = 1 , icl
    !-----------------------------------------------------------------------
    !     ICASE = 1 computes wron(AI(Z),BI(Z))     =CON3
    !     ICASE = 2 computes wron(AI(Z),AI(Z*CON1))=CON2
    !-----------------------------------------------------------------------
    DO kode = 1 , 2
      DO irset = 1 , 3
        irb = MIN(irset,2)
        DO ir = irb , 4
          !------------ switch (irset)
          SELECT CASE (irset)
            CASE (2)
              r = (2.0D0*(4-ir)+rl*(ir-1))/3.0D0
            CASE (3)
              r = (rl*(4-ir)+rm*(ir-1))/3.0D0
            CASE DEFAULT
              r = 2.0D0*(ir-1)/3.0D0
          END SELECT
          !------------ end switch
          DO it = 1 , itl
            !----------------------------------------------------------------------
            !     The following values are set before the DO 30 loop:
            !            C23 = 2/3
            !           CON1 = cmplx(cos(2PI/3),sin(2PI/3))
            !           CON2 = cmplx(cos(PI/6),-sin(PI/6)/2PI
            !           CON3 = cmplx(1/PI,0)
            !----------------------------------------------------------------------
            ct = COS(t(it))
            st = SIN(t(it))
            IF ( ABS(ct)<atol ) ct = 0.0D0
            IF ( ABS(st)<atol ) st = 0.0D0
            zr = r*ct
            zi = r*st
            CALL ZSQRT(zr,zi,str,sti)
            ptr = (zr*str-zi*sti)*c23
            zri = (zr*sti+zi*str)*c23
            zrr = ptr
            azrr = ABS(zrr)
            !-------------- Check for possible underflow or overflow
            IF ( azrr/=0.0D0 ) THEN
              arg = -azrr - 0.5D0*LOG(azrr) + 0.226D0
              arg = arg + arg
              !---------------- Skip test for this case?
              IF ( arg<(-elim) ) CYCLE
            ENDIF
            CALL ZAIRY(zr,zi,0,kode,yr(1),yi(1),nz1,ierr)
            CALL ZAIRY(zr,zi,1,kode,yr(2),yi(2),nz2,ierr)
            IF ( icase==1 ) THEN
              !---------------- Compare 1/PI with Wronskian of ZAIRY(Z) and ZBIRY(Z).
              CALL ZBIRY(zr,zi,0,kode,wr(1),wi(1),ierr)
              CALL ZBIRY(zr,zi,1,kode,wr(2),wi(2),ierr)
              IF ( kode==2 ) THEN
                !-----------------------------------------------------------------------
                !     When KODE = 2, the scaling factor exp(-zeta1-zeta2) is 1.0 for
                !     -PI.lt.arg(Z).le.PI/3 and exp(-2.0*zeta1) for PI/3.lt.arg(Z)
                !     .le.PI where zeta1 = zeta2 in this range. This is due to the fact
                !     that arg(Z*CON1) is taken to be in (-PI,PI) by the principal
                !     square root.
                !-----------------------------------------------------------------------
                !------------------ Adjust scaling factor.
                cvr = azrr - zrr
                cvi = -zri
                CALL ZEXP(cvr,cvi,cvr,cvi)
                str = wr(1)*cvr - wi(1)*cvi
                wi(1) = wr(1)*cvi + wi(1)*cvr
                wr(1) = str
                str = wr(2)*cvr - wi(2)*cvi
                wi(2) = wr(2)*cvi + wi(2)*cvr
                wr(2) = str
              ENDIF
              cvr = con3r
              cvi = con3i
            ELSE
              !---------------- Compare exp(-i*PI/6)/2PI with Wronskian of ZAIRY(Z)
              !                 and ZAIRY(Z*exp(2i*PI/3)).
              cvr = zr*con1r - zi*con1i
              cvi = zr*con1i + zi*con1r
              CALL ZAIRY(cvr,cvi,0,kode,wr(1),wi(1),nz3,ierr)
              CALL ZAIRY(cvr,cvi,1,kode,wr(2),wi(2),nz4,ierr)
              IF ( kode==2 ) THEN
                IF ( t(it)>=pi3 ) THEN
                  !-------------------- Adjust scaling factor.
                  cvr = zrr + zrr
                  cvi = zri + zri
                  CALL ZEXP(-cvr,-cvi,cvr,cvi)
                  str = wr(1)*cvr - wi(1)*cvi
                  wi(1) = wr(1)*cvi + wi(1)*cvr
                  wr(1) = str
                  str = wr(2)*cvr - wi(2)*cvi
                  wi(2) = wr(2)*cvi + wi(2)*cvr
                  wr(2) = str
                ENDIF
              ENDIF
              str = wr(2)*con1r - wi(2)*con1i
              wi(2) = wr(2)*con1i + wi(2)*con1r
              wr(2) = str
              cvr = con2r
              cvi = con2i
            ENDIF
            !-----------------------------------------------------------------------
            !     Error relative to maximum term
            !-----------------------------------------------------------------------
            av = ZABS(cvr,cvi)
            cwr = yr(1)*wr(2) - yi(1)*wi(2)
            cwi = yr(1)*wi(2) + yi(1)*wr(2)
            cyr = yr(2)*wr(1) - yi(2)*wi(1)
            cyi = yr(2)*wi(1) + yi(2)*wr(1)
            cyr = cwr - cyr - cvr
            cyi = cwi - cyi - cvi
            acy = ZABS(yr(1),yi(1))*ZABS(wr(2),wi(2))
            acw = ZABS(wr(1),wi(1))*ZABS(yr(2),yi(2))
            av = MAX(acw,acy,av)
            er = ZABS(cyr,cyi)/av
            IF ( er>=ertol ) THEN
              IF ( lflg==0 ) THEN
                IF ( Kprint>=2 ) THEN
                  WRITE (Lun,99005) ertol
                  99005                 FORMAT (' CASES WHICH VIOLATE THE RELATIVE ERROR',&
                    ' TEST WITH ERTOL = ',D12.4/)
                  WRITE (Lun,99006)
                  99006                 FORMAT (' INPUT TO ZAIRY AND ERROR')
                ENDIF
                IF ( Kprint>=3 ) THEN
                  WRITE (Lun,99007)
                  99007                 FORMAT (' COMPARISON VALUE AND WRONSKIAN')
                  WRITE (Lun,99008)
                  99008                 FORMAT (' RESULTS FROM ZAIRY AND/OR ZBIRY')
                  WRITE (Lun,99009)
                  99009                 FORMAT (' TEST CASE INDICES'/)
                ENDIF
              ENDIF
              lflg = 1
              IF ( Kprint>=2 ) THEN
                WRITE (Lun,99010) zr , zi , er
                99010               FORMAT (12X,'INPUT:    Z=',2D12.4,5X,'ERROR:   ER=',D12.4)
              ENDIF
              IF ( Kprint>=3 ) THEN
                WRITE (Lun,99011) cvr , cvi , cyr , cyi
                99011               FORMAT (' COMPARISON VALUE:   CV=',2D12.4/8X,&
                  'WRONSKIAN:   CY=',2D12.4)
                WRITE (Lun,99012) nz1 , yr(1) , yi(1) , nz2 , yr(2) , yi(2)
                99012               FORMAT (10X,'RESULTS:  NZ1=',I3,4X,'Y(1)=',2D12.4/20X,&
                  'NZ2=',I3,4X,'Y(2)=',2D12.4)
                IF ( icase==1 ) THEN
                  WRITE (Lun,99013) wr(1) , wi(1) , wr(2) , wi(2)
                  99013                 FORMAT (31X,'W(1)=',2D12.4/31X,'W(2)=',2D12.4)
                ELSE
                  WRITE (Lun,99014) nz3 , wr(1) , wi(1) , nz4 , wr(2) , &
                    wi(2)
                  99014                 FORMAT (20X,'NZ3=',I3,4X,'W(1)=',2D12.4/20X,'NZ4=',I3,4X,&
                    'W(2)=',2D12.4)
                ENDIF
                WRITE (Lun,99015) it , ir , irset , icase
                99015               FORMAT (13X,'CASE:   IT=',I3,4X,'IR=',I3,4X,'IRSET=',I3,4X,&
                  'ICASE=',I3,4X/)
              ENDIF
            ENDIF
          ENDDO
        ENDDO
      ENDDO
    ENDDO
  ENDDO
  IF ( Kprint>=2 ) THEN
    IF ( lflg==0 ) THEN
      WRITE (Lun,99016)
      99016     FORMAT (' QUICK CHECKS OK')
    ELSE
      WRITE (Lun,99017)
      99017     FORMAT (' ***',5X,'FAILURE(S) FOR ZAIRY IN THE Z PLANE')
    ENDIF
  ENDIF
  Ipass = 0
  IF ( lflg==0 ) Ipass = 1
  IF ( Ipass==1.AND.Kprint>=2 ) THEN
    WRITE (Lun,99018)
    99018   FORMAT (/' ****** ZAIRY  PASSED ALL TESTS  ******'/)
  ENDIF
  IF ( Ipass==0.AND.Kprint>=1 ) THEN
    WRITE (Lun,99019)
    99019   FORMAT (/' ****** ZAIRY  FAILED SOME TESTS ******'/)
  ENDIF
END SUBROUTINE ZQCAI
