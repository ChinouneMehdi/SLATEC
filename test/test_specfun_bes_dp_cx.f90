MODULE TEST10_MOD
  USE service, ONLY : SP, DP
  IMPLICIT NONE

CONTAINS
  !** ZQCAI
  SUBROUTINE ZQCAI(Lun,Kprint,Ipass)
    !> Quick check for SLATEC subroutines
    !            ZAIRY, ZBIRY
    !***
    ! **Library:**   SLATEC
    !***
    ! **Category:**  C10D
    !***
    ! **Type:**      COMPLEX (CQCAI-C, ZQCAI-Z)
    !***
    ! **Keywords:**  QUICK CHECK, ZAIRY, ZBIRY
    !***
    ! **Author:**  Amos, Don, (SNL)
    !           Goudy, Sue, (SNL)
    !           Walton, Lee, (SNL)
    !***
    ! **Description:**
    !
    !- Usage:
    !
    !        INTEGER  LUN, KPRINT, IPASS
    !
    !        CALL ZQCAI (LUN, KPRINT, IPASS)
    !
    !- Arguments:
    !
    !     LUN    :IN  is the unit number to which output is to be written.
    !
    !     KPRINT :IN  controls the amount of output, as specified in the
    !                 SLATEC Guidelines.
    !
    !     IPASS  :OUT indicates whether the test passed or failed.
    !                 A value of one is good, indicating no failures.
    !
    !- Description:
    !
    !               *** A DOUBLE PRECISION ROUTINE ***
    !
    !   ZQCAI is a quick check routine for the complex Airy functions
    !    generated by subroutines ZAIRY and ZBIRY.
    !
    !   ZQCAI generates Airy functions and their derivatives from ZAIRY
    !    and ZBIRY and checks them against the Wronskian evaluation
    !    in the Z plane.
    !
    !***
    ! **References:**  Abramowitz, M. and Stegun, I. A., Handbook
    !                 of Mathematical Functions, Dover Publications,
    !                 New York, 1964.
    !               Amos, D. E., A Subroutine Package for Bessel
    !                 Functions of a Complex Argument and Nonnegative
    !                 Order, SAND85-1018, May, 1985.
    !***
    ! **Routines called:**  ZAIRY, ZBIRY, ZABS, ZSQRT, ZEXP, I1MACH, D1MACH

    !* REVISION HISTORY  (YYMMDD)
    !   830501  DATE WRITTEN
    !   890831  Revised to meet new SLATEC standards
    !   930122  Added ZEXP and ZSQRT to EXTERNAL statement.  (RWC)
    USE service, ONLY : eps_dp, log10_radix_dp, min_exp_dp, max_exp_dp, huge_dp
    USE special_functions, ONLY : ZAIRY, ZBIRY
    USE IEEE_ARITHMETIC, ONLY : IEEE_IS_FINITE
    !
    !*Internal Notes:
    !   Machine constants are defined by functions I1MACH and D1MACH.
    !
    !   The parameter MQC can have values 1 (the default) for a faster,
    !   less definitive test or 2 for a slower, more definitive test.
    !
    !**End
    !
    !  Set test complexity parameter.
    INTEGER, PARAMETER :: MQC = 1
    !  Declare arguments.
    !
    INTEGER :: Lun, Kprint, Ipass
    !
    !  Declare local variables.
    !
    REAL(DP) :: aa, ab, acw, acy, alim, arg, atol, av, azrr, a1, a2, ct, c23, &
      dig, elim, eps, er, ertol, film, fnul, fpi, hpi, pi, pi3, r, rl, rm, &
      rpi, rtpi, r1m4, r1m5, slak, spi, st, t(20), tol, tpi, tpi3, ts
    COMPLEX(DP) :: con1, con2, con3, cv, cw, cy, w(20), y(20), z, zr
    INTEGER :: i, icase, icl, ierr, il, ir, irb, irset, it, itl, k, &
      kdo(20), keps(20), kode, k1, k2, lflg, nz1, nz2, nz3, nz4
    REAL(DP), PARAMETER :: sqrt_huge = SQRT( huge_dp )
    !
    !* FIRST EXECUTABLE STATEMENT  ZQCAI
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99001)
      99001 FORMAT (' QUICK CHECK ROUTINE FOR THE AIRY FUNCTIONS FROM ',&
        'ZAIRY AND ZBIRY'/)
    END IF
    !-----------------------------------------------------------------------
    !     Set parameters related to machine constants.
    !     TOL is the approximate unit roundoff limited to 1.0D-18.
    !     ELIM is the approximate exponential over- and underflow limit.
    !     exp(-ELIM)<exp(-ALIM)=exp(-ELIM)/TOL    and
    !     exp(ELIM)>exp(ALIM)=exp(ELIM)*TOL       are intervals near
    !     underflow and overflow limits where scaled arithmetic is done.
    !     RL is the lower boundary of the asymptotic expansion for large Z.
    !     DIG = number of base 10 digits in TOL = 10**(-DIG).
    !     FNUL is the lower boundary of the asymptotic series for large FNU.
    !-----------------------------------------------------------------------
    r1m4 = eps_dp
    tol = MAX(r1m4,1.E-18_DP)
    atol = 100._DP*tol
    aa = -LOG10(r1m4)
    k1 = min_exp_dp
    k2 = max_exp_dp
    r1m5 = log10_radix_dp
    k = MIN(ABS(k1),ABS(k2))
    elim = 2.303_DP*(k*r1m5-3._DP)
    ab = aa*2.303_DP
    alim = elim + MAX(-ab,-41.45_DP)
    dig = MIN(aa,18._DP)
    slak = 3._DP + 4._DP*(-LOG10(tol)-7._DP)/11._DP
    slak = MAX(slak,3._DP)
    ertol = tol*10._DP**slak
    rl = 1.2_DP*dig + 3._DP
    rm = 0.5_DP*(alim+elim)
    rm = MIN(rm,200._DP)
    rm = MAX(rm,rl+10._DP)
    fnul = 10._DP + 6._DP*(dig-3._DP)
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99002)
      99002 FORMAT (' PARAMETERS'/5X,'TOL ',8X,'ELIM',8X,'ALIM',8X,'RL  ',8X,'FNUL',&
        8X,'DIG')
      WRITE (Lun,99003) tol, elim, alim, rl, fnul, dig
      99003 FORMAT (6D12.4/)
    END IF
    !-----------------------------------------------------------------------
    !     Generate angles for construction of complex Z to be used in tests.
    !-----------------------------------------------------------------------
    fpi = ATAN(1._DP)
    hpi = fpi + fpi
    pi = hpi + hpi
    tpi = pi + pi
    rpi = 1._DP/pi
    tpi3 = tpi/3._DP
    spi = pi/6._DP
    pi3 = spi + spi
    rtpi = 1._DP/tpi
    a1 = rtpi*COS(spi)
    a2 = rtpi*SIN(spi)
    con1 = CMPLX( COS(tpi3), SIN(tpi3), DP)
    con2 = CMPLX( a1, -a2, DP )
    con3 = CMPLX( rpi, 0._DP, DP )
    c23 = 2._DP/3._DP
    !-----------------------------------------------------------------------
    !     KDO(K), K = 1,IL  determines which of the IL angles in -PI to PI
    !     are used to compute values of Z.
    !       KDO(K) = 0  means that the index K will be used for one or two
    !                   values of Z, depending on the choice of KEPS(K)
    !              = 1  means that the index K and the corresponding angle
    !                   will be skipped
    !     KEPS(K), K = 1,IL determines which of the angles get incremented
    !     up and down to put values of Z in regions where different
    !     formulae are used.
    !       KEPS(K)  = 0  means that the angle will be used without change
    !                = 1  means that the angle will be incremented up and
    !                   down by EPS
    !     The angles to be used are stored in the T(I) array, I = 1,ITL.
    !-----------------------------------------------------------------------
    IF( MQC/=2 ) THEN
      icl = 1
      il = 5
      DO i = 1, il
        kdo(i) = 0
        keps(i) = 0
      END DO
    ELSE
      icl = 2
      il = 7
      DO i = 1, il
        kdo(i) = 0
        keps(i) = 0
      END DO
      keps(2) = 1
      keps(3) = 1
      keps(5) = 1
      keps(6) = 1
    END IF
    i = 2
    eps = 0.01_DP
    film = il - 1
    t(1) = -pi + eps
    DO k = 2, il
      IF( kdo(k)==0 ) THEN
        t(i) = pi*(-il+2*k-1)/film
        IF( keps(k)/=0 ) THEN
          ts = t(i)
          t(i) = ts - eps
          i = i + 1
          t(i) = ts + eps
        END IF
        i = i + 1
      END IF
    END DO
    itl = i - 1
    !-----------------------------------------------------------------------
    !     Test values of Z in -PI<arg(Z)<=PI near formula boundaries.
    !-----------------------------------------------------------------------
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99004)
      99004 FORMAT (' CHECKS IN THE Z PLANE'/)
    END IF
    lflg = 0
    DO icase = 1, icl
      !-----------------------------------------------------------------------
      !     ICASE = 1 computes wron(AI(Z),BI(Z))     =CON3
      !     ICASE = 2 computes wron(AI(Z),AI(Z*CON1))=CON2
      !-----------------------------------------------------------------------
      DO kode = 1, 2
        DO irset = 1, 3
          irb = MIN(irset,2)
          DO ir = irb, 4
            !------------ switch (irset)
            SELECT CASE (irset)
              CASE (2)
                r = (2._DP*(4-ir)+rl*(ir-1))/3._DP
              CASE (3)
                r = (rl*(4-ir)+rm*(ir-1))/3._DP
              CASE DEFAULT
                r = 2._DP*(ir-1)/3._DP
            END SELECT
            !------------ end switch
            DO it = 1, itl
              !----------------------------------------------------------------------
              !     The following values are set before the DO 30 loop:
              !            C23 = 2/3
              !           CON1 = cmplx(cos(2PI/3),sin(2PI/3))
              !           CON2 = cmplx(cos(PI/6),-sin(PI/6)/2PI
              !           CON3 = cmplx(1/PI,0)
              !----------------------------------------------------------------------
              ct = COS(t(it))
              st = SIN(t(it))
              IF( ABS(ct)<atol ) ct = 0._DP
              IF( ABS(st)<atol ) st = 0._DP
              z = r*CMPLX(ct,st,DP)
              zr = z*SQRT(z)*c23
              azrr = ABS(REAL(zr,DP))
              !-------------- Check for possible underflow or overflow
              IF( azrr/=0._DP ) THEN
                arg = -azrr - 0.5_DP*LOG(azrr) + 0.226_DP
                arg = arg + arg
                !---------------- Skip test for this case?
                IF( arg<(-elim) ) CYCLE
              END IF
              CALL ZAIRY(z,0,kode,y(1),nz1,ierr)
              CALL ZAIRY(z,1,kode,y(2),nz2,ierr)
              IF( icase==1 ) THEN
                !---------------- Compare 1/PI with Wronskian of ZAIRY(Z) and ZBIRY(Z).
                CALL ZBIRY(z,0,kode,w(1),ierr)
                CALL ZBIRY(z,1,kode,w(2),ierr)
                IF( kode==2 ) THEN
                  !-----------------------------------------------------------------------
                  !     When KODE = 2, the scaling factor exp(-zeta1-zeta2) is 1.0 for
                  !     -PI<arg(Z)<=PI/3 and exp(-2.0*zeta1) for PI/3<arg(Z)
                  !     <=PI where zeta1 = zeta2 in this range. This is due to the fact
                  !     that arg(Z*CON1) is taken to be in (-PI,PI) by the principal
                  !     square root.
                  !-----------------------------------------------------------------------
                  !------------------ Adjust scaling factor.
                  cv = azrr - zr
                  cv = EXP(cv)
                  w(1) = w(1)*cv
                  w(2) = w(2)*cv
                END IF
                cv = con3
              ELSE
                !-- Compare exp(-i*PI/6)/2PI with Wronskian of ZAIRY(Z)
                !                 and ZAIRY(Z*exp(2i*PI/3)).
                cv = z*con1
                CALL ZAIRY(cv,0,kode,w(1),nz3,ierr)
                CALL ZAIRY(cv,1,kode,w(2),nz4,ierr)
                IF( kode==2 ) THEN
                  IF( t(it)>=pi3 ) THEN
                    !-------------------- Adjust scaling factor.
                    cv = 2._DP*zr
                    cv = EXP(-cv)
                    w(1) = w(1)*cv
                    w(2) = w(2)*cv
                  END IF
                END IF
                w(2) = w(2)*con1
                cv = con2
              END IF
              !-----------------------------------------------------------------------
              !     Error relative to maximum term
              !-----------------------------------------------------------------------
              av = ABS(cv)
              cw = y(1)*w(2)
              cy = y(2)*w(1)
              cy = cw - cy - cv
              acw = ABS(cw)
              IF( .NOT. IEEE_IS_FINITE(acw) ) acw = ABS(cw/sqrt_huge)*sqrt_huge
              acy = ABS(y(2)*w(1))
              IF( .NOT. IEEE_IS_FINITE(acy) ) acy = ABS(y(2)*w(1)/sqrt_huge)*sqrt_huge
              av = MAX(acw,acy,av)
              acy = ABS(cy)
              IF( .NOT. IEEE_IS_FINITE(acy) ) acy = ABS(cy/sqrt_huge)*sqrt_huge
              er = acy/av
              IF( er>=ertol ) THEN
                IF( lflg==0 ) THEN
                  IF( Kprint>=2 ) THEN
                    WRITE (Lun,99005) ertol
                    99005 FORMAT (' CASES WHICH VIOLATE THE RELATIVE ERROR',&
                      ' TEST WITH ERTOL = ',D12.4/)
                    WRITE (Lun,99006)
                    99006 FORMAT (' INPUT TO ZAIRY AND ERROR')
                  END IF
                  IF( Kprint>=3 ) THEN
                    WRITE (Lun,99007)
                    99007 FORMAT (' COMPARISON VALUE AND WRONSKIAN')
                    WRITE (Lun,99008)
                    99008 FORMAT (' RESULTS FROM ZAIRY AND/OR ZBIRY')
                    WRITE (Lun,99009)
                    99009 FORMAT (' TEST CASE INDICES'/)
                  END IF
                END IF
                lflg = 1
                IF( Kprint>=2 ) THEN
                  WRITE (Lun,99010) z, er
                  99010 FORMAT (12X,'INPUT:    Z=',2D12.4,5X,'ERROR:   ER=',D12.4)
                END IF
                IF( Kprint>=3 ) THEN
                  WRITE (Lun,99011) cv, cy
                  99011 FORMAT (' COMPARISON VALUE:   CV=',2D12.4/8X,&
                    'WRONSKIAN:   CY=',2D12.4)
                  WRITE (Lun,99012) nz1, y(1), nz2, y(2)
                  99012 FORMAT (10X,'RESULTS:  NZ1=',I3,4X,'Y(1)=',2D12.4/20X,&
                    'NZ2=',I3,4X,'Y(2)=',2D12.4)
                  IF( icase==1 ) THEN
                    WRITE (Lun,99013) w(1), w(2)
                    99013 FORMAT (31X,'W(1)=',2D12.4/31X,'W(2)=',2D12.4)
                  ELSE
                    WRITE (Lun,99014) nz3, w(1), nz4, w(2)
                    99014 FORMAT (20X,'NZ3=',I3,4X,'W(1)=',2D12.4/20X,'NZ4=',I3,4X,&
                      'W(2)=',2D12.4)
                  END IF
                  WRITE (Lun,99015) it, ir, irset, icase
                  99015 FORMAT (13X,'CASE:   IT=',I3,4X,'IR=',I3,4X,'IRSET=',I3,4X,&
                    'ICASE=',I3,4X/)
                END IF
              END IF
            END DO
          END DO
        END DO
      END DO
    END DO
    IF( Kprint>=2 ) THEN
      IF( lflg==0 ) THEN
        WRITE (Lun,99016)
        99016 FORMAT (' QUICK CHECKS OK')
      ELSE
        WRITE (Lun,99017)
        99017 FORMAT (' ***',5X,'FAILURE(S) FOR ZAIRY IN THE Z PLANE')
      END IF
    END IF
    Ipass = 0
    IF( lflg==0 ) Ipass = 1
    IF( Ipass==1 .AND. Kprint>=2 ) THEN
      WRITE (Lun,99018)
      99018 FORMAT (/' ****** ZAIRY  PASSED ALL TESTS  ******'/)
    END IF
    IF( Ipass==0 .AND. Kprint>=1 ) THEN
      WRITE (Lun,99019)
      99019 FORMAT (/' ****** ZAIRY  FAILED SOME TESTS ******'/)
    END IF
  END SUBROUTINE ZQCAI
  !** ZQCBH
  SUBROUTINE ZQCBH(Lun,Kprint,Ipass)
    !> Quick check for SLATEC subroutine
    !            ZBESH
    !***
    ! **Library:**   SLATEC
    !***
    ! **Category:**  C10A4
    !***
    ! **Type:**      COMPLEX (CQCBH-C, ZQCBH-Z)
    !***
    ! **Keywords:**  QUICK CHECK, ZBESH
    !***
    ! **Author:**  Amos, Don, (SNL)
    !           Goudy, Sue, (SNL)
    !           Walton, Lee, (SNL)
    !***
    ! **Description:**
    !
    !- Usage:
    !
    !        INTEGER  LUN, KPRINT, IPASS
    !
    !        CALL ZQCBH (LUN, KPRINT, IPASS)
    !
    !- Arguments:
    !
    !     LUN    :IN  is the unit number to which output is to be written.
    !
    !     KPRINT :IN  controls the amount of output, as specified in the
    !                 SLATEC Guidelines.
    !
    !     IPASS  :OUT indicates whether the test passed or failed.
    !                 A value of one is good, indicating no failures.
    !
    !- Description:
    !
    !                 *** A DOUBLE PRECISION ROUTINE ***
    !
    !   ZQCBH is a quick check routine for the complex H Bessel functions
    !    generated by subroutine ZBESH.
    !
    !   ZQCBH generates sequences of H Bessel functions for kinds 1 and 2
    !    from CBESH and checks them against the Wronskian evaluation
    !    in the (Z,FNU) space.
    !
    !***
    ! **References:**  Abramowitz, M. and Stegun, I. A., Handbook
    !                 of Mathematical Functions, Dover Publications,
    !                 New York, 1964.
    !               Amos, D. E., A Subroutine Package for Bessel
    !                 Functions of a Complex Argument and Nonnegative
    !                 Order, SAND85-1018, May, 1985.
    !***
    ! **Routines called:**  ZBESH, ZUOIK, ZABS, ZDIV, I1MACH, D1MACH

    !* REVISION HISTORY  (YYMMDD)
    !   830501  DATE WRITTEN
    !   890831  Revised to meet new SLATEC standards
    USE service, ONLY : eps_dp, log10_radix_dp, min_exp_dp, max_exp_dp, huge_dp
    USE special_functions, ONLY : ZBESH, ZUOIK
    USE IEEE_ARITHMETIC, ONLY : IEEE_IS_FINITE
    !
    !*Internal Notes:
    !   Machine constants are defined by functions I1MACH and D1MACH.
    !
    !   The parameter MQC can have values 1 (the default) for a faster,
    !   less definitive test or 2 for a slower, more definitive test.
    !
    !**End
    !
    !  Set test complexity parameter.
    INTEGER, PARAMETER :: MQC = 1
    !  Declare arguments.
    !
    INTEGER :: Lun, Kprint, Ipass
    !
    !  Declare local variables.
    !
    COMPLEX(DP) :: cv, cw, cy, w(20), y(20), z, zn
    REAL(DP) :: aa, ab, acw, acy, aer(20), alim, atol, av, aw, ay, &
      az, ct, dig, elim, eps, er, ertol, film, fnu, fnul, fpi, hpi, pi, r, rfpi, &
      rl, rm, r1m4, r1m5, r2, slak, st, t(20), tol, ts, xnu(20)
    INTEGER :: i, icase, ierr, il, ir, irb, it, itl, k, kdo(20), keps(20), &
      kk, kode, k1, k2, lflg, mflg, n, nl, nu, nul, nz1, nz2, n1
    REAL(DP), PARAMETER :: sqrt_huge = SQRT( huge_dp )
    !
    !* FIRST EXECUTABLE STATEMENT  ZQCBH
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99001)
      99001 FORMAT (' QUICK CHECK ROUTINE FOR THE H BESSEL FUNCTIONS FROM ','ZBESH'/)
    END IF
    !-----------------------------------------------------------------------
    !     Set parameters related to machine constants.
    !     TOL is the approximate unit roundoff limited to 1.0D-18.
    !     ELIM is the approximate exponential over- and underflow limit.
    !     exp(-ELIM)<exp(-ALIM)=exp(-ELIM)/TOL    and
    !     exp(ELIM)>exp(ALIM)=exp(ELIM)*TOL       are intervals near
    !     underflow and overflow limits where scaled arithmetic is done.
    !     RL is the lower boundary of the asymptotic expansion for large Z.
    !     DIG = number of base 10 digits in TOL = 10**(-DIG).
    !     FNUL is the lower boundary of the asymptotic series for large FNU.
    !-----------------------------------------------------------------------
    r1m4 = eps_dp
    tol = MAX(r1m4,1.E-18_DP)
    atol = 100._DP*tol
    aa = -LOG10(r1m4)
    k1 = min_exp_dp
    k2 = max_exp_dp
    r1m5 = log10_radix_dp
    k = MIN(ABS(k1),ABS(k2))
    elim = 2.303_DP*(k*r1m5-3._DP)
    ab = aa*2.303_DP
    alim = elim + MAX(-ab,-41.45_DP)
    dig = MIN(aa,18._DP)
    fnul = 10._DP + 6._DP*(dig-3._DP)
    rl = 1.2_DP*dig + 3._DP
    slak = 3._DP + 4._DP*(-LOG10(tol)-7._DP)/11._DP
    slak = MAX(slak,3._DP)
    ertol = tol*10._DP**slak
    rm = 0.5_DP*(alim+elim)
    rm = MIN(rm,200._DP)
    rm = MAX(rm,rl+10._DP)
    r2 = MIN(fnul,rm)
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99002)
      99002 FORMAT (' PARAMETERS'/5X,'TOL ',8X,'ELIM',8X,'ALIM',8X,'RL  ',8X,'FNUL',&
        8X,'DIG')
      WRITE (Lun,99003) tol, elim, alim, rl, fnul, dig
      99003 FORMAT (6D12.4/)
    END IF
    !-----------------------------------------------------------------------
    !     Set other constants needed in the tests.
    !-----------------------------------------------------------------------
    fpi = ATAN(1._DP)
    hpi = fpi + fpi
    pi = hpi + hpi
    rfpi = 1._DP/fpi
    zn = CMPLX( 0._DP, -rfpi, DP )
    !-----------------------------------------------------------------------
    !     Generate angles for construction of complex Z to be used in tests.
    !-----------------------------------------------------------------------
    !     KDO(K), K = 1,IL  determines which of the IL angles in -PI to PI
    !     are used to compute values of Z.
    !       KDO(K) = 0  means that the index K will be used for one or two
    !                   values of Z, depending on the choice of KEPS(K)
    !              = 1  means that the index K and the corresponding angle
    !                   will be skipped
    !     KEPS(K), K = 1,IL determines which of the angles get incremented
    !     up and down to put values of Z in regions where different
    !     formulae are used.
    !       KEPS(K)  = 0  means that the angle will be used without change
    !                = 1  means that the angle will be incremented up and
    !                   down by EPS
    !     The angles to be used are stored in the T(I) array, I = 1,ITL.
    !-----------------------------------------------------------------------
    IF( MQC/=2 ) THEN
      nl = 2
      il = 5
      DO i = 1, il
        keps(i) = 0
        kdo(i) = 0
      END DO
      nul = 5
      xnu(1) = 0._DP
      xnu(2) = 1._DP
      xnu(3) = 2._DP
      xnu(4) = 0.5_DP*fnul
      xnu(5) = fnul + 1.1_DP
    ELSE
      nl = 4
      il = 13
      DO i = 1, il
        kdo(i) = 0
        keps(i) = 0
      END DO
      kdo(2) = 1
      kdo(6) = 1
      kdo(8) = 1
      kdo(12) = 1
      keps(3) = 1
      keps(4) = 1
      keps(5) = 1
      keps(9) = 1
      keps(10) = 1
      keps(11) = 1
      nul = 6
      xnu(1) = 0._DP
      xnu(2) = 0.6_DP
      xnu(3) = 1.3_DP
      xnu(4) = 2._DP
      xnu(5) = 0.5_DP*fnul
      xnu(6) = fnul + 1.1_DP
    END IF
    i = 2
    eps = 0.01_DP
    film = il - 1
    t(1) = -pi + eps
    DO k = 2, il
      IF( kdo(k)==0 ) THEN
        t(i) = pi*(-il+2*k-1)/film
        IF( keps(k)/=0 ) THEN
          ts = t(i)
          t(i) = ts - eps
          i = i + 1
          t(i) = ts + eps
        ELSE
          i = i + 1
        END IF
      END IF
    END DO
    itl = i - 1
    !-----------------------------------------------------------------------
    !     Test values of Z in -PI<arg(Z)<=PI.
    !-----------------------------------------------------------------------
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99004)
      99004 FORMAT (' CHECKS IN THE (Z,FNU) SPACE'/)
    END IF
    lflg = 0
    DO kode = 1, 2
      DO n = 1, nl
        n1 = n + 1
        DO nu = 1, nul
          fnu = xnu(nu)
          DO icase = 1, 3
            irb = MIN(icase,2)
            DO ir = irb, 3
              !-------------- switch (icase)
              SELECT CASE (icase)
                CASE (2)
                  r = (2._DP*(3-ir)+r2*(ir-1))/2._DP
                CASE (3)
                  IF( r2>=rm ) EXIT
                  r = (r2*(3-ir)+rm*(ir-1))/2._DP
                CASE DEFAULT
                  r = (eps*(3-ir)+2._DP*(ir-1))/2._DP
              END SELECT
              !-------------- end switch
              DO it = 1, itl
                ct = COS(t(it))
                st = SIN(t(it))
                IF( ABS(ct)<atol ) ct = 0._DP
                IF( ABS(st)<atol ) st = 0._DP
                z = r*CMPLX(ct,st,DP)
                IF( fnu>=2._DP ) THEN
                  !------------------ Check for possible overflow condition
                  cv = z*(0._DP,1._DP)
                  CALL ZUOIK(cv,fnu,kode,2,n1,w,nz2,tol,elim,alim)
                  !------------------ Overflow detected? - skip test for this case
                  IF( nz2==(-1) ) CYCLE
                  cv = -cv
                  CALL ZUOIK(cv,fnu,kode,2,n1,w,nz2,tol,elim,alim)
                  !------------------ Overflow detected? - skip test for this case
                  IF( nz2==(-1) ) CYCLE
                END IF
                !---------------- No overflow - calculate H1(Z,FNU) and H2(Z,FNU)
                CALL ZBESH(z,fnu,kode,1,n1,y,nz1,ierr)
                !---------------- Underflow? - skip test for this case
                IF( nz1==0 ) THEN
                  CALL ZBESH(z,fnu,kode,2,n1,w,nz2,ierr)
                  !---------------- Underflow? - skip test for this case
                  IF( nz2==0 ) THEN
                    !--------------------------------------------------------------
                    !  Compare ZN/Z with the Wronskian of H1(Z,FNU) and H2(Z,FNU).
                    !  ZN = -4i/PI
                    !--------------------------------------------------------------
                    cv = zn/z
                    mflg = 0
                    DO i = 1, n
                      !--------------------------------------------------------
                      !     Error relative to maximum term
                      !--------------------------------------------------------
                      aw = ABS(w(i+1))
                      IF( .NOT. IEEE_IS_FINITE(aw) ) aw = ABS(w(i+1)/sqrt_huge)*sqrt_huge
                      ay = ABS(y(i))
                      IF( .NOT. IEEE_IS_FINITE(ay) ) ay = ABS(y(i)/sqrt_huge)*sqrt_huge
                      az = LOG(aw) + LOG(ay)
                      az = ABS(az)
                      IF( az<=alim ) THEN
                        !-------------------- No scaling problem - do error analysis
                        av = ABS(cv)
                        cw = w(i)*y(i+1)
                        cy = w(i+1)*y(i)
                        cy = cw - cy - cv
                        acy = aw*ay
                        acw = ABS(w(i))*ABS(y(i+1))
                        IF( .NOT. IEEE_IS_FINITE(acw) ) &
                          acw = ABS(w(i)*y(i+1)/sqrt_huge)*sqrt_huge
                        av = MAX(acw,acy,av)
                        acy = ABS(cy)
                        IF( .NOT. IEEE_IS_FINITE(acy) ) acy = ABS(cy/sqrt_huge)*sqrt_huge
                        er = acy/av
                        aer(i) = er
                        IF( er>ertol ) mflg = 1
                      END IF
                    END DO
                    IF( mflg/=0 ) THEN
                      IF( lflg==0 ) THEN
                        IF( Kprint>=2 ) THEN
                          WRITE (Lun,99005) ertol
                          99005 FORMAT (' CASES WHICH VIOLATE THE RELATIVE ',&
                            'ERROR TEST WITH ERTOL = ',D12.4/)
                          WRITE (Lun,99006)
                          99006 FORMAT (' INPUT TO ZBESH   Z, FNU, KODE, N')
                        END IF
                        IF( Kprint>=3 ) THEN
                          WRITE (Lun,99007)
                          99007 FORMAT (' COMPARE -4i/(PI*Z) WITH WRONSKIAN OF',&
                            ' H1(Z,FNU) AND H2(Z,FNU)')
                          WRITE (Lun,99008)
                          99008 FORMAT (' RESULTS FROM ZBESH FOR FUNCTION H1'/&
                            '         AND FUNCTION H2')
                          WRITE (Lun,99009)
                          99009 FORMAT (' TEST CASE INDICES'/)
                        END IF
                      END IF
                      lflg = lflg + 1
                      IF( Kprint>=2 ) THEN
                        WRITE (Lun,99010) z, fnu, kode, n
                        99010 FORMAT ('   INPUT:    Z=',2D12.4,4X,'FNU=',D12.4,4X,&
                          'KODE=',I3,4X,'N=',I3)
                      END IF
                      IF( Kprint>=3 ) THEN
                        WRITE (Lun,99011) (aer(k),k=1,n)
                        99011 FORMAT ('   ERROR:   AER(K)=',4D12.4)
                        kk = MAX(nz1,nz2) + 1
                        kk = MIN(n,kk)
                        WRITE (Lun,99012) nz1, y(kk), nz2, w(kk)
                        99012 FORMAT (' RESULTS:  NZ1=',I3,4X,'Y(KK)=',2D12.4/11X,&
                          'NZ2=',I3,4X,'W(KK)=',2D12.4)
                        WRITE (Lun,99013) it, ir, icase
                        99013 FORMAT ('    CASE:   IT=',I3,4X,'IR=',I3,4X,'ICASE=',I3/)
                      END IF
                    END IF
                  END IF
                END IF
              END DO
            END DO
          END DO
        END DO
      END DO
    END DO
    IF( Kprint>=2 ) THEN
      IF( lflg==0 ) THEN
        WRITE (Lun,99014)
        99014 FORMAT (' QUICK CHECKS OK')
      ELSE
        WRITE (Lun,99015) lflg
        99015 FORMAT (' ***',I5,' FAILURE(S) FOR ZBESH IN THE (Z,FNU)',' PLANE')
      END IF
    END IF
    Ipass = 0
    IF( lflg==0 ) Ipass = 1
    IF( Ipass==1 .AND. Kprint>=2 ) THEN
      WRITE (Lun,99016)
      99016 FORMAT (/' ****** ZBESH  PASSED ALL TESTS  ******'/)
    END IF
    IF( Ipass==0 .AND. Kprint>=1 ) THEN
      WRITE (Lun,99017)
      99017 FORMAT (/' ****** ZBESH  FAILED SOME TESTS ******'/)
    END IF
  END SUBROUTINE ZQCBH
  !** ZQCBI
  SUBROUTINE ZQCBI(Lun,Kprint,Ipass)
    !> Quick check for SLATEC subroutine
    !            ZBESI
    !***
    ! **Library:**   SLATEC
    !***
    ! **Category:**  C10B4
    !***
    ! **Type:**      COMPLEX (CQCBI-C, ZQCBI-Z)
    !***
    ! **Keywords:**  QUICK CHECK, ZBESI
    !***
    ! **Author:**  Amos, Don, (SNL)
    !           Goudy, Sue, (SNL)
    !           Walton, Lee, (SNL)
    !***
    ! **Description:**
    !
    !- Usage:
    !
    !        INTEGER  LUN, KPRINT, IPASS
    !
    !        CALL ZQCBI (LUN, KPRINT, IPASS)
    !
    !- Arguments:
    !
    !     LUN    :IN  is the unit number to which output is to be written.
    !
    !     KPRINT :IN  controls the amount of output, as specified in the
    !                 SLATEC Guidelines.
    !
    !     IPASS  :OUT indicates whether the test passed or failed.
    !                 A value of one is good, indicating no failures.
    !
    !- Description:
    !
    !                 *** A DOUBLE PRECISION ROUTINE ***
    !
    !   ZQCBI is a quick check routine for the complex I Bessel function
    !    generated by subroutine ZBESI.
    !
    !   ZQCBI generates sequences crossing formula boundaries which
    !    are started by one formula and terminated in a region where
    !    another formula applies. The terminated value is checked by
    !    the formula appropriate to that region.
    !
    !***
    ! **References:**  Abramowitz, M. and Stegun, I. A., Handbook
    !                 of Mathematical Functions, Dover Publications,
    !                 New York, 1964.
    !               Amos, D. E., A Subroutine Package for Bessel
    !                 Functions of a Complex Argument and Nonnegative
    !                 Order, SAND85-1018, May, 1985.
    !***
    ! **Routines called:**  ZBESI, ZBESK, ZWRSK, ZABS, ZDIV, I1MACH, D1MACH

    !* REVISION HISTORY  (YYMMDD)
    !   830501  DATE WRITTEN
    !   890831  Revised to meet new SLATEC standards
    USE service, ONLY : eps_dp, log10_radix_dp, min_exp_dp, max_exp_dp
    USE special_functions, ONLY : ZBESI, ZBESK, ZWRSK
    !
    !*Internal Notes:
    !   Machine constants are defined by functions I1MACH and D1MACH.
    !
    !   The parameter MQC can have values 1 (the default) for a faster,
    !   less definitive test or 2 for a slower, more definitive test.
    !
    !**End
    !
    !  Set test complexity parameter.
    INTEGER, PARAMETER :: MQC = 1
    !  Declare arguments.
    !
    INTEGER :: Lun, Kprint, Ipass
    !
    !  Declare local variables.
    !
    COMPLEX(DP) :: ck(20), csgn, cw, cy, w(20), y(20), z, zn, zt
    REAL(DP) :: aa, ab, aer(20), alim, arg, atol, aw, carg, ct, dig, elim, eps, &
      er, ertol, film, fnu, fnul, gnu, hpi, pi, r, rl, rlt, rm, r1, r1m4, r1m5, &
      r2, sarg, slak, st, t(20), tol, ts, zscr, zzr
    INTEGER :: i, icase, ierr, il, inu, iprnt, ir, it, itl, k, kdo(20), &
      keps(20), kk, kode, k1, k2, lflg, mflg, n, nl, nzi, nzk, nz1, nz2, n1
    !
    !* FIRST EXECUTABLE STATEMENT  ZQCBI
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99001)
      99001 FORMAT (' QUICK CHECK ROUTINE FOR THE I BESSEL FUNCTION FROM ','ZBESI'/)
    END IF
    !-----------------------------------------------------------------------
    !     Set parameters related to machine constants.
    !     TOL is the approximate unit roundoff limited to 1.0D-18.
    !     ELIM is the approximate exponential over- and underflow limit.
    !     exp(-ELIM)<exp(-ALIM)=exp(-ELIM)/TOL    and
    !     exp(ELIM)>exp(ALIM)=exp(ELIM)*TOL       are intervals near
    !     underflow and overflow limits where scaled arithmetic is done.
    !     RL is the lower boundary of the asymptotic expansion for large Z.
    !     DIG = number of base 10 digits in TOL = 10**(-DIG).
    !     FNUL is the lower boundary of the asymptotic series for large FNU.
    !-----------------------------------------------------------------------
    r1m4 = eps_dp
    tol = MAX(r1m4,1.E-18_DP)
    atol = 100._DP*tol
    aa = -LOG10(r1m4)
    k1 = min_exp_dp
    k2 = max_exp_dp
    r1m5 = log10_radix_dp
    k = MIN(ABS(k1),ABS(k2))
    elim = 2.303_DP*(k*r1m5-3._DP)
    ab = aa*2.303_DP
    alim = elim + MAX(-ab,-41.45_DP)
    dig = MIN(aa,18._DP)
    fnul = 10._DP + 6._DP*(dig-3._DP)
    rl = 1.2_DP*dig + 3._DP
    slak = 3._DP + 4._DP*(-LOG10(tol)-7._DP)/11._DP
    slak = MAX(slak,3._DP)
    ertol = tol*10._DP**slak
    rm = 0.5_DP*(alim+elim)
    rm = MIN(rm,200._DP)
    rm = MAX(rm,rl+10._DP)
    r2 = MIN(rm,fnul)
    r1 = 2._DP*SQRT(fnul+1._DP)
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99002)
      99002 FORMAT (' PARAMETERS'/5X,'TOL ',8X,'ELIM',8X,'ALIM',8X,'RL  ',8X,&
        'FNUL',8X,'DIG')
      WRITE (Lun,99003) tol, elim, alim, rl, fnul, dig
      99003 FORMAT (1X,6D12.4/)
    END IF
    !-----------------------------------------------------------------------
    !     Set other constants needed in the tests.
    !-----------------------------------------------------------------------
    zzr = 1._DP/tol
    hpi = 2._DP*ATAN(1._DP)
    pi = hpi + hpi
    !-----------------------------------------------------------------------
    !     Generate angles for construction of complex Z to be used in tests.
    !-----------------------------------------------------------------------
    !     KDO(K), K = 1,IL  determines which of the IL angles in -PI to PI
    !     are used to compute values of Z.
    !       KDO(K) = 0  means that the index K will be used for one or two
    !                   values of Z, depending on the choice of KEPS(K)
    !              = 1  means that the index K and the corresponding angle
    !                   will be skipped
    !     KEPS(K), K = 1,IL determines which of the angles get incremented
    !     up and down to put values of Z in regions where different
    !     formulae are used.
    !       KEPS(K)  = 0  means that the angle will be used without change
    !                = 1  means that the angle will be incremented up and
    !                   down by EPS
    !     The angles to be used are stored in the T(I) array, I = 1,ITL.
    !-----------------------------------------------------------------------
    IF( MQC/=2 ) THEN
      nl = 2
      il = 5
      DO i = 1, il
        keps(i) = 0
        kdo(i) = 0
      END DO
    ELSE
      nl = 4
      il = 13
      DO i = 1, il
        kdo(i) = 0
        keps(i) = 0
      END DO
      kdo(2) = 1
      kdo(6) = 1
      kdo(8) = 1
      kdo(12) = 1
      keps(3) = 1
      keps(4) = 1
      keps(5) = 1
      keps(9) = 1
      keps(10) = 1
      keps(11) = 1
    END IF
    i = 2
    eps = 0.01_DP
    film = il - 1
    t(1) = -pi + eps
    DO k = 2, il
      IF( kdo(k)==0 ) THEN
        t(i) = pi*(-il+2*k-1)/film
        IF( keps(k)/=0 ) THEN
          ts = t(i)
          t(i) = ts - eps
          i = i + 1
          t(i) = ts + eps
        ELSE
          i = i + 1
        END IF
      END IF
    END DO
    itl = i - 1
    !-----------------------------------------------------------------------
    !     Test values of Z in -PI<arg(Z)<=PI near formula boundaries.
    !-----------------------------------------------------------------------
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99004)
      99004 FORMAT (' CHECKS ACROSS FORMULA BOUNDARIES')
    END IF
    lflg = 0
    DO icase = 1, 6
      DO kode = 1, 2
        DO n = 1, nl
          n1 = n + 2
          !-----------------------------------------------------------------------
          !     Set values for R = magnitude of Z and for FNU to test computation
          !     methods for the various regions of the (Z,FNU) plane.
          !-----------------------------------------------------------------------
          DO ir = 1, 3
            !------------ switch (icase)
            SELECT CASE (icase)
              CASE (2)
                r = (rl*(3-ir)+r2*(ir-1))/2._DP
                gnu = SQRT(r+r) - 0.2_DP - (n-1)
                fnu = MAX(0._DP,gnu)
              CASE (3)
                IF( r2>=rm ) GOTO 100
                r = (r2*(3-ir)+rm*(ir-1))/2._DP
                gnu = SQRT(r+r) - 0.2_DP - (n-1)
                fnu = MAX(0._DP,gnu)
              CASE (4)
                IF( r1>=rl ) GOTO 100
                r = (r1*(3-ir)+rl*(ir-1))/2._DP
                fnu = fnul - 0.2_DP - (n-1)
              CASE (5)
                r = (rl*(3-ir)+r2*(ir-1))/2._DP
                fnu = fnul - 0.2_DP - (n-1)
              CASE (6)
                IF( r2>=rm ) GOTO 100
                r = (r2*(3-ir)+rm*(ir-1))/2._DP
                fnu = fnul - 0.2_DP - (n-1)
              CASE DEFAULT
                r = (2._DP*(3-ir)+rl*(ir-1))/2._DP
                gnu = r*r/4._DP - 0.2_DP - (n-1)
                fnu = MAX(0._DP,gnu)
            END SELECT
            !------------ end switch
            DO it = 1, itl
              ct = COS(t(it))
              st = SIN(t(it))
              IF( ABS(ct)<atol ) ct = 0._DP
              IF( ABS(st)<atol ) st = 0._DP
              z = r*CMPLX(ct,st,DP)
              CALL ZBESI(z,fnu,kode,n1,y,nz1,ierr)
              IF( nz1==0 ) THEN
                !-----------------------------------------------------------------------
                !     Compare values from ZBESI with values from ZWRSK, an alternative
                !     method for calculating the complex Bessel I function.
                !-----------------------------------------------------------------------
                zn = z
                IF( REAL(z,DP)>=0._DP ) THEN
                  CALL ZWRSK(zn,fnu,kode,n,w,nz2,ck,tol,elim,alim)
                  IF( nz2/=0 ) CYCLE
                ELSE
                  zn = -z
                  inu = INT(fnu)
                  arg = (fnu-inu)*pi
                  IF( AIMAG(z)<0._DP ) arg = -arg
                  carg = COS(arg)
                  sarg = SIN(arg)
                  csgn = CMPLX(carg,sarg,DP)
                  IF( MOD(inu,2)==1 ) THEN
                    csgn = -csgn
                  END IF
                  CALL ZWRSK(zn,fnu,kode,n,w,nz2,ck,tol,elim,alim)
                  IF( nz2/=0 ) CYCLE
                  DO i = 1, n
                    w(i) = w(i)*csgn
                    csgn = -csgn
                  END DO
                END IF
                mflg = 0
                DO i = 1, n
                  ab = fnu + i - 1
                  aa = MAX(2._DP,ab)
                  zt = w(i)
                  IF( ABS(REAL(zt,DP))>1._DP .OR. ABS(AIMAG(zt))>1._DP ) THEN
                    zscr = tol
                  ELSE
                    zscr = zzr
                    !------------------ ZZR = 1._DP/TOL
                  END IF
                  cw = w(i)*zscr
                  cy = y(i)*zscr
                  er = ABS(cy-cw)
                  aw = ABS(cw)
                  IF( aw==0._DP ) THEN
                    er = ABS(y(i))
                  ELSEIF( REAL(z,DP)/=0._DP ) THEN
                    er = er/aw
                  ELSEIF( ABS(AIMAG(z))<aa ) THEN
                    er = er/aw
                  ELSE
                    er = ABS(y(i)-w(i))
                  END IF
                  aer(i) = er
                  IF( er>ertol ) mflg = 1
                END DO
                !-----------------------------------------------------------------------
                !     Write failure reports for KPRINT>=2 and KPRINT>=3
                !-----------------------------------------------------------------------
                IF( mflg/=0 ) THEN
                  IF( lflg==0 ) THEN
                    IF( Kprint>=2 ) THEN
                      WRITE (Lun,99005) ertol
                      99005 FORMAT (/' CASES WHICH UNDERFLOW OR VIOLATE THE ',&
                        'RELATIVE ERROR TEST'/' WITH ERTOL = ',D12.4/)
                      WRITE (Lun,99006)
                      99006 FORMAT (' INPUT TO ZBESI   Z, FNU, KODE, N')
                    END IF
                    IF( Kprint>=3 ) THEN
                      WRITE (Lun,99007)
                      99007 FORMAT (' ERROR TEST ON RESULTS FROM ZBESI AND ',&
                        'ZWRSK   AER(K)')
                      WRITE (Lun,99008)
                      99008 FORMAT (' RESULTS FROM ZBESI   NZ1, Y(KK)'/,&
                        ' RESULTS FROM ZWRSK   NZ2, W(KK)')
                      WRITE (Lun,99009)
                      99009 FORMAT (' TEST CASE INDICES   IT, IR, ICASE'/)
                    END IF
                  END IF
                  lflg = lflg + 1
                  IF( Kprint>=2 ) THEN
                    WRITE (Lun,99010) z, fnu, kode, n
                    99010 FORMAT ('   INPUT:    Z=',2D12.4,4X,'FNU=',D12.4,4X,&
                      'KODE=',I3,4X,'N=',I3)
                  END IF
                  IF( Kprint>=3 ) THEN
                    WRITE (Lun,99011) (aer(k),k=1,n)
                    99011 FORMAT ('   ERROR:  AER(K)=',4D12.4)
                    kk = MAX(nz1,nz2) + 1
                    kk = MIN(n,kk)
                    WRITE (Lun,99012) nz1, y(kk), nz2, w(kk)
                    99012 FORMAT (' RESULTS:  NZ1=',I3,4X,'Y(KK)=',2D12.4,/11X,&
                      'NZ2=',I3,4X,'W(KK)=',2D12.4)
                    WRITE (Lun,99013) it, ir, icase
                    99013 FORMAT ('    CASE:   IT=',I3,4X,'IR=',I3,4X,'ICASE=',I3/)
                  END IF
                END IF
              END IF
            END DO
          END DO
        END DO
      END DO
      100 CONTINUE
    END DO
    IF( Kprint>=2 ) THEN
      IF( lflg==0 ) THEN
        WRITE (Lun,99019)
      ELSE
        WRITE (Lun,99014) lflg
        99014 FORMAT (' ***',I5,' FAILURE(S) FOR ZBESI CHECKS NEAR FORMULA ',&
          'BOUNDARIES')
      END IF
    END IF
    !
    !
    iprnt = 0
    IF( MQC/=1 ) THEN
      !-----------------------------------------------------------------------
      !     Checks near underflow limits on series(I=1) and uniform
      !     asymptotic expansion(I=2)
      !     Compare 1/Z with I(Z,FNU)*K(Z,FNU+1) + I(Z,FNU+1)*K(Z,FNU) and
      !     report cases for which the relative error is greater than ERTOL.
      !-----------------------------------------------------------------------
      IF( Kprint>=2 ) THEN
        WRITE (Lun,99015)
        99015 FORMAT (/' CHECKS NEAR UNDERFLOW AND OVERFLOW LIMITS'/)
      END IF
      z = CMPLX(1.4_DP,1.4_DP,DP)
      kode = 1
      n = 20
      DO i = 1, 2
        fnu = 10.2_DP
        DO
          !-----------------------------------------------------------------------
          !       Adjust FNU by repeating until 0<NZI<10
          !-----------------------------------------------------------------------
          CALL ZBESI(z,fnu,kode,n,y,nzi,ierr)
          IF( nzi==0 ) THEN
            fnu = fnu + 5._DP
            CYCLE
          ELSEIF( nzi>=10 ) THEN
            fnu = fnu - 1._DP
            CYCLE
          END IF
          !------ End repeat
          CALL ZBESK(z,fnu,kode,2,w,nzk,ierr)
          zt = (1._DP,0._DP)/z
          cy = w(1)*y(2)
          cw = w(2)*y(1)
          cw = cw + cy - zt
          er = ABS(cw)/ABS(zt)
          !-----------------------------------------------------------------------
          !     Write failure reports for KPRINT>=2 and KPRINT>=3
          !-----------------------------------------------------------------------
          IF( er>=ertol ) THEN
            IF( iprnt==0 ) THEN
              IF( Kprint>=2 ) WRITE (Lun,99020)
              IF( Kprint>=3 ) WRITE (Lun,99021)
            END IF
            iprnt = 1
            IF( Kprint>=2 ) WRITE (Lun,99022) z, fnu, kode, n
            IF( Kprint>=3 ) THEN
              WRITE (Lun,99023) zt, cw+cy
              WRITE (Lun,99024) er
            END IF
          END IF
          rlt = rl + rl
          z = CMPLX(rlt,0._DP,DP)
          EXIT
        END DO
      END DO
      !-----------------------------------------------------------------------
      !     Check near overflow limits
      !     Compare 1/Z with I(Z,FNU)*K(Z,FNU+1) + I(Z,FNU+1)*K(Z,FNU) and
      !     report cases for which the relative error is greater than ERTOL.
      !-----------------------------------------------------------------------
      z = CMPLX(elim,0._DP,DP)
      fnu = 0._DP
      DO
        !-----------------------------------------------------------------------
        !     Adjust FNU by repeating until NZK<10
        !     N = 20 set before DO 280 loop
        !-----------------------------------------------------------------------
        CALL ZBESK(z,fnu,kode,n,y,nzk,ierr)
        IF( nzk>=10 ) THEN
          IF( nzk==n ) THEN
            fnu = fnu + 3._DP
          ELSE
            fnu = fnu + 2._DP
          END IF
          CYCLE
        END IF
        !---- End repeat
        gnu = fnu + (n-2)
        CALL ZBESI(z,gnu,kode,2,w,nzi,ierr)
        zt = (1._DP,0._DP)/z
        cy = y(n-1)*w(2)
        cw = y(n)*w(1)
        cw = cw + cy -zt
        er = ABS(cw)/ABS(zt)
        IF( er>=ertol ) THEN
          IF( iprnt==0 ) THEN
            IF( Kprint>=2 ) WRITE (Lun,99020)
            IF( Kprint>=3 ) WRITE (Lun,99021)
          END IF
          iprnt = 1
          IF( Kprint>=2 ) WRITE (Lun,99022) z, fnu, kode, n
          IF( Kprint>=3 ) THEN
            WRITE (Lun,99023) zt, cw+cy
            WRITE (Lun,99024) er
          END IF
        END IF
        IF( Kprint>=2 ) THEN
          IF( iprnt==0 ) THEN
            WRITE (Lun,99019)
            ! 99986 FORMAT (' QUICK CHECKS OK')
          ELSE
            WRITE (Lun,99016)
            99016 FORMAT (' ***',5X,'FAILURE(S) FOR ZBESI NEAR UNDERFLOW AND ',&
              'OVERFLOW LIMITS')
          END IF
        END IF
        EXIT
      END DO
    END IF
    Ipass = 0
    IF( iprnt==0 .AND. lflg==0 ) Ipass = 1
    IF( Ipass==1 .AND. Kprint>=2 ) THEN
      WRITE (Lun,99017)
      99017 FORMAT (/' ****** ZBESI  PASSED ALL TESTS  ******'/)
    END IF
    IF( Ipass==0 .AND. Kprint>=1 ) THEN
      WRITE (Lun,99018)
      99018 FORMAT (/' ****** ZBESI  FAILED SOME TESTS ******'/)
    END IF
    99019 FORMAT (' QUICK CHECKS OK')
    99020 FORMAT (' INPUT TO ZBESI   Z, FNU, KODE, N')
    99021 FORMAT (' COMPARE 1/Z WITH WRONSKIAN(ZBESI(Z,FNU),','ZBESK(Z,FNU))'/)
    99022 FORMAT (' INPUT: Z=',2D12.4,3X,'FNU=',D12.4,3X,'KODE=',I3,3X,'N=',I3)
    99023 FORMAT (' RESULTS:',15X,'1/Z=',2D12.4/10X,'WRON(ZBESI,ZBESK)=',2D12.4)
    99024 FORMAT (' RELATIVE ERROR:',9X,'ER=',D12.4/)
  END SUBROUTINE ZQCBI
  !** ZQCBJ
  SUBROUTINE ZQCBJ(Lun,Kprint,Ipass)
    !> Quick check for SLATEC subroutine
    !            ZBESJ
    !***
    ! **Library:**   SLATEC
    !***
    ! **Category:**  C10A4
    !***
    ! **Type:**      COMPLEX (CQCBJ-C, ZQCBJ-Z)
    !***
    ! **Keywords:**  QUICK CHECK, ZBESJ
    !***
    ! **Author:**  Amos, Don, (SNL)
    !           Goudy, Sue, (SNL)
    !           Walton, Lee, (SNL)
    !***
    ! **Description:**
    !
    !- Usage:
    !
    !        INTEGER  LUN, KPRINT, IPASS
    !
    !        CALL ZQCBJ (LUN, KPRINT, IPASS)
    !
    !- Arguments:
    !
    !     LUN    :IN  is the unit number to which output is to be written.
    !
    !     KPRINT :IN  controls the amount of output, as specified in the
    !                 SLATEC Guidelines.
    !
    !     IPASS  :OUT indicates whether the test passed or failed.
    !                 A value of one is good, indicating no failures.
    !
    !- Description:
    !
    !                 *** A DOUBLE PRECISION ROUTINE ***
    !
    !   ZQCBJ is a quick check routine for the complex J Bessel function
    !    generated by subroutine ZBESJ.
    !
    !   ZQCBJ generates sequences of J Bessel functions from ZBESJ
    !    and checks them against the evaluation from the formula
    !
    !            J(FNU,Z) = 0.5*( H(1,FNU,Z) + H(2,FNU,Z) )
    !
    !    where -PI<arg(Z)<=PI for abs(Z)>=FNU.
    !
    !   For abs(Z)<FNU, the first N members of a sequence of length
    !    N+16 are checked against a corresponding N member sequence where
    !    both sequences are generated by ZBESJ beginning at order FNU.
    !
    !***
    ! **References:**  Abramowitz, M. and Stegun, I. A., Handbook
    !                 of Mathematical Functions, Dover Publications,
    !                 New York, 1964.
    !               Amos, D. E., A Subroutine Package for Bessel
    !                 Functions of a Complex Argument and Nonnegative
    !                 Order, SAND85-1018, May, 1985.
    !***
    ! **Routines called:**  ZBESH, ZBESJ, ZABS, ZEXP, I1MACH, D1MACH

    !* REVISION HISTORY  (YYMMDD)
    !   830501  DATE WRITTEN
    !   890831  Revised to meet new SLATEC standards
    !   930122  Added ZEXP to EXTERNAL statement.  (RWC)
    USE service, ONLY : eps_dp, log10_radix_dp, min_exp_dp, max_exp_dp
    USE special_functions, ONLY : ZBESH, ZBESJ
    !
    !*Internal Notes:
    !   Machine constants are defined by functions I1MACH and D1MACH.
    !
    !   The parameter MQC can have values 1 (the default) for a faster,
    !   less definitive test or 2 for a slower, more definitive test.
    !
    !**End
    !
    !  Set test complexity parameter.
    INTEGER, PARAMETER :: MQC = 1
    !  Declare arguments.
    !
    INTEGER :: Lun, Kprint, Ipass
    !
    !  Declare local variables.
    !
    COMPLEX(DP) :: coe1, coe2, cw, half, v(20), w(20), y(20), z, a
    REAL(DP) :: aa, ab, aer(20), alim, atol, av, cc, ct, dd, dig, elim, eps, er, &
      ertol, film, fnu, fnul, gnu, hpi, pi, r, rl, rm, r1m4, r1m5, r2, slak, st, &
      t(20), tol, ts, xnu(20)
    INTEGER :: i, icase, ierr, il, ir, irb, it, itl, k, kdo(20), keps(20), &
      kk, kode, k1, k2, lflg, m, mflg, n, nl, nu, nul, nz, nz1, nz2
    !
    !* FIRST EXECUTABLE STATEMENT  ZQCBJ
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99001)
      99001 FORMAT (' QUICK CHECK ROUTINE FOR THE J BESSEL FUNCTION FROM ','ZBESJ'/)
    END IF
    !-----------------------------------------------------------------------
    !     Set parameters related to machine constants.
    !     TOL is the approximate unit roundoff limited to 1.0D-18.
    !     ELIM is the approximate exponential over- and underflow limit.
    !     exp(-ELIM)<exp(-ALIM)=exp(-ELIM)/TOL    and
    !     exp(ELIM)>exp(ALIM)=exp(ELIM)*TOL       are intervals near
    !     underflow and overflow limits where scaled arithmetic is done.
    !     RL is the lower boundary of the asymptotic expansion for large Z.
    !     DIG = number of base 10 digits in TOL = 10**(-DIG).
    !     FNUL is the lower boundary of the asymptotic series for large FNU.
    !-----------------------------------------------------------------------
    r1m4 = eps_dp
    tol = MAX(r1m4,1.E-18_DP)
    atol = 100._DP*tol
    aa = -LOG10(r1m4)
    k1 = min_exp_dp
    k2 = max_exp_dp
    r1m5 = log10_radix_dp
    k = MIN(ABS(k1),ABS(k2))
    elim = 2.303_DP*(k*r1m5-3._DP)
    ab = aa*2.303_DP
    alim = elim + MAX(-ab,-41.45_DP)
    dig = MIN(aa,18._DP)
    fnul = 10._DP + 6._DP*(dig-3._DP)
    rl = 1.2_DP*dig + 3._DP
    slak = 3._DP + 4._DP*(-LOG10(tol)-7._DP)/11._DP
    slak = MAX(slak,3._DP)
    ertol = tol*10._DP**slak
    rm = 0.5_DP*(alim+elim)
    rm = MIN(rm,200._DP)
    rm = MAX(rm,rl+10._DP)
    r2 = MIN(rm,fnul)
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99002)
      99002 FORMAT (' PARAMETERS'/5X,'TOL ',8X,'ELIM',8X,'ALIM',8X,'RL  ',8X,'FNUL',&
        8X,'DIG')
      WRITE (Lun,99003) tol, elim, alim, rl, fnul, dig
      99003 FORMAT (1X,6D12.4/)
    END IF
    !-----------------------------------------------------------------------
    !     Set other constants needed in the tests.
    !-----------------------------------------------------------------------
    half = CMPLX(0.5_DP,0._DP,DP)
    hpi = 2._DP*ATAN(1._DP)
    pi = hpi + hpi
    !-----------------------------------------------------------------------
    !     Generate angles for construction of complex Z to be used in tests.
    !-----------------------------------------------------------------------
    !     KDO(K), K = 1,IL  determines which of the IL angles in -PI to PI
    !     are used to compute values of Z.
    !       KDO(K) = 0  means that the index K will be used for one or two
    !                   values of Z, depending on the choice of KEPS(K)
    !              = 1  means that the index K and the corresponding angle
    !                   will be skipped
    !     KEPS(K), K = 1,IL determines which of the angles get incremented
    !     up and down to put values of Z in regions where different
    !     formulae are used.
    !       KEPS(K)  = 0  means that the angle will be used without change
    !                = 1  means that the angle will be incremented up and
    !                   down by EPS
    !     The angles to be used are stored in the T(I) array, I = 1,ITL.
    !-----------------------------------------------------------------------
    IF( MQC/=2 ) THEN
      nl = 2
      il = 5
      DO i = 1, il
        keps(i) = 0
        kdo(i) = 0
      END DO
      nul = 5
      xnu(1) = 0._DP
      xnu(2) = 1._DP
      xnu(3) = 2._DP
      xnu(4) = 0.5_DP*fnul
      xnu(5) = fnul + 1.1_DP
    ELSE
      nl = 4
      il = 13
      DO i = 1, il
        kdo(i) = 0
        keps(i) = 0
      END DO
      kdo(2) = 1
      kdo(6) = 1
      kdo(8) = 1
      kdo(12) = 1
      keps(3) = 1
      keps(4) = 1
      keps(5) = 1
      keps(9) = 1
      keps(10) = 1
      keps(11) = 1
      nul = 6
      xnu(1) = 0._DP
      xnu(2) = 0.6_DP
      xnu(3) = 1.3_DP
      xnu(4) = 2._DP
      xnu(5) = 0.5_DP*fnul
      xnu(6) = fnul + 1.1_DP
    END IF
    i = 2
    eps = 0.01_DP
    film = il - 1
    t(1) = -pi + eps
    DO k = 2, il
      IF( kdo(k)==0 ) THEN
        t(i) = pi*(-il+2*k-1)/film
        IF( keps(k)==0 ) THEN
          ts = t(i)
          t(i) = ts - eps
          i = i + 1
          t(i) = ts + eps
        ELSE
          i = i + 1
        END IF
      END IF
    END DO
    itl = i - 1
    !-----------------------------------------------------------------------
    !     Test values of Z in -PI<arg(Z)<=PI.
    !-----------------------------------------------------------------------
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99004)
      99004 FORMAT (' CHECKS IN THE (Z,FNU) SPACE'/)
    END IF
    lflg = 0
    DO kode = 1, 2
      DO n = 1, nl
        DO nu = 1, nul
          fnu = xnu(nu)
          DO icase = 1, 3
            irb = MIN(2,icase)
            DO ir = irb, 4
              !-------------- switch (icase)
              SELECT CASE (icase)
                CASE (2)
                  r = (2._DP*(4-ir)+r2*(ir-1))/3._DP
                CASE (3)
                  IF( r2>=rm ) EXIT
                  r = (r2*(4-ir)+rm*(ir-1))/3._DP
                CASE DEFAULT
                  r = (eps*(4-ir)+2._DP*(ir-1))/3._DP
              END SELECT
              !-------------- end switch
              gnu = fnu + (n-1)
              DO it = 1, itl
                ct = COS(t(it))
                st = SIN(t(it))
                IF( ABS(ct)<atol ) ct = 0._DP
                IF( ABS(st)<atol ) st = 0._DP
                z = r*CMPLX(ct,st,DP)
                IF( r>=gnu ) THEN
                  !------------------ Cases for abs(Z)>=FNU+N-1
                  CALL ZBESJ(z,fnu,kode,n,v,nz,ierr)
                  !------------------ Underflow - skip test for this case.
                  IF( nz/=0 ) CYCLE
                  CALL ZBESH(z,fnu,kode,1,n,w,nz1,ierr)
                  CALL ZBESH(z,fnu,kode,2,n,y,nz2,ierr)
                  IF( kode==2 ) THEN
                    !-------------------- Adjust scaling of H functions.
                    cc = -AIMAG(z) - ABS(AIMAG(z))
                    IF( cc>(-alim) ) THEN
                      cw = CMPLX( cc, REAL(z,DP), DP )
                      coe1 = EXP(cw)
                    ELSE
                      coe1 = (0._DP,0._DP)
                    END IF
                    dd = AIMAG(z) - ABS(AIMAG(z))
                    IF( dd>(-alim) ) THEN
                      cw = CMPLX(dd,-REAL(z,DP),DP)
                      coe2 = EXP(cw)
                    ELSE
                      coe2 = (0._DP,0._DP)
                    END IF
                    DO kk = 1, n
                      y(kk) = y(kk)*coe2
                      w(kk) = w(kk)*coe1
                    END DO
                  END IF
                ELSE
                  !------------------ Cases for abs(Z)<FNU+N-1
                  m = n + 16
                  CALL ZBESJ(z,fnu,kode,m,v,nz,ierr)
                  !------------------ Underflow at end of sequence - skip test
                  IF( nz>10 ) CYCLE
                  CALL ZBESJ(z,fnu,kode,n,w,nz,ierr)
                  DO kk = 1, n
                    y(kk) = w(kk)
                  END DO
                END IF
                !-----------------------------------------------------------------------
                !     If abs(Z)>=FNU+N-1 then the error test compares J(Z<FNU) with
                !     0.5*(H1(Z,FNU) + H2(Z,FNU)).
                !     If abs(Z)<FNU+N-1 then the error test ensures that calculations
                !     begun in one region of the (Z,FNU) plane and carried into another
                !     region do not diverge from calculations carried out entirely in
                !     one region.  This is an internal consistency check.
                !-----------------------------------------------------------------------
                mflg = 0
                DO i = 1, n
                  ab = fnu + i - 1
                  aa = MAX(2._DP,ab)
                  cw = (w(i)+y(i))*half
                  av = ABS(v(i))
                  a = cw - v(i)
                  er = ABS(a)
                  IF( av/=0._DP ) THEN
                    IF( AIMAG(z)==0._DP ) THEN
                      IF( ABS(REAL(z))<aa ) er = er/av
                    ELSE
                      er = er/av
                    END IF
                  END IF
                  aer(i) = er
                  IF( er>ertol ) mflg = 1
                END DO
                IF( mflg/=0 ) THEN
                  IF( lflg==0 ) THEN
                    IF( Kprint>=2 ) THEN
                      WRITE (Lun,99005) ertol
                      99005 FORMAT (' CASES WHICH VIOLATE THE RELATIVE ',&
                        'ERROR TEST WITH ERTOL=',D12.4/)
                      WRITE (Lun,99006)
                      99006 FORMAT (' INPUT TO ZBESJ   Z, FNU, KODE, N')
                    END IF
                    IF( Kprint>=3 ) THEN
                      IF( r>=gnu ) THEN
                        WRITE (Lun,99007)
                        99007 FORMAT (' COMPARE WITH AVERAGE OF H1 AND H2 ',&
                          'FUNCTIONS FOR THE SAME INPUT')
                        WRITE (Lun,99008)
                        99008 FORMAT (' RESULTS FROM ZBESJ    NZ, V(KK)')
                        WRITE (Lun,99009)
                        99009 FORMAT (' RESULTS FROM ZBESH   NZ1, W(KK)')
                        WRITE (Lun,99010)
                        99010 FORMAT (' RESULTS FROM ZBESH   NZ2, Y(KK)')
                      ELSE
                        WRITE (Lun,99011)
                        99011 FORMAT (' RESULTS FROM ZBESJ    NZ, W(KK)')
                      END IF
                      WRITE (Lun,99012)
                      99012 FORMAT (' TEST CASE INDICES   IR, IT, ICASE'/)
                    END IF
                  END IF
                  lflg = lflg + 1
                  IF( Kprint>=2 ) THEN
                    WRITE (Lun,99013) z, fnu, kode, n
                    99013 FORMAT ('   INPUT:   Z=',2D12.4,3X,'FNU=',D12.4,3X,&
                      'KODE=',I3,3X,'N=',I3)
                  END IF
                  IF( Kprint>=3 ) THEN
                    WRITE (Lun,99014) (aer(k),k=1,n)
                    99014 FORMAT ('   ERROR:   AER(K)=',4D12.4)
                    IF( r>=gnu ) THEN
                      kk = MAX(nz1,nz2) + 1
                      kk = MIN(n,kk)
                      WRITE (Lun,99015) nz, v(kk)
                      99015 FORMAT (' RESULTS:   NZ=',I3,3X,'V(KK)=',2D12.4)
                      WRITE (Lun,99016) nz1, w(kk)
                      99016 FORMAT (' RESULTS:  NZ1=',I3,3X,'W(KK)=',2D12.4)
                      WRITE (Lun,99017) nz2, y(kk)
                      99017 FORMAT (' RESULTS:  NZ2=',I3,3X,'Y(KK)=',2D12.4)
                    ELSE
                      kk = n - nz
                      WRITE (Lun,99018) nz, w(kk)
                      99018 FORMAT (' RESULTS:   NZ=',I3,3X,'W(KK)=',2D12.4)
                    END IF
                    WRITE (Lun,99019) ir, it, icase
                    99019 FORMAT ('    CASE:  IR=',I3,3X,'IT=',I3,3X,'ICASE=',I3/)
                  END IF
                END IF
              END DO
            END DO
          END DO
        END DO
      END DO
    END DO
    IF( Kprint>=2 ) THEN
      IF( lflg==0 ) THEN
        WRITE (Lun,99020)
        99020 FORMAT (' QUICK CHECKS OK')
      ELSE
        WRITE (Lun,99021) lflg
        99021 FORMAT (' ***',I5,' FAILURE(S) FOR ZBESJ IN THE (Z,FNU)',' PLANE')
      END IF
    END IF
    Ipass = 0
    IF( lflg==0 ) Ipass = 1
    IF( Ipass==1 .AND. Kprint>=2 ) THEN
      WRITE (Lun,99022)
      99022 FORMAT (/' ****** ZBESJ  PASSED ALL TESTS  ******'/)
    END IF
    IF( Ipass==0 .AND. Kprint>=1 ) THEN
      WRITE (Lun,99023)
      99023 FORMAT (/' ****** ZBESJ  FAILED SOME TESTS ******'/)
    END IF
  END SUBROUTINE ZQCBJ
  !** ZQCBK
  SUBROUTINE ZQCBK(Lun,Kprint,Ipass)
    !> Quick check for SLATEC subroutine
    !            ZBESK
    !***
    ! **Library:**   SLATEC
    !***
    ! **Category:**  C10B4
    !***
    ! **Type:**      COMPLEX (CQCBK-C, ZQCBK-Z)
    !***
    ! **Keywords:**  QUICK CHECK, ZBESK
    !***
    ! **Author:**  Amos, Don, (SNL)
    !           Goudy, Sue, (SNL)
    !           Walton, Lee, (SNL)
    !***
    ! **Description:**
    !
    !- Usage:
    !
    !        INTEGER  LUN, KPRINT, IPASS
    !
    !        CALL ZQCBK (LUN, KPRINT, IPASS)
    !
    !- Arguments:
    !
    !     LUN    :IN  is the unit number to which output is to be written.
    !
    !     KPRINT :IN  controls the amount of output, as specified in the
    !                 SLATEC Guidelines.
    !
    !     IPASS  :OUT indicates whether the test passed or failed.
    !                 A value of one is good, indicating no failures.
    !
    !- Description:
    !
    !                  *** A DOUBLE PRECISION ROUTINE ***
    !
    !   ZQCBK is a quick check routine for the complex K Bessel function
    !    generated by subroutine ZBESK.
    !
    !   ZQCBK generates sequences of I and K Bessel functions from
    !    ZBESI and ZBESK and checks them against the Wronskian evaluation
    !    in the (Z,FNU) space.
    !
    !***
    ! **References:**  Abramowitz, M. and Stegun, I. A., Handbook
    !                 of Mathematical Functions, Dover Publications,
    !                 New York, 1964.
    !               Amos, D. E., A Subroutine Package for Bessel
    !                 Functions of a Complex Argument and Nonnegative
    !                 Order, SAND85-1018, May, 1985.
    !***
    ! **Routines called:**  ZBESI, ZBESK, ZABS, ZDIV, ZEXP, I1MACH, D1MACH

    !* REVISION HISTORY  (YYMMDD)
    !   830501  DATE WRITTEN
    !   890831  Revised to meet new SLATEC standard
    !   930122  Added ZEXP to EXTERNAL Statement.  (RWC)
    USE service, ONLY : eps_dp, log10_radix_dp, min_exp_dp, max_exp_dp
    USE special_functions, ONLY : ZBESI, ZBESK
    !
    !*Internal Notes:
    !   Machine constants are defined by functions I1MACH and D1MACH.
    !
    !   The parameter MQC can have values 1 (the default) for a faster,
    !   less definitive test or 2 for a slower, more definitive test.
    !
    !**End
    !
    !  Set test complexity parameter.
    INTEGER, PARAMETER :: MQC = 1
    !  Declare arguments.
    !
    INTEGER :: Lun, Kprint, Ipass
    !
    !  Declare local variables.
    !
    COMPLEX(DP) :: csgn, cv, cw, cy, w(20), y(20), z, zn, stt
    REAL(DP) :: aa, ab, aer(20), alim, arg, atol, axx, ct, dig, elim, eps, er, &
      ertol, ffnu, film, fnu, fnul, hpi, pi, r, rl, rm, r1m4, r1m5, r2, slak, &
      st, t(20), tol, ts, xnu(20)
    INTEGER :: i, icase, ierr, ifnu, il, ir, irb, it, itl, k, kdo(20), &
      keps(20), kk, kode, k1, k2, lflg, mflg, n, nl, nu, nul, nz1, nz2, n1
    !
    !* FIRST EXECUTABLE STATEMENT  ZQCBK
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99001)
      99001 FORMAT (' QUICK CHECK ROUTINE FOR THE K BESSEL FUNCTION FROM ','ZBESK'/)
    END IF
    !-----------------------------------------------------------------------
    !     Set parameters related to machine constants.
    !     TOL is the approximate unit roundoff limited to 1.0D-18.
    !     ELIM is the approximate exponential over- and underflow limit.
    !     exp(-ELIM)<exp(-ALIM)=exp(-ELIM)/TOL    and
    !     exp(ELIM)>exp(ALIM)=exp(ELIM)*TOL       are intervals near
    !     underflow and overflow limits where scaled arithmetic is done.
    !     RL is the lower boundary of the asymptotic expansion for large Z.
    !     DIG = number of base 10 digits in TOL = 10**(-DIG).
    !     FNUL is the lower boundary of the asymptotic series for large FNU.
    !-----------------------------------------------------------------------
    r1m4 = eps_dp
    tol = MAX(r1m4,1.E-18_DP)
    atol = 100._DP*tol
    aa = -LOG10(r1m4)
    k1 = min_exp_dp
    k2 = max_exp_dp
    r1m5 = log10_radix_dp
    k = MIN(ABS(k1),ABS(k2))
    elim = 2.303_DP*(k*r1m5-3._DP)
    ab = aa*2.303_DP
    alim = elim + MAX(-ab,-41.45_DP)
    dig = MIN(aa,18._DP)
    fnul = 10._DP + 6._DP*(dig-3._DP)
    rl = 1.2_DP*dig + 3._DP
    slak = 3._DP + 4._DP*(-LOG10(tol)-7._DP)/11._DP
    slak = MAX(slak,3._DP)
    ertol = tol*10._DP**slak
    rm = 0.5_DP*(alim+elim)
    rm = MIN(rm,200._DP)
    rm = MAX(rm,rl+10._DP)
    r2 = MIN(rm,fnul)
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99002)
      99002 FORMAT (' PARAMETERS'/5X,'TOL ',8X,'ELIM',8X,'ALIM',8X,'RL  ',8X,'FNUL',&
        8X,'DIG')
      WRITE (Lun,99003) tol, elim, alim, rl, fnul, dig
      99003 FORMAT (1X,6D12.4/)
    END IF
    !-----------------------------------------------------------------------
    !     Set other constants needed in the tests.
    !-----------------------------------------------------------------------
    hpi = 2._DP*ATAN(1._DP)
    pi = hpi + hpi
    !-----------------------------------------------------------------------
    !     Generate angles for construction of complex Z to be used in tests.
    !-----------------------------------------------------------------------
    !     KDO(K), K = 1,IL  determines which of the IL angles in -PI to PI
    !     are used to compute values of Z.
    !       KDO(K) = 0  means that the index K will be used for one or two
    !                   values of Z, depending on the choice of KEPS(K)
    !              = 1  means that the index K and the corresponding angle
    !                   will be skipped
    !     KEPS(K), K = 1,IL determines which of the angles get incremented
    !     up and down to put values of Z in regions where different
    !     formulae are used.
    !       KEPS(K)  = 0  means that the angle will be used without change
    !                = 1  means that the angle will be incremented up and
    !                   down by EPS
    !     The angles to be used are stored in the T(I) array, I = 1,ITL.
    !-----------------------------------------------------------------------
    IF( MQC/=2 ) THEN
      nl = 2
      il = 5
      DO i = 1, il
        keps(i) = 0
        kdo(i) = 0
      END DO
      nul = 5
      xnu(1) = 0._DP
      xnu(2) = 1._DP
      xnu(3) = 2._DP
      xnu(4) = 0.5_DP*fnul
      xnu(5) = fnul + 1.1_DP
    ELSE
      nl = 4
      il = 13
      DO i = 1, il
        kdo(i) = 0
        keps(i) = 0
      END DO
      kdo(2) = 1
      kdo(6) = 1
      kdo(8) = 1
      kdo(12) = 1
      keps(3) = 1
      keps(4) = 1
      keps(5) = 1
      keps(9) = 1
      keps(10) = 1
      keps(11) = 1
      nul = 6
      xnu(1) = 0._DP
      xnu(2) = 0.6_DP
      xnu(3) = 1.3_DP
      xnu(4) = 2._DP
      xnu(5) = 0.5_DP*fnul
      xnu(6) = fnul + 1.1_DP
    END IF
    i = 2
    eps = 0.01_DP
    film = il - 1
    t(1) = -pi + eps
    DO k = 2, il
      IF( kdo(k)==0 ) THEN
        t(i) = pi*(-il+2*k-1)/film
        IF( keps(k)/=0 ) THEN
          ts = t(i)
          t(i) = ts - eps
          i = i + 1
          t(i) = ts + eps
        ELSE
          i = i + 1
        END IF
      END IF
    END DO
    itl = i - 1
    !-----------------------------------------------------------------------
    !     Test values of Z IN -PI<arg(Z)<=PI near formula boundaries.
    !-----------------------------------------------------------------------
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99004)
      99004 FORMAT (' CHECKS IN THE (Z,FNU) SPACE')
    END IF
    lflg = 0
    DO kode = 1, 2
      DO n = 1, nl
        n1 = n + 1
        DO nu = 1, nul
          fnu = xnu(nu)
          ifnu = INT(fnu)
          ffnu = fnu - ifnu
          arg = pi*ffnu
          csgn = CMPLX(COS(arg),SIN(arg),DP)
          IF( MOD(ifnu,2)==1 ) THEN
            csgn = -csgn
          END IF
          DO icase = 1, 3
            irb = MIN(2,icase)
            DO ir = irb, 4
              !-------------- switch (icase)
              SELECT CASE (icase)
                CASE (2)
                  r = (2._DP*(4-ir)+r2*(ir-1))/3._DP
                CASE (3)
                  IF( r2>=rm ) EXIT
                  r = (r2*(4-ir)+rm*(ir-1))/3._DP
                CASE DEFAULT
                  r = (eps*(4-ir)+2._DP*(ir-1))/3._DP
              END SELECT
              !-------------- end switch
              DO it = 1, itl
                ct = COS(t(it))
                st = SIN(t(it))
                IF( ABS(ct)<atol ) ct = 0._DP
                IF( ABS(st)<atol ) st = 0._DP
                z = r*CMPLX(ct,st,DP)
                CALL ZBESI(z,fnu,kode,n1,w,nz2,ierr)
                !---------------- Underflow? - skip test for this case.
                IF( nz2==0 ) THEN
                  !-----------------------------------------------------------------------
                  !     In the left half plane, the analytic continuation formula for K
                  !     introduces an I function. The dominant terms in the Wronskian
                  !     I(FNU,Z)*I(FNU+1,Z) cancel out, giving losses of significance.
                  !     This cancellation can be done analytically to give a Wronskian in
                  !     terms of I in the left half plane and K in the right half plane.
                  !-----------------------------------------------------------------------
                  IF( icase==1 .OR. ct>=0._DP ) THEN
                    !------------------ Z is in the right half plane
                    CALL ZBESK(z,fnu,kode,n1,y,nz1,ierr)
                    cv = (1._DP,0._DP)/z
                    IF( kode==2 ) THEN
                      !-------------------- Adjust Wronskian due to scaled I and K functions
                      axx = ABS(REAL(z,DP))
                      zn = CMPLX(-axx,0._DP,DP)
                      cv = zn + z
                      stt = EXP(cv)
                      cv = stt/z
                    END IF
                  ELSE
                    !------------------ Z is in the left half plane
                    zn = -z
                    CALL ZBESK(zn,fnu,kode,n1,y,nz1,ierr)
                    zn = csgn
                    !------------------ CSGNR and CSGNI set near top of DO 180 loop
                    IF( st>0._DP .OR. (st==0._DP .AND. ct<0._DP) ) zn = CONJG(zn)
                    DO kk = 1, n1
                      y(kk) = y(kk)*zn
                      zn = -zn
                    END DO
                    cv = (1._DP,0._DP)/z
                    IF( kode==2 ) THEN
                      !-------------------- Adjust Wronskian due to scaled I and K functions
                      axx = ABS(REAL(z,DP))
                      zn = CMPLX(-axx,0._DP,DP)
                      cv = zn - z
                      stt = EXP(cv)
                      cv = stt/z
                    END IF
                  END IF
                  mflg = 0
                  DO i = 1, n
                    cw = w(i)*y(i+1)
                    cy = w(i+1)*y(i)
                    cy = cy + cw - cv
                    er = ABS(cy)/ABS(cv)
                    aer(i) = er
                    IF( er>ertol ) mflg = 1
                  END DO
                  IF( mflg/=0 ) THEN
                    IF( lflg==0 ) THEN
                      IF( Kprint>=2 ) THEN
                        WRITE (Lun,99005) ertol
                        99005 FORMAT (/' CASES WHICH OR VIOLATE THE RELATIVE',&
                          ' ERROR TEST WITH ERTOL = ',D12.4/)
                        WRITE (Lun,99006)
                        99006 FORMAT (' INPUT TO ZBESK   Z, FNU, KODE, N')
                      END IF
                      IF( Kprint>=3 ) THEN
                        WRITE (Lun,99007)
                        99007 FORMAT (' ERROR TEST ON THE WRONSKIAN OF ',&
                          'ZBESI(Z,FNU) AND ZBESK(Z,FNU)')
                        WRITE (Lun,99008)
                        99008 FORMAT (' RESULTS FROM ZBESK   NZ1, Y(KK)'/,&
                          ' RESULTS FROM ZBESI   NZ2, W(KK)')
                        WRITE (Lun,99009)
                        99009 FORMAT (' TEST CASE INDICES   IT, IR, ICASE'/)
                      END IF
                    END IF
                    lflg = lflg + 1
                    IF( Kprint>=2 ) THEN
                      WRITE (Lun,99010) z, fnu, kode, n
                      99010 FORMAT ('   INPUT:    Z=',2D12.4,4X,'FNU=',D12.4,4X,&
                        'KODE=',I3,4X,'N=',I3)
                    END IF
                    IF( Kprint>=3 ) THEN
                      WRITE (Lun,99011) (aer(k),k=1,n)
                      99011 FORMAT ('   ERROR:  AER(K)=',4D12.4)
                      kk = MAX(nz1,nz2) + 1
                      kk = MIN(n,kk)
                      WRITE (Lun,99012) nz1, y(kk), nz2, w(kk)
                      99012 FORMAT (' RESULTS:  NZ1=',I3,4X,'Y(KK)=',2D12.4,/11X,&
                        'NZ2=',I3,4X,'W(KK)=',2D12.4)
                      WRITE (Lun,99013) it, ir, icase
                      99013 FORMAT ('    CASE:   IT=',I3,4X,'IR=',I3,4X,'ICASE=',I3/)
                    END IF
                  END IF
                END IF
              END DO
            END DO
          END DO
        END DO
      END DO
    END DO
    IF( Kprint>=2 ) THEN
      IF( lflg==0 ) THEN
        WRITE (Lun,99014)
        99014 FORMAT (' QUICK CHECKS OK')
      ELSE
        WRITE (Lun,99015) lflg
        99015 FORMAT (' ***',I5,' FAILURE(S) FOR ZBESK NEAR FORMULA ','BOUNDARIES')
      END IF
    END IF
    Ipass = 0
    IF( lflg==0 ) Ipass = 1
    IF( Ipass==1 .AND. Kprint>=2 ) THEN
      WRITE (Lun,99016)
      99016 FORMAT (/' ****** ZBESK  PASSED ALL TESTS  ******'/)
    END IF
    IF( Ipass==0 .AND. Kprint>=1 ) THEN
      WRITE (Lun,99017)
      99017 FORMAT (/' ****** ZBESK  FAILED SOME TESTS ******'/)
    END IF
  END SUBROUTINE ZQCBK
  !** ZQCBY
  SUBROUTINE ZQCBY(Lun,Kprint,Ipass)
    !> Quick check for SLATEC subroutine
    !            ZBESY
    !***
    ! **Library:**   SLATEC
    !***
    ! **Category:**  C10A4
    !***
    ! **Type:**      COMPLEX (CQCBY-C, ZQCBY-Z)
    !***
    ! **Keywords:**  QUICK CHECK, ZBESY
    !***
    ! **Author:**  Amos, Don, (SNL)
    !           Goudy, Sue, (SNL)
    !           Walton, Lee, (SNL)
    !***
    ! **Description:**
    !
    !- Usage:
    !
    !        INTEGER  LUN, KPRINT, IPASS
    !
    !        CALL ZQCBY (LUN, KPRINT, IPASS)
    !
    !- Arguments:
    !
    !     LUN    :IN  is the unit number to which output is to be written.
    !
    !     KPRINT :IN  controls the amount of output, as specified in the
    !                 SLATEC Guidelines.
    !
    !     IPASS  :OUT indicates whether the test passed or failed.
    !                 A value of one is good, indicating no failures.
    !
    !- Description:
    !
    !                 *** A DOUBLE PRECISION ROUTINE ***
    !
    !   ZQCBY is a quick check routine for the complex Y Bessel function
    !    generated by subroutine ZBESY.
    !
    !   ZQCBY generates sequences of Y Bessel functions from ZBESY
    !    and checks them against the evaluation from the formula
    !
    !    Y(FNU,Z*ROT) = C(FNU+1)*I(FNU,Z)-(2/PI)*CONJG(C(FNU))*K(FNU,Z)
    !
    !    where ROT = EXP(PI*I/2), C(FNU)=EXP(PI*FNU*I/2), I**2=-1
    !
    !    and -PI<ARG(Z)<=PI/2, in the (Z,FNU) space.
    !
    !***
    ! **References:**  Abramowitz, M. and Stegun, I. A., Handbook
    !                 of Mathematical Functions, Dover Publications,
    !                 New York, 1964.
    !               Amos, D. E., A Subroutine Package for Bessel
    !                 Functions of a Complex Argument and Nonnegative
    !                 Order, SAND85-1018, May, 1985.
    !***
    ! **Routines called:**  ZBESI, ZBESK, ZBESY, ZABS, ZEXP, I1MACH, D1MACH

    !* REVISION HISTORY  (YYMMDD)
    !   830501  DATE WRITTEN
    !   890831  Revised to meet new SLATEC standards
    !   930122  Added ZEXP to EXTERNAL Statement.  (RWC)
    USE service, ONLY : eps_dp, log10_radix_dp, min_exp_dp, max_exp_dp
    USE special_functions, ONLY : ZBESI, ZBESK, ZBESY

    !
    !*Internal Notes:
    !   Machine constants are defined by functions I1MACH and D1MACH.
    !
    !   The parameter MQC can have values 1 (the default) for a faster,
    !   less definitive test or 2 for a slower, more definitive test.
    !
    !**End
    !
    !  Set test complexity parameter.
    INTEGER, PARAMETER :: MQC = 1
    !  Declare arguments.
    INTEGER :: Lun, Kprint, Ipass
    !
    !  Declare local variables.
    !
    COMPLEX(DP) :: coe1, coe2, csgn, cspn, cw, cwrk(20), v(20), w(20), y(20), z, &
      zn, stt, a
    REAL(DP) :: aa, ab, aer(20), alim, arg, atol, av, cc, &
      ct, dig, elim, eps, er, ertol, ffnu, film, fnu, &
      fnul, hpi, pi, r, rhpi, rl, rm, r1m4, &
      r1m5, r2, slak, st, t(20), tol, ts, xnu(20)
    INTEGER :: i, icase, ierr, ifnu, il, ir, irb, it, itl, i4, k, &
      kdo(20), keps(20), kk, kode, k1, k2, lflg, mflg, n, nl, nu, nul, nz, nz1, nz2
    COMPLEX(DP), PARAMETER :: cip(4) = [ (1._DP,0._DP), (0._DP,1._DP), &
      (-1._DP,0._DP), (0._DP,-1._DP) ]
    !
    !* FIRST EXECUTABLE STATEMENT  ZQCBY
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99001)
      99001 FORMAT (' QUICK CHECK ROUTINE FOR THE Y BESSEL FUNCTION FROM ','ZBESY'/)
    END IF
    !-----------------------------------------------------------------------
    !     Set parameters related to machine constants.
    !     TOL is the approximate unit roundoff limited to 1.0D-18.
    !     ELIM is the approximate exponential over- and underflow limit.
    !     exp(-ELIM)<exp(-ALIM)=exp(-ELIM)/TOL    and
    !     exp(ELIM)>exp(ALIM)=exp(ELIM)*TOL       are intervals near
    !     underflow and overflow limits where scaled arithmetic is done.
    !     RL is the lower boundary of the asymptotic expansion for large Z.
    !     DIG = number of base 10 digits in TOL = 10**(-DIG).
    !     FNUL is the lower boundary of the asymptotic series for large FNU.
    !-----------------------------------------------------------------------
    r1m4 = eps_dp
    tol = MAX(r1m4,1.E-18_DP)
    atol = 100._DP*tol
    aa = -LOG10(r1m4)
    k1 = min_exp_dp
    k2 = max_exp_dp
    r1m5 = log10_radix_dp
    k = MIN(ABS(k1),ABS(k2))
    elim = 2.303_DP*(k*r1m5-3._DP)
    ab = aa*2.303_DP
    alim = elim + MAX(-ab,-41.45_DP)
    dig = MIN(aa,18._DP)
    fnul = 10._DP + 6._DP*(dig-3._DP)
    rl = 1.2_DP*dig + 3._DP
    slak = 3._DP + 4._DP*(-LOG10(tol)-7._DP)/11._DP
    slak = MAX(slak,3._DP)
    ertol = tol*10._DP**slak
    rm = 0.5_DP*(alim+elim)
    rm = MIN(rm,200._DP)
    rm = MAX(rm,rl+10._DP)
    r2 = MIN(rm,fnul)
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99002)
      99002 FORMAT (' PARAMETERS'/5X,'TOL ',8X,'ELIM',8X,'ALIM',8X,'RL  ',8X,'FNUL',&
        8X,'DIG')
      WRITE (Lun,99003) tol, elim, alim, rl, fnul, dig
      99003 FORMAT (1X,6D12.4/)
    END IF
    !-----------------------------------------------------------------------
    !     Set other constants needed in the tests.
    !-----------------------------------------------------------------------
    hpi = 2._DP*ATAN(1._DP)
    rhpi = 1._DP/hpi
    pi = hpi + hpi
    !-----------------------------------------------------------------------
    !     Generate angles for construction of complex Z to be used in tests.
    !-----------------------------------------------------------------------
    !     KDO(K), K = 1,IL  determines which of the IL angles in -PI to PI
    !     are used to compute values of Z.
    !       KDO(K) = 0  means that the index K will be used for one or two
    !                   values of Z, depending on the choice of KEPS(K)
    !              = 1  means that the index K and the corresponding angle
    !                   will be skipped
    !     KEPS(K), K = 1,IL determines which of the angles get incremented
    !     up and down to put values of Z in regions where different
    !     formulae are used.
    !       KEPS(K)  = 0  means that the angle will be used without change
    !                = 1  means that the angle will be incremented up and
    !                   down by EPS
    !     The angles to be used are stored in the T(I) array, I = 1,ITL.
    !-----------------------------------------------------------------------
    IF( MQC/=2 ) THEN
      nl = 2
      il = 5
      DO i = 1, il
        keps(i) = 0
        kdo(i) = 0
      END DO
      kdo(5) = 1
      nul = 5
      xnu(1) = 0._DP
      xnu(2) = 1._DP
      xnu(3) = 2._DP
      xnu(4) = 0.5_DP*fnul
      xnu(5) = fnul + 1.2_DP
    ELSE
      nl = 4
      il = 13
      DO i = 1, il
        kdo(i) = 0
        keps(i) = 0
      END DO
      kdo(2) = 1
      kdo(6) = 1
      kdo(8) = 1
      kdo(11) = 1
      kdo(12) = 1
      kdo(13) = 1
      keps(3) = 1
      keps(4) = 1
      keps(5) = 1
      keps(9) = 1
      nul = 6
      xnu(1) = 0._DP
      xnu(2) = 0.6_DP
      xnu(3) = 1.3_DP
      xnu(4) = 2._DP
      xnu(5) = 0.5_DP*fnul
      xnu(6) = fnul + 1.2_DP
    END IF
    i = 2
    eps = 0.01_DP
    film = il - 1
    t(1) = -pi + eps
    DO k = 2, il
      IF( kdo(k)==0 ) THEN
        t(i) = pi*(-il+2*k-1)/film
        IF( keps(k)/=0 ) THEN
          ts = t(i)
          t(i) = ts - eps
          i = i + 1
          t(i) = ts + eps
        ELSE
          i = i + 1
        END IF
      END IF
    END DO
    itl = i - 1
    !-----------------------------------------------------------------------
    !     Test values of Z in -PI/2<arg(Z)<=PI
    !-----------------------------------------------------------------------
    IF( Kprint>=2 ) THEN
      WRITE (Lun,99004)
      99004 FORMAT (' CHECKS IN THE (Z,FNU) SPACE')
    END IF
    lflg = 0
    DO kode = 1, 2
      DO n = 1, nl
        DO nu = 1, nul
          !-----------------------------------------------------------------------
          !     Construct values which will be used to set
          !           COE1 = exp(i*(FNU+1)*PI/2) and
          !           COE2 = (2/pi)*exp(-i*FNU*PI/2).
          !-----------------------------------------------------------------------
          fnu = xnu(nu)
          ifnu = INT(fnu)
          ffnu = fnu - ifnu
          arg = hpi*ffnu
          csgn = CMPLX( COS(arg), SIN(arg), DP )
          i4 = MOD(ifnu,4) + 1
          csgn = csgn*cip(i4)
          cspn = CONJG(csgn)*rhpi
          !---------- CSGN=CSGN*CI in CQCBY
          csgn = (0._DP,1._DP)*csgn
          DO icase = 1, 3
            irb = MIN(2,icase)
            DO ir = irb, 4
              !-------------- switch (icase)
              SELECT CASE (icase)
                CASE (2)
                  r = (2._DP*(4-ir)+r2*(ir-1))/3._DP
                CASE (3)
                  IF( r2>=rm ) EXIT
                  r = (r2*(4-ir)+rm*(ir-1))/3._DP
                CASE DEFAULT
                  r = (eps*(4-ir)+2._DP*(ir-1))/3._DP
              END SELECT
              !-------------- end switch
              DO it = 1, itl
                ct = COS(t(it))
                st = SIN(t(it))
                IF( ABS(ct)<atol ) ct = 0._DP
                IF( ABS(st)<atol ) st = 0._DP
                z = r*CMPLX(ct,st,DP)
                CALL ZBESI(z,fnu,kode,n,w,nz2,ierr)
                !---------------- Underflow in ZBESI - skip test for this case.
                IF( nz2==0 ) THEN
                  CALL ZBESK(z,fnu,kode,n,y,nz1,ierr)
                  !---------------- Underflow in ZBESK - skip test for this case.
                  IF( nz1==0 ) THEN
                    zn = (0._DP,1._DP)*z
                    CALL ZBESY(zn,fnu,kode,n,v,nz,cwrk,ierr)
                    !---------------- Underflow in ZBESY - skip test for this case.
                    IF( nz==0 ) THEN
                      coe1 = csgn
                      coe2 = cspn
                      IF( kode==2 ) THEN
                        !------------------ Adjust scale for I and K functions.
                        cc = -REAL(z,DP) - ABS(REAL(z,DP))
                        IF( cc>(-alim) ) THEN
                          zn = CMPLX( cc, -AIMAG(z), DP )
                          stt = EXP(zn)
                          coe2 = stt*coe2
                        ELSE
                          !-------------------- Scaling problem - skip test for this case
                          coe2 = (0._DP,0._DP)
                          CYCLE
                        END IF
                      END IF
                      DO kk = 1, n
                        y(kk) = y(kk)*coe2
                        w(kk) = w(kk)*coe1
                        coe1 = (0._DP,1._DP)*coe1
                        coe2 = (0._DP,-1._DP)*coe2
                      END DO
                      !---------------------------------------------------------
                      !     Compare Y(ZN,FNU) with COE1*I(Z,FNU)-COE2*K(Z,FNU).
                      !---------------------------------------------------------
                      mflg = 0
                      DO i = 1, n
                        ab = fnu + i - 1
                        aa = MAX(0.5_DP,ab)
                        cw = w(i) - y(i)
                        av = ABS(v(i))
                        a = cw - v(i)
                        er = ABS(a)
                        IF( av/=0._DP ) THEN
                          IF( AIMAG(zn)/=0._DP ) THEN
                            er = er/av
                          ELSEIF( REAL(zn,DP)>0._DP ) THEN
                            IF( ABS(REAL(zn,DP))<aa ) er = er/av
                          ELSEIF( ABS(ffnu-0.5_DP)<0.125_DP ) THEN
                            IF( ABS(REAL(zn,DP))<aa ) er = er/av
                          ELSE
                            er = er/av
                          END IF
                        END IF
                        aer(i) = er
                        IF( er>ertol ) mflg = 1
                      END DO
                      IF( mflg/=0 ) THEN
                        IF( lflg==0 ) THEN
                          IF( Kprint>=2 ) THEN
                            WRITE (Lun,99005) ertol
                            99005 FORMAT (/' CASES WHICH VIOLATE THE RELATIVE ',&
                              'ERROR TEST WITH ERTOL = ',D12.4/)
                            WRITE (Lun,99006)
                            99006 FORMAT (' INPUT TO ZBESY   ZN, FNU, KODE, N')
                          END IF
                          IF( Kprint>=3 ) THEN
                            WRITE (Lun,99007)
                            99007 FORMAT (' COMPARE Y(ZN,FNU) WITH COE1*I(Z,FNU)',&
                              '-COE2*K(Z,FNU)')
                            WRITE (Lun,99008)
                            99008 FORMAT (' Z = ZN*EXP(-i*PI/2)'/&
                              ' COE1 = EXP(i*(FNU+1)*PI/2)  ',&
                              ' COE2 = (2/PI)*EXP(-i*FNU*PI/2)')
                            WRITE (Lun,99009)
                            99009 FORMAT (' RESULTS FROM ZBESY   V(KK)'/9X,&
                              'FROM ZBESI   W(KK)'/9X,&
                              'FROM ZBESK   Y(KK)')
                            WRITE (Lun,99010)
                            99010 FORMAT (' TEST CASE INDICES   IR, IT, ICASE'/)
                          END IF
                        END IF
                        lflg = lflg + 1
                        IF( Kprint>=2 ) THEN
                          WRITE (Lun,99011) zn, fnu, kode, n
                          99011 FORMAT ('   INPUT:   ZN=',2D12.4,3X,'FNU=',D12.4,3X,&
                            'KODE=',I3,3X,'N=',I3)
                        END IF
                        IF( Kprint>=3 ) THEN
                          WRITE (Lun,99012) (aer(k),k=1,n)
                          99012 FORMAT ('   ERROR:   AER(K)=',4D12.4)
                          WRITE (Lun,99013) z, coe1, coe2
                          99013 FORMAT (12X,'Z=',2D12.4/12X,'COE1=',2D12.4,3X,&
                            'COE2=',2D12.4)
                          kk = MAX(nz1,nz2) + 1
                          kk = MIN(n,kk)
                          WRITE (Lun,99014) v(kk), w(kk), y(kk)
                          99014 FORMAT (' RESULTS:   V(KK)=',2D12.4/12X,'W(KK)=',&
                            2D12.4/12X,'Y(KK)=',2D12.4)
                          WRITE (Lun,99015) ir, it, icase
                          99015 FORMAT ('    CASE:   IR=',I3,3X,'IT=',I3,3X,&
                            'ICASE=',I3/)
                        END IF
                      END IF
                    END IF
                  END IF
                END IF
              END DO
            END DO
          END DO
        END DO
      END DO
    END DO
    IF( Kprint>=2 ) THEN
      IF( lflg==0 ) THEN
        WRITE (Lun,99016)
        99016 FORMAT (' QUICK CHECKS OK')
      ELSE
        WRITE (Lun,99017) lflg
        99017 FORMAT (' ***',I5,' FAILURE(S) FOR ZBESY IN THE (Z,FNU) ','PLANE')
      END IF
    END IF
    Ipass = 0
    IF( lflg==0 ) Ipass = 1
    IF( Ipass==1 .AND. Kprint>=2 ) THEN
      WRITE (Lun,99018)
      99018 FORMAT (/' ****** ZBESY  PASSED ALL TESTS  ******'/)
    END IF
    IF( Ipass==0 .AND. Kprint>=1 ) THEN
      WRITE (Lun,99019)
      99019 FORMAT (/' ****** ZBESY  FAILED SOME TESTS ******'/)
    END IF
  END SUBROUTINE ZQCBY
END MODULE TEST10_MOD
!** TEST10
PROGRAM TEST10
  USE TEST10_MOD, ONLY : ZQCAI, ZQCBH, ZQCBI, ZQCBJ, ZQCBK, ZQCBY
  USE ISO_FORTRAN_ENV, ONLY : INPUT_UNIT, OUTPUT_UNIT
  USE common_mod, ONLY : GET_ARGUMENT
  IMPLICIT NONE
  !> Driver for testing SLATEC subprograms.
  !***
  ! **Library:**   SLATEC
  !***
  ! **Category:**  C7A, C10A4, C10B4, C10D
  !***
  ! **Type:**      DOUBLE PRECISION (TEST09-S, TEST10-D)
  !***
  ! **Keywords:**  QUICK CHECK DRIVER
  !***
  ! **Author:**  SLATEC Common Mathematical Library Committee
  !***
  ! **Description:**
  !
  !- Usage:
  !     One input data record is required
  !         READ (LIN, '(I1)') KPRINT
  !
  !- Arguments:
  !     KPRINT = 0  Quick checks - No printing.
  !                 Driver       - Short pass or fail message printed.
  !              1  Quick checks - No message printed for passed tests,
  !                                short message printed for failed tests.
  !                 Driver       - Short pass or fail message printed.
  !              2  Quick checks - Print short message for passed tests,
  !                                fuller information for failed tests.
  !                 Driver       - Pass or fail message printed.
  !              3  Quick checks - Print complete quick check results.
  !                 Driver       - Pass or fail message printed.
  !
  !- Description:
  !     Driver for testing SLATEC subprograms
  !               ZABS, ZAIRY, ZBESH, ZBESI, ZBESJ, ZBESK, ZBESY, ZBIRY,
  !               ZDIV, ZEXP, ZSQRT, ZUOIK, ZWRSK
  !
  !***
  ! **References:**  Fong, Kirby W., Jefferson, Thomas H., Suyehiro,
  !                 Tokihiko, Walton, Lee, Guidelines to the SLATEC Common
  !                 Mathematical Library, March 21, 1989.
  !***
  ! **Routines called:**  I1MACH, XERMAX, XSETF, ZQCAI, ZQCBH, ZQCBI,
  !                    ZQCBJ, ZQCBK, ZQCBY

  !* REVISION HISTORY  (YYMMDD)
  !   910411  DATE WRITTEN
  !   920128  Category corrected.  (WRB)

  INTEGER :: ipass, kprint, lin, lun, nfail
  !* FIRST EXECUTABLE STATEMENT  TEST10
  lun = OUTPUT_UNIT
  lin = INPUT_UNIT
  nfail = 0
  !
  !     Read KPRINT parameter
  !
  CALL GET_ARGUMENT(kprint)
  !
  !     Test Double Precision Complex Bessel Functions.
  !
  CALL ZQCAI(lun,kprint,ipass)
  IF( ipass==0 ) nfail = nfail + 1
  CALL ZQCBH(lun,kprint,ipass)
  IF( ipass==0 ) nfail = nfail + 1
  CALL ZQCBI(lun,kprint,ipass)
  IF( ipass==0 ) nfail = nfail + 1
  CALL ZQCBJ(lun,kprint,ipass)
  IF( ipass==0 ) nfail = nfail + 1
  CALL ZQCBK(lun,kprint,ipass)
  IF( ipass==0 ) nfail = nfail + 1
  CALL ZQCBY(lun,kprint,ipass)
  IF( ipass==0 ) nfail = nfail + 1
  !
  !     Write PASS or FAIL message
  !
  IF( nfail==0 ) THEN
    WRITE (lun,99001)
    99001 FORMAT (/' --------------TEST10 PASSED ALL TESTS----------------')
  ELSE
    WRITE (lun,99002) nfail
    99002 FORMAT (/' ************* WARNING -- ',I5,&
      ' TEST(S) FAILED IN PROGRAM TEST10  *************')
  END IF
  STOP
END PROGRAM TEST10
