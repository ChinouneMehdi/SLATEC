!*==ZQCBJ.f90  processed by SPAG 6.72Dc at 10:52 on  6 Feb 2019
!DECK ZQCBJ
      SUBROUTINE ZQCBJ(Lun,Kprint,Ipass)
      IMPLICIT NONE
!*--ZQCBJ5
!***BEGIN PROLOGUE  ZQCBJ
!***SUBSIDIARY
!***PURPOSE  Quick check for SLATEC subroutine
!            ZBESJ
!***LIBRARY   SLATEC
!***CATEGORY  C10A4
!***TYPE      COMPLEX (CQCBJ-C, ZQCBJ-Z)
!***KEYWORDS  QUICK CHECK, ZBESJ
!***AUTHOR  Amos, Don, (SNL)
!           Goudy, Sue, (SNL)
!           Walton, Lee, (SNL)
!***DESCRIPTION
!
! *Usage:
!
!        INTEGER  LUN, KPRINT, IPASS
!
!        CALL ZQCBJ (LUN, KPRINT, IPASS)
!
! *Arguments:
!
!     LUN    :IN  is the unit number to which output is to be written.
!
!     KPRINT :IN  controls the amount of output, as specified in the
!                 SLATEC Guidelines.
!
!     IPASS  :OUT indicates whether the test passed or failed.
!                 A value of one is good, indicating no failures.
!
! *Description:
!
!                 *** A DOUBLE PRECISION ROUTINE ***
!
!   ZQCBJ is a quick check routine for the complex J Bessel function
!    generated by subroutine ZBESJ.
!
!   ZQCBJ generates sequences of J Bessel functions from ZBESJ
!    and checks them against the evaluation from the formula
!
!            J(FNU,Z) = 0.5*( H(1,FNU,Z) + H(2,FNU,Z) )
!
!    where -PI.lt.arg(Z).le.PI for abs(Z).ge.FNU.
!
!   For abs(Z).lt.FNU, the first N members of a sequence of length
!    N+16 are checked against a corresponding N member sequence where
!    both sequences are generated by ZBESJ beginning at order FNU.
!
!***REFERENCES  Abramowitz, M. and Stegun, I. A., Handbook
!                 of Mathematical Functions, Dover Publications,
!                 New York, 1964.
!               Amos, D. E., A Subroutine Package for Bessel
!                 Functions of a Complex Argument and Nonnegative
!                 Order, SAND85-1018, May, 1985.
!***ROUTINES CALLED  ZBESH, ZBESJ, ZABS, ZEXP, I1MACH, D1MACH
!***REVISION HISTORY  (YYMMDD)
!   830501  DATE WRITTEN
!   890831  Revised to meet new SLATEC standards
!   930122  Added ZEXP to EXTERNAL statement.  (RWC)
!***END PROLOGUE  ZQCBJ
!
!*Internal Notes:
!   Machine constants are defined by functions I1MACH and D1MACH.
!
!   The parameter MQC can have values 1 (the default) for a faster,
!   less definitive test or 2 for a slower, more definitive test.
!
!**End
!
!  Set test complexity parameter.
!
      INTEGER MQC
      PARAMETER (MQC=1)
!
!  Declare arguments.
!
      INTEGER Lun , Kprint , Ipass
!
!  Declare external functions.
!
      INTEGER I1MACH
      DOUBLE PRECISION D1MACH , ZABS
      EXTERNAL I1MACH , D1MACH , ZABS , ZEXP
!
!  Declare local variables.
!
      DOUBLE PRECISION coe1r , coe1i , coe2r , coe2i , cwr , cwi , halfr , 
     &                 halfi , vr , vi , wr , wi , yr , yi , zr , zi
      DOUBLE PRECISION aa , ab , aer , ai , alim , ar , atol , av , cc , ct , 
     &                 dd , dig , elim , eps , er , ertol , film , fnu , fnul , 
     &                 gnu , hpi , pi , r , rl , rm , r1m4 , r1m5 , r2 , slak , 
     &                 st , str , t , tol , ts , xnu
      INTEGER i , icase , ierr , il , ir , irb , it , itl , k , kdo , keps , 
     &        kk , kode , k1 , k2 , lflg , m , mflg , n , nl , nu , nul , nz , 
     &        nz1 , nz2
      DIMENSION aer(20) , kdo(20) , keps(20) , t(20) , vr(20) , vi(20) , wr(20)
     &          , wi(20) , xnu(20) , yr(20) , yi(20)
!
!***FIRST EXECUTABLE STATEMENT  ZQCBJ
      IF ( Kprint>=2 ) THEN
        WRITE (Lun,99001)
99001   FORMAT (' QUICK CHECK ROUTINE FOR THE J BESSEL FUNCTION FROM ','ZBESJ'/)
      ENDIF
!-----------------------------------------------------------------------
!     Set parameters related to machine constants.
!     TOL is the approximate unit roundoff limited to 1.0D-18.
!     ELIM is the approximate exponential over- and underflow limit.
!     exp(-ELIM).lt.exp(-ALIM)=exp(-ELIM)/TOL    and
!     exp(ELIM).gt.exp(ALIM)=exp(ELIM)*TOL       are intervals near
!     underflow and overflow limits where scaled arithmetic is done.
!     RL is the lower boundary of the asymptotic expansion for large Z.
!     DIG = number of base 10 digits in TOL = 10**(-DIG).
!     FNUL is the lower boundary of the asymptotic series for large FNU.
!-----------------------------------------------------------------------
      r1m4 = D1MACH(4)
      tol = MAX(r1m4,1.0D-18)
      atol = 100.0D0*tol
      aa = -LOG10(r1m4)
      k1 = I1MACH(12)
      k2 = I1MACH(13)
      r1m5 = D1MACH(5)
      k = MIN(ABS(k1),ABS(k2))
      elim = 2.303D0*(k*r1m5-3.0D0)
      ab = aa*2.303D0
      alim = elim + MAX(-ab,-41.45D0)
      dig = MIN(aa,18.0D0)
      fnul = 10.0D0 + 6.0D0*(dig-3.0D0)
      rl = 1.2D0*dig + 3.0D0
      slak = 3.0D0 + 4.0D0*(-LOG10(tol)-7.0D0)/11.0D0
      slak = MAX(slak,3.0D0)
      ertol = tol*10.0D0**slak
      rm = 0.5D0*(alim+elim)
      rm = MIN(rm,200.0D0)
      rm = MAX(rm,rl+10.0D0)
      r2 = MIN(rm,fnul)
      IF ( Kprint>=2 ) THEN
        WRITE (Lun,99002)
99002   FORMAT (' PARAMETERS'/5X,'TOL ',8X,'ELIM',8X,'ALIM',8X,'RL  ',8X,'FNUL',
     &          8X,'DIG')
        WRITE (Lun,99003) tol , elim , alim , rl , fnul , dig
99003   FORMAT (1X,6D12.4/)
      ENDIF
!-----------------------------------------------------------------------
!     Set other constants needed in the tests.
!-----------------------------------------------------------------------
      halfr = 0.5D0
      halfi = 0.0D0
      hpi = 2.0D0*ATAN(1.0D0)
      pi = hpi + hpi
!-----------------------------------------------------------------------
!     Generate angles for construction of complex Z to be used in tests.
!-----------------------------------------------------------------------
!     KDO(K), K = 1,IL  determines which of the IL angles in -PI to PI
!     are used to compute values of Z.
!       KDO(K) = 0  means that the index K will be used for one or two
!                   values of Z, depending on the choice of KEPS(K)
!              = 1  means that the index K and the corresponding angle
!                   will be skipped
!     KEPS(K), K = 1,IL determines which of the angles get incremented
!     up and down to put values of Z in regions where different
!     formulae are used.
!       KEPS(K)  = 0  means that the angle will be used without change
!                = 1  means that the angle will be incremented up and
!                   down by EPS
!     The angles to be used are stored in the T(I) array, I = 1,ITL.
!-----------------------------------------------------------------------
      IF ( MQC/=2 ) THEN
        nl = 2
        il = 5
        DO i = 1 , il
          keps(i) = 0
          kdo(i) = 0
        ENDDO
        nul = 5
        xnu(1) = 0.0D0
        xnu(2) = 1.0D0
        xnu(3) = 2.0D0
        xnu(4) = 0.5D0*fnul
        xnu(5) = fnul + 1.1D0
      ELSE
        nl = 4
        il = 13
        DO i = 1 , il
          kdo(i) = 0
          keps(i) = 0
        ENDDO
        kdo(2) = 1
        kdo(6) = 1
        kdo(8) = 1
        kdo(12) = 1
        keps(3) = 1
        keps(4) = 1
        keps(5) = 1
        keps(9) = 1
        keps(10) = 1
        keps(11) = 1
        nul = 6
        xnu(1) = 0.0D0
        xnu(2) = 0.6D0
        xnu(3) = 1.3D0
        xnu(4) = 2.0D0
        xnu(5) = 0.5D0*fnul
        xnu(6) = fnul + 1.1D0
      ENDIF
      i = 2
      eps = 0.01D0
      film = il - 1
      t(1) = -pi + eps
      DO k = 2 , il
        IF ( kdo(k)==0 ) THEN
          t(i) = pi*(-il+2*k-1)/film
          IF ( keps(k)==0 ) THEN
            ts = t(i)
            t(i) = ts - eps
            i = i + 1
            t(i) = ts + eps
          ELSE
            i = i + 1
          ENDIF
        ENDIF
      ENDDO
      itl = i - 1
!-----------------------------------------------------------------------
!     Test values of Z in -PI.lt.arg(Z).le.PI.
!-----------------------------------------------------------------------
      IF ( Kprint>=2 ) THEN
        WRITE (Lun,99004)
99004   FORMAT (' CHECKS IN THE (Z,FNU) SPACE'/)
      ENDIF
      lflg = 0
      DO kode = 1 , 2
        DO n = 1 , nl
          DO nu = 1 , nul
            fnu = xnu(nu)
            DO icase = 1 , 3
              irb = MIN(2,icase)
              DO ir = irb , 4
!-------------- switch (icase)
                SELECT CASE (icase)
                CASE (2)
                  r = (2.0D0*(4-ir)+r2*(ir-1))/3.0D0
                CASE (3)
                  IF ( r2>=rm ) EXIT
                  r = (r2*(4-ir)+rm*(ir-1))/3.0D0
                CASE DEFAULT
                  r = (eps*(4-ir)+2.0D0*(ir-1))/3.0D0
                END SELECT
!-------------- end switch
                gnu = fnu + (n-1)
                DO it = 1 , itl
                  ct = COS(t(it))
                  st = SIN(t(it))
                  IF ( ABS(ct)<atol ) ct = 0.0D0
                  IF ( ABS(st)<atol ) st = 0.0D0
                  zr = r*ct
                  zi = r*st
                  IF ( r>=gnu ) THEN
!------------------ Cases for abs(Z).ge.FNU+N-1
                    CALL ZBESJ(zr,zi,fnu,kode,n,vr,vi,nz,ierr)
!------------------ Underflow - skip test for this case.
                    IF ( nz/=0 ) CYCLE
                    CALL ZBESH(zr,zi,fnu,kode,1,n,wr,wi,nz1,ierr)
                    CALL ZBESH(zr,zi,fnu,kode,2,n,yr,yi,nz2,ierr)
                    IF ( kode==2 ) THEN
!-------------------- Adjust scaling of H functions.
                      cc = -zi - ABS(zi)
                      IF ( cc>(-alim) ) THEN
                        cwr = cc
                        cwi = zr
                        CALL ZEXP(cwr,cwi,coe1r,coe1i)
                      ELSE
                        coe1r = 0.0D0
                        coe1i = 0.0D0
                      ENDIF
                      dd = zi - ABS(zi)
                      IF ( dd>(-alim) ) THEN
                        cwr = dd
                        cwi = -zr
                        CALL ZEXP(cwr,cwi,coe2r,coe2i)
                      ELSE
                        coe2r = 0.0D0
                        coe2i = 0.0D0
                      ENDIF
                      DO kk = 1 , n
                        str = yr(kk)*coe2r - yi(kk)*coe2i
                        yi(kk) = yr(kk)*coe2i + yi(kk)*coe2r
                        yr(kk) = str
                        str = wr(kk)*coe1r - wi(kk)*coe1i
                        wi(kk) = wr(kk)*coe1i + wi(kk)*coe1r
                        wr(kk) = str
                      ENDDO
                    ENDIF
                  ELSE
!------------------ Cases for abs(Z).lt.FNU+N-1
                    m = n + 16
                    CALL ZBESJ(zr,zi,fnu,kode,m,vr,vi,nz,ierr)
!------------------ Underflow at end of sequence - skip test
                    IF ( nz>10 ) CYCLE
                    CALL ZBESJ(zr,zi,fnu,kode,n,wr,wi,nz,ierr)
                    DO kk = 1 , n
                      yr(kk) = wr(kk)
                      yi(kk) = wi(kk)
                    ENDDO
                  ENDIF
!-----------------------------------------------------------------------
!     If abs(Z).ge.FNU+N-1 then the error test compares J(Z<FNU) with
!     0.5*(H1(Z,FNU) + H2(Z,FNU)).
!     If abs(Z).lt.FNU+N-1 then the error test ensures that calculations
!     begun in one region of the (Z,FNU) plane and carried into another
!     region do not diverge from calculations carried out entirely in
!     one region.  This is an internal consistency check.
!-----------------------------------------------------------------------
                  mflg = 0
                  DO i = 1 , n
                    ab = fnu + i - 1
                    aa = MAX(2.0D0,ab)
                    cwr = (wr(i)+yr(i))*halfr - (wi(i)+yi(i))*halfi
                    cwi = (wr(i)+yr(i))*halfi + (wi(i)+yi(i))*halfr
                    av = ZABS(vr(i),vi(i))
                    ar = cwr - vr(i)
                    ai = cwi - vi(i)
                    er = ZABS(ar,ai)
                    IF ( av/=0.0D0 ) THEN
                      IF ( zi==0.0D0 ) THEN
                        IF ( DABS(zr)<aa ) er = er/av
                      ELSE
                        er = er/av
                      ENDIF
                    ENDIF
                    aer(i) = er
                    IF ( er>ertol ) mflg = 1
                  ENDDO
                  IF ( mflg/=0 ) THEN
                    IF ( lflg==0 ) THEN
                      IF ( Kprint>=2 ) THEN
                        WRITE (Lun,99005) ertol
99005                   FORMAT (' CASES WHICH VIOLATE THE RELATIVE ',
     &                          'ERROR TEST WITH ERTOL=',D12.4/)
                        WRITE (Lun,99006)
99006                   FORMAT (' INPUT TO ZBESJ   Z, FNU, KODE, N')
                      ENDIF
                      IF ( Kprint>=3 ) THEN
                        IF ( r>=gnu ) THEN
                          WRITE (Lun,99007)
99007                     FORMAT (' COMPARE WITH AVERAGE OF H1 AND H2 ',
     &                            'FUNCTIONS FOR THE SAME INPUT')
                          WRITE (Lun,99008)
99008                     FORMAT (' RESULTS FROM ZBESJ    NZ, V(KK)')
                          WRITE (Lun,99009)
99009                     FORMAT (' RESULTS FROM ZBESH   NZ1, W(KK)')
                          WRITE (Lun,99010)
99010                     FORMAT (' RESULTS FROM ZBESH   NZ2, Y(KK)')
                        ELSE
                          WRITE (Lun,99011)
99011                     FORMAT (' RESULTS FROM ZBESJ    NZ, W(KK)')
                        ENDIF
                        WRITE (Lun,99012)
99012                   FORMAT (' TEST CASE INDICES   IR, IT, ICASE'/)
                      ENDIF
                    ENDIF
                    lflg = lflg + 1
                    IF ( Kprint>=2 ) THEN
                      WRITE (Lun,99013) zr , zi , fnu , kode , n
99013                 FORMAT ('   INPUT:   Z=',2D12.4,3X,'FNU=',D12.4,3X,
     &                        'KODE=',I3,3X,'N=',I3)
                    ENDIF
                    IF ( Kprint>=3 ) THEN
                      WRITE (Lun,99014) (aer(k),k=1,n)
99014                 FORMAT ('   ERROR:   AER(K)=',4D12.4)
                      IF ( r>=gnu ) THEN
                        kk = MAX(nz1,nz2) + 1
                        kk = MIN(n,kk)
                        WRITE (Lun,99015) nz , vr(kk) , vi(kk)
99015                   FORMAT (' RESULTS:   NZ=',I3,3X,'V(KK)=',2D12.4)
                        WRITE (Lun,99016) nz1 , wr(kk) , wi(kk)
99016                   FORMAT (' RESULTS:  NZ1=',I3,3X,'W(KK)=',2D12.4)
                        WRITE (Lun,99017) nz2 , yr(kk) , yi(kk)
99017                   FORMAT (' RESULTS:  NZ2=',I3,3X,'Y(KK)=',2D12.4)
                      ELSE
                        kk = n - nz
                        WRITE (Lun,99018) nz , wr(kk) , wi(kk)
99018                   FORMAT (' RESULTS:   NZ=',I3,3X,'W(KK)=',2D12.4)
                      ENDIF
                      WRITE (Lun,99019) ir , it , icase
99019                 FORMAT ('    CASE:  IR=',I3,3X,'IT=',I3,3X,'ICASE=',I3/)
                    ENDIF
                  ENDIF
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
      ENDDO
      IF ( Kprint>=2 ) THEN
        IF ( lflg==0 ) THEN
          WRITE (Lun,99020)
99020     FORMAT (' QUICK CHECKS OK')
        ELSE
          WRITE (Lun,99021) lflg
99021     FORMAT (' ***',I5,' FAILURE(S) FOR ZBESJ IN THE (Z,FNU)',' PLANE')
        ENDIF
      ENDIF
      Ipass = 0
      IF ( lflg==0 ) Ipass = 1
      IF ( Ipass==1.AND.Kprint>=2 ) THEN
        WRITE (Lun,99022)
99022   FORMAT (/' ****** ZBESJ  PASSED ALL TESTS  ******'/)
      ENDIF
      IF ( Ipass==0.AND.Kprint>=1 ) THEN
        WRITE (Lun,99023)
99023   FORMAT (/' ****** ZBESJ  FAILED SOME TESTS ******'/)
      ENDIF
      END SUBROUTINE ZQCBJ
