!*==ZQCBI.f90  processed by SPAG 6.72Dc at 10:52 on  6 Feb 2019
!DECK ZQCBI
      SUBROUTINE ZQCBI(Lun,Kprint,Ipass)
      IMPLICIT NONE
!*--ZQCBI5
!***BEGIN PROLOGUE  ZQCBI
!***SUBSIDIARY
!***PURPOSE  Quick check for SLATEC subroutine
!            ZBESI
!***LIBRARY   SLATEC
!***CATEGORY  C10B4
!***TYPE      COMPLEX (CQCBI-C, ZQCBI-Z)
!***KEYWORDS  QUICK CHECK, ZBESI
!***AUTHOR  Amos, Don, (SNL)
!           Goudy, Sue, (SNL)
!           Walton, Lee, (SNL)
!***DESCRIPTION
!
! *Usage:
!
!        INTEGER  LUN, KPRINT, IPASS
!
!        CALL ZQCBI (LUN, KPRINT, IPASS)
!
! *Arguments:
!
!     LUN    :IN  is the unit number to which output is to be written.
!
!     KPRINT :IN  controls the amount of output, as specified in the
!                 SLATEC Guidelines.
!
!     IPASS  :OUT indicates whether the test passed or failed.
!                 A value of one is good, indicating no failures.
!
! *Description:
!
!                 *** A DOUBLE PRECISION ROUTINE ***
!
!   ZQCBI is a quick check routine for the complex I Bessel function
!    generated by subroutine ZBESI.
!
!   ZQCBI generates sequences crossing formula boundaries which
!    are started by one formula and terminated in a region where
!    another formula applies. The terminated value is checked by
!    the formula appropriate to that region.
!
!***REFERENCES  Abramowitz, M. and Stegun, I. A., Handbook
!                 of Mathematical Functions, Dover Publications,
!                 New York, 1964.
!               Amos, D. E., A Subroutine Package for Bessel
!                 Functions of a Complex Argument and Nonnegative
!                 Order, SAND85-1018, May, 1985.
!***ROUTINES CALLED  ZBESI, ZBESK, ZWRSK, ZABS, ZDIV, I1MACH, D1MACH
!***REVISION HISTORY  (YYMMDD)
!   830501  DATE WRITTEN
!   890831  Revised to meet new SLATEC standards
!***END PROLOGUE  ZQCBI
!
!*Internal Notes:
!   Machine constants are defined by functions I1MACH and D1MACH.
!
!   The parameter MQC can have values 1 (the default) for a faster,
!   less definitive test or 2 for a slower, more definitive test.
!
!**End
!
!  Set test complexity parameter.
!
      INTEGER MQC
      PARAMETER (MQC=1)
!
!  Declare arguments.
!
      INTEGER Lun , Kprint , Ipass
!
!  Declare external functions.
!
      INTEGER I1MACH
      DOUBLE PRECISION D1MACH , ZABS
      EXTERNAL I1MACH , D1MACH , ZABS
!
!  Declare local variables.
!
      DOUBLE PRECISION ckr , cki , coner , conei , csgnr , csgni , cwr , cwi , 
     &                 cyr , cyi , wr , wi , yr , yi , zr , zi , znr , zni , 
     &                 ztr , zti
      DOUBLE PRECISION aa , ab , aer , alim , arg , atol , aw , carg , ct , 
     &                 dig , elim , eps , er , ertol , film , fnu , fnul , gnu , 
     &                 hpi , pi , r , rl , rlt , rm , r1 , r1m4 , r1m5 , r2 , 
     &                 sarg , slak , st , sti , str , t , tol , ts , zscr , zzr
      INTEGER i , icase , ierr , il , inu , iprnt , ir , it , itl , k , kdo , 
     &        keps , kk , kode , k1 , k2 , lflg , mflg , n , nl , nzi , nzk , 
     &        nz1 , nz2 , n1
      DIMENSION aer(20) , ckr(2) , cki(2) , kdo(20) , keps(20) , t(20) , wr(20)
     &          , wi(20) , yr(20) , yi(20)
!
!***FIRST EXECUTABLE STATEMENT  ZQCBI
      IF ( Kprint>=2 ) THEN
        WRITE (Lun,99001)
99001   FORMAT (' QUICK CHECK ROUTINE FOR THE I BESSEL FUNCTION FROM ','ZBESI'/)
      ENDIF
!-----------------------------------------------------------------------
!     Set parameters related to machine constants.
!     TOL is the approximate unit roundoff limited to 1.0D-18.
!     ELIM is the approximate exponential over- and underflow limit.
!     exp(-ELIM).lt.exp(-ALIM)=exp(-ELIM)/TOL    and
!     exp(ELIM).gt.exp(ALIM)=exp(ELIM)*TOL       are intervals near
!     underflow and overflow limits where scaled arithmetic is done.
!     RL is the lower boundary of the asymptotic expansion for large Z.
!     DIG = number of base 10 digits in TOL = 10**(-DIG).
!     FNUL is the lower boundary of the asymptotic series for large FNU.
!-----------------------------------------------------------------------
      r1m4 = D1MACH(4)
      tol = MAX(r1m4,1.0D-18)
      atol = 100.0D0*tol
      aa = -LOG10(r1m4)
      k1 = I1MACH(12)
      k2 = I1MACH(13)
      r1m5 = D1MACH(5)
      k = MIN(ABS(k1),ABS(k2))
      elim = 2.303D0*(k*r1m5-3.0D0)
      ab = aa*2.303D0
      alim = elim + MAX(-ab,-41.45D0)
      dig = MIN(aa,18.0D0)
      fnul = 10.0D0 + 6.0D0*(dig-3.0D0)
      rl = 1.2D0*dig + 3.0D0
      slak = 3.0D0 + 4.0D0*(-LOG10(tol)-7.0D0)/11.0D0
      slak = MAX(slak,3.0D0)
      ertol = tol*10.0D0**slak
      rm = 0.5D0*(alim+elim)
      rm = MIN(rm,200.0D0)
      rm = MAX(rm,rl+10.0D0)
      r2 = MIN(rm,fnul)
      r1 = 2.0D0*SQRT(fnul+1.0D0)
      IF ( Kprint>=2 ) THEN
        WRITE (Lun,99002)
99002   FORMAT (' PARAMETERS'/5X,'TOL ',8X,'ELIM',8X,'ALIM',8X,'RL  ',8X,'FNUL',
     &          8X,'DIG')
        WRITE (Lun,99003) tol , elim , alim , rl , fnul , dig
99003   FORMAT (1X,6D12.4/)
      ENDIF
!-----------------------------------------------------------------------
!     Set other constants needed in the tests.
!-----------------------------------------------------------------------
      zzr = 1.0D0/tol
      coner = 1.0D0
      conei = 0.0D0
      hpi = 2.0D0*ATAN(1.0D0)
      pi = hpi + hpi
!-----------------------------------------------------------------------
!     Generate angles for construction of complex Z to be used in tests.
!-----------------------------------------------------------------------
!     KDO(K), K = 1,IL  determines which of the IL angles in -PI to PI
!     are used to compute values of Z.
!       KDO(K) = 0  means that the index K will be used for one or two
!                   values of Z, depending on the choice of KEPS(K)
!              = 1  means that the index K and the corresponding angle
!                   will be skipped
!     KEPS(K), K = 1,IL determines which of the angles get incremented
!     up and down to put values of Z in regions where different
!     formulae are used.
!       KEPS(K)  = 0  means that the angle will be used without change
!                = 1  means that the angle will be incremented up and
!                   down by EPS
!     The angles to be used are stored in the T(I) array, I = 1,ITL.
!-----------------------------------------------------------------------
      IF ( MQC/=2 ) THEN
        nl = 2
        il = 5
        DO i = 1 , il
          keps(i) = 0
          kdo(i) = 0
        ENDDO
      ELSE
        nl = 4
        il = 13
        DO i = 1 , il
          kdo(i) = 0
          keps(i) = 0
        ENDDO
        kdo(2) = 1
        kdo(6) = 1
        kdo(8) = 1
        kdo(12) = 1
        keps(3) = 1
        keps(4) = 1
        keps(5) = 1
        keps(9) = 1
        keps(10) = 1
        keps(11) = 1
      ENDIF
      i = 2
      eps = 0.01D0
      film = il - 1
      t(1) = -pi + eps
      DO k = 2 , il
        IF ( kdo(k)==0 ) THEN
          t(i) = pi*(-il+2*k-1)/film
          IF ( keps(k)/=0 ) THEN
            ts = t(i)
            t(i) = ts - eps
            i = i + 1
            t(i) = ts + eps
          ELSE
            i = i + 1
          ENDIF
        ENDIF
      ENDDO
      itl = i - 1
!-----------------------------------------------------------------------
!     Test values of Z in -PI.lt.arg(Z).le.PI near formula boundaries.
!-----------------------------------------------------------------------
      IF ( Kprint>=2 ) THEN
        WRITE (Lun,99004)
99004   FORMAT (' CHECKS ACROSS FORMULA BOUNDARIES')
      ENDIF
      lflg = 0
      DO icase = 1 , 6
        DO kode = 1 , 2
          DO n = 1 , nl
            n1 = n + 2
!-----------------------------------------------------------------------
!     Set values for R = magnitude of Z and for FNU to test computation
!     methods for the various regions of the (Z,FNU) plane.
!-----------------------------------------------------------------------
            DO ir = 1 , 3
!------------ switch (icase)
              SELECT CASE (icase)
              CASE (2)
                r = (rl*(3-ir)+r2*(ir-1))/2.0D0
                gnu = SQRT(r+r) - 0.2D0 - (n-1)
                fnu = MAX(0.0D0,gnu)
              CASE (3)
                IF ( r2>=rm ) GOTO 100
                r = (r2*(3-ir)+rm*(ir-1))/2.0D0
                gnu = SQRT(r+r) - 0.2D0 - (n-1)
                fnu = MAX(0.0D0,gnu)
              CASE (4)
                IF ( r1>=rl ) GOTO 100
                r = (r1*(3-ir)+rl*(ir-1))/2.0D0
                fnu = fnul - 0.2D0 - (n-1)
              CASE (5)
                r = (rl*(3-ir)+r2*(ir-1))/2.0D0
                fnu = fnul - 0.2D0 - (n-1)
              CASE (6)
                IF ( r2>=rm ) GOTO 100
                r = (r2*(3-ir)+rm*(ir-1))/2.0D0
                fnu = fnul - 0.2D0 - (n-1)
              CASE DEFAULT
                r = (2.0D0*(3-ir)+rl*(ir-1))/2.0D0
                gnu = r*r/4.0D0 - 0.2D0 - (n-1)
                fnu = MAX(0.0D0,gnu)
              END SELECT
!------------ end switch
              DO it = 1 , itl
                ct = COS(t(it))
                st = SIN(t(it))
                IF ( ABS(ct)<atol ) ct = 0.0D0
                IF ( ABS(st)<atol ) st = 0.0D0
                zr = r*ct
                zi = r*st
                CALL ZBESI(zr,zi,fnu,kode,n1,yr,yi,nz1,ierr)
                IF ( nz1==0 ) THEN
!-----------------------------------------------------------------------
!     Compare values from ZBESI with values from ZWRSK, an alternative
!     method for calculating the complex Bessel I function.
!-----------------------------------------------------------------------
                  znr = zr
                  zni = zi
                  IF ( zr>=0.0D0 ) THEN
                    CALL ZWRSK(znr,zni,fnu,kode,n,wr,wi,nz2,ckr,cki,tol,elim,
     &                         alim)
                    IF ( nz2/=0 ) CYCLE
                  ELSE
                    znr = -zr
                    zni = -zi
                    inu = INT(fnu)
                    arg = (fnu-inu)*pi
                    IF ( zi<0.0D0 ) arg = -arg
                    carg = COS(arg)
                    sarg = SIN(arg)
                    csgnr = carg
                    csgni = sarg
                    IF ( MOD(inu,2)==1 ) THEN
                      csgnr = -csgnr
                      csgni = -csgni
                    ENDIF
                    CALL ZWRSK(znr,zni,fnu,kode,n,wr,wi,nz2,ckr,cki,tol,elim,
     &                         alim)
                    IF ( nz2/=0 ) CYCLE
                    DO i = 1 , n
                      str = wr(i)*csgnr - wi(i)*csgni
                      wi(i) = wr(i)*csgni + wi(i)*csgnr
                      wr(i) = str
                      csgnr = -csgnr
                      csgni = -csgni
                    ENDDO
                  ENDIF
                  mflg = 0
                  DO i = 1 , n
                    ab = fnu + i - 1
                    aa = MAX(2.0D0,ab)
                    ztr = wr(i)
                    zti = wi(i)
                    IF ( ABS(ztr)>1.0D0.OR.ABS(zti)>1.0D0 ) THEN
                      zscr = tol
                    ELSE
                      zscr = zzr
!------------------ ZZR = 1.0D0/TOL
                    ENDIF
                    cwr = wr(i)*zscr
                    cwi = wi(i)*zscr
                    cyr = yr(i)*zscr
                    cyi = yi(i)*zscr
                    str = cyr - cwr
                    sti = cyi - cwi
                    er = ZABS(str,sti)
                    aw = ZABS(cwr,cwi)
                    IF ( aw==0.0D0 ) THEN
                      er = ZABS(yr(i),yi(i))
                    ELSEIF ( zr/=0.0D0 ) THEN
                      er = er/aw
                    ELSEIF ( ABS(zi)<aa ) THEN
                      er = er/aw
                    ELSE
                      str = yr(i) - wr(i)
                      sti = yi(i) - wi(i)
                      er = ZABS(str,sti)
                    ENDIF
                    aer(i) = er
                    IF ( er>ertol ) mflg = 1
                  ENDDO
!-----------------------------------------------------------------------
!     Write failure reports for KPRINT.ge.2 and KPRINT.ge.3
!-----------------------------------------------------------------------
                  IF ( mflg/=0 ) THEN
                    IF ( lflg==0 ) THEN
                      IF ( Kprint>=2 ) THEN
                        WRITE (Lun,99005) ertol
99005                   FORMAT (/' CASES WHICH UNDERFLOW OR VIOLATE THE ',
     &                          'RELATIVE ERROR TEST'/' WITH ERTOL = ',D12.4/)
                        WRITE (Lun,99006)
99006                   FORMAT (' INPUT TO ZBESI   Z, FNU, KODE, N')
                      ENDIF
                      IF ( Kprint>=3 ) THEN
                        WRITE (Lun,99007)
99007                   FORMAT (' ERROR TEST ON RESULTS FROM ZBESI AND ',
     &                          'ZWRSK   AER(K)')
                        WRITE (Lun,99008)
99008                   FORMAT (' RESULTS FROM ZBESI   NZ1, Y(KK)'/,
     &                          ' RESULTS FROM ZWRSK   NZ2, W(KK)')
                        WRITE (Lun,99009)
99009                   FORMAT (' TEST CASE INDICES   IT, IR, ICASE'/)
                      ENDIF
                    ENDIF
                    lflg = lflg + 1
                    IF ( Kprint>=2 ) THEN
                      WRITE (Lun,99010) zr , zi , fnu , kode , n
99010                 FORMAT ('   INPUT:    Z=',2D12.4,4X,'FNU=',D12.4,4X,
     &                        'KODE=',I3,4X,'N=',I3)
                    ENDIF
                    IF ( Kprint>=3 ) THEN
                      WRITE (Lun,99011) (aer(k),k=1,n)
99011                 FORMAT ('   ERROR:  AER(K)=',4D12.4)
                      kk = MAX(nz1,nz2) + 1
                      kk = MIN(n,kk)
                      WRITE (Lun,99012) nz1 , yr(kk) , yi(kk) , nz2 , wr(kk) , 
     &                                  wi(kk)
99012                 FORMAT (' RESULTS:  NZ1=',I3,4X,'Y(KK)=',2D12.4,/11X,
     &                        'NZ2=',I3,4X,'W(KK)=',2D12.4)
                      WRITE (Lun,99013) it , ir , icase
99013                 FORMAT ('    CASE:   IT=',I3,4X,'IR=',I3,4X,'ICASE=',I3/)
                    ENDIF
                  ENDIF
                ENDIF
              ENDDO
            ENDDO
          ENDDO
        ENDDO
 100  ENDDO
      IF ( Kprint>=2 ) THEN
        IF ( lflg==0 ) THEN
          WRITE (Lun,99019)
        ELSE
          WRITE (Lun,99014) lflg
99014     FORMAT (' ***',I5,' FAILURE(S) FOR ZBESI CHECKS NEAR FORMULA ',
     &            'BOUNDARIES')
        ENDIF
      ENDIF
!
!
      iprnt = 0
      IF ( MQC/=1 ) THEN
!-----------------------------------------------------------------------
!     Checks near underflow limits on series(I=1) and uniform
!     asymptotic expansion(I=2)
!     Compare 1/Z with I(Z,FNU)*K(Z,FNU+1) + I(Z,FNU+1)*K(Z,FNU) and
!     report cases for which the relative error is greater than ERTOL.
!-----------------------------------------------------------------------
        IF ( Kprint>=2 ) THEN
          WRITE (Lun,99015)
99015     FORMAT (/' CHECKS NEAR UNDERFLOW AND OVERFLOW LIMITS'/)
        ENDIF
        zr = 1.4D0
        zi = 1.4D0
        kode = 1
        n = 20
        DO i = 1 , 2
          fnu = 10.2D0
          DO
!-----------------------------------------------------------------------
!       Adjust FNU by repeating until 0.lt.NZI.lt.10
!-----------------------------------------------------------------------
            CALL ZBESI(zr,zi,fnu,kode,n,yr,yi,nzi,ierr)
            IF ( nzi==0 ) THEN
              fnu = fnu + 5.0D0
              CYCLE
            ELSEIF ( nzi>=10 ) THEN
              fnu = fnu - 1.0D0
              CYCLE
            ENDIF
!------ End repeat
            CALL ZBESK(zr,zi,fnu,kode,2,wr,wi,nzk,ierr)
            CALL ZDIV(coner,conei,zr,zi,ztr,zti)
            cyr = wr(1)*yr(2) - wi(1)*yi(2)
            cyi = wr(1)*yi(2) + wi(1)*yr(2)
            cwr = wr(2)*yr(1) - wi(2)*yi(1)
            cwi = wr(2)*yi(1) + wi(2)*yr(1)
            cwr = cwr + cyr - ztr
            cwi = cwi + cyi - zti
            er = ZABS(cwr,cwi)/ZABS(ztr,zti)
!-----------------------------------------------------------------------
!     Write failure reports for KPRINT.ge.2 and KPRINT.ge.3
!-----------------------------------------------------------------------
            IF ( er>=ertol ) THEN
              IF ( iprnt==0 ) THEN
                IF ( Kprint>=2 ) WRITE (Lun,99020)
                IF ( Kprint>=3 ) WRITE (Lun,99021)
              ENDIF
              iprnt = 1
              IF ( Kprint>=2 ) WRITE (Lun,99022) zr , zi , fnu , kode , n
              IF ( Kprint>=3 ) THEN
                WRITE (Lun,99023) ztr , zti , cwr + cyr , cwi + cyi
                WRITE (Lun,99024) er
              ENDIF
            ENDIF
            rlt = rl + rl
            zr = rlt
            zi = 0.0D0
            EXIT
          ENDDO
        ENDDO
!-----------------------------------------------------------------------
!     Check near overflow limits
!     Compare 1/Z with I(Z,FNU)*K(Z,FNU+1) + I(Z,FNU+1)*K(Z,FNU) and
!     report cases for which the relative error is greater than ERTOL.
!-----------------------------------------------------------------------
        zr = elim
        zi = 0.0D0
        fnu = 0.0D0
        DO
!-----------------------------------------------------------------------
!     Adjust FNU by repeating until NZK.lt.10
!     N = 20 set before DO 280 loop
!-----------------------------------------------------------------------
          CALL ZBESK(zr,zi,fnu,kode,n,yr,yi,nzk,ierr)
          IF ( nzk>=10 ) THEN
            IF ( nzk==n ) THEN
              fnu = fnu + 3.0D0
            ELSE
              fnu = fnu + 2.0D0
            ENDIF
            CYCLE
          ENDIF
!---- End repeat
          gnu = fnu + (n-2)
          CALL ZBESI(zr,zi,gnu,kode,2,wr,wi,nzi,ierr)
          CALL ZDIV(coner,conei,zr,zi,ztr,zti)
          cyr = yr(n-1)*wr(2) - yi(n-1)*wi(2)
          cyi = yr(n-1)*wi(2) + yi(n-1)*wr(2)
          cwr = yr(n)*wr(1) - yi(n)*wi(1)
          cwi = yr(n)*wi(1) + yi(n)*wr(1)
          cwr = cwr + cyr - ztr
          cwi = cwi + cyi - zti
          er = ZABS(cwr,cwi)/ZABS(ztr,zti)
          IF ( er>=ertol ) THEN
            IF ( iprnt==0 ) THEN
              IF ( Kprint>=2 ) WRITE (Lun,99020)
              IF ( Kprint>=3 ) WRITE (Lun,99021)
            ENDIF
            iprnt = 1
            IF ( Kprint>=2 ) WRITE (Lun,99022) zr , zi , fnu , kode , n
            IF ( Kprint>=3 ) THEN
              WRITE (Lun,99023) ztr , zti , cwr + cyr , cwi + cyi
              WRITE (Lun,99024) er
            ENDIF
          ENDIF
          IF ( Kprint>=2 ) THEN
            IF ( iprnt==0 ) THEN
              WRITE (Lun,99019)
! 99986   FORMAT (' QUICK CHECKS OK')
            ELSE
              WRITE (Lun,99016)
99016         FORMAT (' ***',5X,'FAILURE(S) FOR ZBESI NEAR UNDERFLOW AND ',
     &                'OVERFLOW LIMITS')
            ENDIF
          ENDIF
          EXIT
        ENDDO
      ENDIF
      Ipass = 0
      IF ( iprnt==0.AND.lflg==0 ) Ipass = 1
      IF ( Ipass==1.AND.Kprint>=2 ) THEN
        WRITE (Lun,99017)
99017   FORMAT (/' ****** ZBESI  PASSED ALL TESTS  ******'/)
      ENDIF
      IF ( Ipass==0.AND.Kprint>=1 ) THEN
        WRITE (Lun,99018)
99018   FORMAT (/' ****** ZBESI  FAILED SOME TESTS ******'/)
      ENDIF
99019 FORMAT (' QUICK CHECKS OK')
99020 FORMAT (' INPUT TO ZBESI   Z, FNU, KODE, N')
99021 FORMAT (' COMPARE 1/Z WITH WRONSKIAN(ZBESI(Z,FNU),','ZBESK(Z,FNU))'/)
99022 FORMAT (' INPUT: Z=',2D12.4,3X,'FNU=',D12.4,3X,'KODE=',I3,3X,'N=',I3)
99023 FORMAT (' RESULTS:',15X,'1/Z=',2D12.4/10X,'WRON(ZBESI,ZBESK)=',2D12.4)
99024 FORMAT (' RELATIVE ERROR:',9X,'ER=',D12.4/)
      END SUBROUTINE ZQCBI
