!** SLADOC
PROGRAM SLADOC
  IMPLICIT NONE
  !>
  !***
  !   Retrieve documentation for the SLATEC library.
  !***
  ! **Library:**   (NONE)
  !***
  ! **Category:**  R4
  !***
  ! **Keywords:**  DOCUMENTATION, SLATEC
  !***
  ! **Author:**  Boland, W. Robert, C-8, Los Alamos National Laboratory
  !           Bacon, Barbara A., C-10, Los Alamos National Laboratory
  !***
  ! **Description:**
  !
  !   This program retrieves SLATEC type documentation by routine name.
  !   The search for name can be narrowed by using keyword(s) or
  !   classification category.  The database for this program consists of
  !   four files, generated by another program.  These are
  !
  !   1)  a direct access documentation text file,
  !   2)  a sequential table of routine names, categories, etc.,
  !   3)  a sequential file of keywords and pointers to the routines.
  !   4)  a sequential file of expanded categories and messages.
  !
  !   There are a number of system dependent parameters which the
  !   installer of this program may have to change before compiling,
  !   linking and installing the program.  All parameters are defined in
  !   the records which immediately follow the prologue.  In the
  !   discussion here we refer to the default values which are distributed
  !   with this code;  we give values for several different
  !   machine/operating system configurations.
  !
  !      MXLFN  - the maximum length of a file name to be used.  The value
  !               used is highly system dependent.  Set the value to the
  !               length of longest file name allowed on the system.
  !      FIN    - the name of the input file.  Some typical names are
  !               tty (CTSS), INPUT (NOS), /dev/tty (UNIX) and
  !               SYS$INPUT (VMS).
  !      FTBL   - the name of the input sequential file which contains
  !               the table of routine names, categories, etc.
  !      FCAT   - the name of the input file which contains the category
  !               information.
  !      FKWD   - the name of the input sequential file which contains
  !               the table of keywords and routine names.
  !      FDAF   - the name of the input direct access file which contains
  !               the documentation modules.
  !      FOUT   - the name of the output file.  Some typical names are
  !               tty (CTSS), OUTPUT (NOS), /dev/tty (UNIX) and
  !               SYS$OUTPUT (VMS).
  !      FERR   - the name of the file which is to contain error
  !               information.  All errors are processed by the XERMSG
  !               package.  Some typical names are  tty (CTSS),
  !               OUTPUT (NOS), /dev/tty (UNIX) and SYS$OUTPUT (VMS).
  !
  !      MXLRN  - the maximum length of a routine name.  For most Fortran
  !               based libraries, including SLATEC, the value must be at
  !               least 6.  If your library uses names longer than 6, you
  !               should set the value of this parameter to the maximum
  !               length.
  !      MXNRN  - the maximum number of routine names which are in the
  !               library.
  !      MXLCAT - the maximum length of a category number.  For the GAMS
  !               classification scheme which is used by the SLATEC
  !               Collection, the value is 10.
  !      MXNCAT - the maximum number of categories in the entire library.
  !      MXNKWD - the maximum number of keyword phrases in the entire
  !               library.
  !      MXNCL  - the maximum number of lines in the GAMS classification
  !               file.
  !      KMAXI  - the maximum number of characters in a keyword phrase.
  !      KMAXJ  - the maximum number of keywords in a subroutine.
  !      LLN    - the number of characters in an input line.
  !
  !   On some systems, it may be necessary to remove or comment out the
  !   REWIND (UNIT=LU5, ERR=...) statements to avoid program abort.  It
  !   has been found that on most systems these REWIND statements have no
  !   effect and can be either "active" or commented out;  they have been
  !   incorporated into the code for those few systems which interpret a
  !   null line as an end-of-file signal.
  !
  !***
  ! **References:**  Guide to the SLATEC Common Mathematical Library.
  !***
  ! **Routines called:**  I1MACH, XERMSG

  !* REVISION HISTORY  (YYMMDD)
  !   870819  DATE WRITTEN
  !   880325  REVISION DATE from Version 3.2
  !   891215  Prologue converted to Version 4.0 format.  (BAB)
  !   901024  Added code to check array bounds when reading files.  (BAB)
  !   910325  Changed A6 format used when printing routine name list to an
  !           A format.  (WRB)
  !   920825  Added view option.  (BKS, WRB)
  !   920911  Declarations section restructured.  (WRB)
  
  !
  !     System dependent parameter definitions.
  !
  INTEGER MXLFN
  PARAMETER (MXLFN=32)
  CHARACTER(MXLFN) :: FIN, FCAT, FDAF, FKWD, FTBL, FLIS, FOUT, FERR
  CHARACTER(MXLFN) :: temp
  PARAMETER (FIN='/dev/tty',FCAT='slacat',FDAF='sladaf',FKWD='slakwd',&
    FTBL='slatbl',FLIS='slalis',FOUT='/dev/tty',FERR='/dev/tty')
  !
  !     Library dependent parameter definitions.
  !
  INTEGER MXLCAT, MXNCAT, MXLRN, MXNCL, MXNRN, MXLKAT
  PARAMETER (MXLKAT=7)
  PARAMETER (MXLCAT=10,MXLRN=6,MXNRN=1900)
  PARAMETER (MXNCAT=750,MXNCL=750)
  CHARACTER(MXLCAT) :: tclass(MXNCAT), tcl
  INTEGER iptr(MXNCAT), jptr(MXNCAT), kptr(MXNCAT)
  CHARACTER(80) :: stmts(MXNCL)
  INTEGER LUTIL, LLIB
  PARAMETER (LUTIL=6,LLIB=6)
  CHARACTER(LUTIL) :: UTIL
  CHARACTER(LLIB) :: LIB
  PARAMETER (UTIL='SLADOC',LIB='SLATEC')
  INTEGER LLN
  PARAMETER (LLN=80)
  !
  !     Other declarations.
  !
  INTEGER ierror, ifind, ii, ij, il, ilen, in, inext, ir, irec, &
    istart, istmt, itemp, jcl, jj, lb2, leng, lftbl, lkats, &
    ll, ls, lt2, ltcl, ncc, nerr, nlines, npd, ntkwd, ntry, &
    num
  CHARACTER(LLN) :: line, linesv
  !
  CHARACTER(MXLRN) :: rtname(MXNRN), rtnin
  CHARACTER(MXLRN) :: cname(MXNRN/2)
  !
  INTEGER LCAT, LCATLS, MLCAT, SEVEN
  PARAMETER (LCAT=6,LCATLS=72,MLCAT=MXLCAT-LCAT,SEVEN=7)
  CHARACTER(MXLCAT) :: cat(MXNRN), kat
  CHARACTER(MXLKAT) :: kats
  !
  !     KMAXI - maximum length of a keyword phrase.
  !     MXKWDS - maximum number of keyword phrases
  !
  INTEGER KMAXI, MXKWDS
  PARAMETER (KMAXI=60,MXKWDS=500)
  CHARACTER(KMAXI) :: kwrd
  CHARACTER(KMAXI) :: tkwd(MXKWDS)
  !
  !     IPTRL - table of pointers associated with the keyword phrases.
  !     IPTRR - table of pointers to the routines containing the
  !             keyword phrases.
  !
  INTEGER iptrl(10*MXKWDS), iptrr(10*MXKWDS)
  !
  INTEGER LU13, LU14, LU5, LU6, LU17, LU18, LU19
  PARAMETER (LU13=13,LU14=14,LU5=5,LU6=6,LU17=17,LU18=18,LU19=19)
  CHARACTER(MXLFN) :: fname, fnamsv, fn
  LOGICAL llu13, llu18, llu19, llu14
  LOGICAL found, lexist
  !
  !     IS  - table of pointers to the record in file FDAF containing
  !           the subprogram statement.
  !     IE  - table of pointers to the record in file FDAF containing
  !           the "END PROLOGUE" statement.
  !     IPS - table of pointers to the record in file FDAF containing
  !           starting line of the "PURPOSE" section.
  !     IPE - table of pointers to the record in file FDAF containing
  !           ending line of the "PURPOSE" section.
  !
  INTEGER is(MXNRN), ie(MXNRN), ips(MXNRN), ipe(MXNRN)
  INTEGER i, info, j, lb, lt
  !
  CHARACTER :: input1
  CHARACTER(24) :: fmt1
  CHARACTER(LUTIL+LLIB+54) :: fmt2
  CHARACTER(80) :: msg
  CHARACTER form*25
  CHARACTER forma*60
  INTEGER IALPHA
  PARAMETER (IALPHA=26)
  INTEGER I1(IALPHA), I2(IALPHA), I3(IALPHA), LMSg(IALPHA)
  CHARACTER(7) :: CLAss(IALPHA)
  !
  !     Variables used in the browsing mode.
  !
  INTEGER pgsz, low, high
  COMMON /CATGRY/ I1, I2, I3, LMSg
  COMMON /KLASS / CLAss
  !
  !     External functions.
  !
  INTEGER FIND, LENSTR, MINOR
  CHARACTER(10) :: CVTCAT
  EXTERNAL CVTCAT, FIND, LENSTR, MINOR
  !
  !     Intrinsic functions.
  !
  INTRINSIC ABS, INDEX, MAX, MIN
  !
  !     DATA statement definitions.
  !
  DATA llu13/.FALSE./, fnamsv/' '/
  !
  !     These three variables indicate whether the information from
  !     the files FCAT, FTBL and FKWD have been read in.  The files
  !     are read only once and then only if the information is needed.
  !
  DATA llu18, llu19, llu14/.FALSE., .FALSE., .FALSE./
  !
  DATA forma(1:60) /'(/,1X,A,''category does not exist in this library.'',/)'/
  !* FIRST EXECUTABLE STATEMENT  SLADOC
  WRITE (UNIT=msg,FMT=99039) LCAT, MLCAT
  fmt1 = '(1X, A'//msg(1:2)//', '//msg(3:4)//'X, A, 3I8)'
  fname = FLIS
  !
  !     OPEN (UNIT=LU5, FILE=FIN, STATUS='UNKNOWN', IOSTAT=INFO,
  !    +      FORM='FORMATTED')
  !     IF (INFO .NE. 0) THEN
  !       MSG = 'Failure in attempting to open ' // FIN // ' for input'
  !       NERR = 1
  !       GO TO 520
  !     ENDIF
  !
  !     OPEN (UNIT=LU6, FILE=FOUT, STATUS='UNKNOWN', IOSTAT=INFO,
  !    +      FORM='FORMATTED')
  !     IF (INFO .NE. 0) THEN
  !       MSG = ' Failure in attempting to open ' // FOUT // ' for output'
  !       NERR = 1
  !       GO TO 520
  !     ENDIF
  !
  !     Check to see if the input files to be used are in the user's
  !     local space.  If so, use them instead of the ones on the
  !     system.
  !
  temp = FDAF
  ilen = LENSTR(temp)
  DO i = ilen, 1, -1
    IF ( temp(i:i)=='/' ) THEN
      INQUIRE (FILE=temp(i+1:ilen),EXIST=lexist)
      IF ( lexist ) temp(1:ilen-i) = temp(i+1:ilen)
      EXIT
    ENDIF
  ENDDO
  OPEN (UNIT=LU17,FILE=temp,STATUS='OLD',ACCESS='DIRECT',FORM='FORMATTED',&
    RECL=LLN,IOSTAT=info)
  IF ( info/=0 ) THEN
    msg = ' Failure in attempting to open '//temp
    nerr = 1
    GOTO 700
  ENDIF
  temp = FCAT
  ilen = LENSTR(temp)
  DO i = ilen, 1, -1
    IF ( temp(i:i)=='/' ) THEN
      INQUIRE (FILE=temp(i+1:ilen),EXIST=lexist)
      IF ( lexist ) temp(1:ilen-i) = temp(i+1:ilen)
      EXIT
    ENDIF
  ENDDO
  OPEN (UNIT=LU14,FILE=temp,STATUS='OLD',FORM='FORMATTED',IOSTAT=info)
  IF ( info/=0 ) THEN
    msg = ' Failure in attempting to open '//temp
    nerr = 1
    GOTO 700
  ENDIF
  temp = FKWD
  ilen = LENSTR(temp)
  DO i = ilen, 1, -1
    IF ( temp(i:i)=='/' ) THEN
      INQUIRE (FILE=temp(i+1:ilen),EXIST=lexist)
      IF ( lexist ) temp(1:ilen-i) = temp(i+1:ilen)
      EXIT
    ENDIF
  ENDDO
  OPEN (UNIT=LU19,FILE=temp,STATUS='OLD',FORM='FORMATTED',IOSTAT=info)
  IF ( info/=0 ) THEN
    msg = ' Failure in attempting to open '//temp
    nerr = 1
    GOTO 700
  ENDIF
  temp = FTBL
  ilen = LENSTR(temp)
  DO i = ilen, 1, -1
    IF ( temp(i:i)=='/' ) THEN
      INQUIRE (FILE=temp(i+1:ilen),EXIST=lexist)
      IF ( lexist ) temp(1:ilen-i) = temp(i+1:ilen)
      EXIT
    ENDIF
  ENDDO
  OPEN (UNIT=LU18,FILE=temp,STATUS='OLD',FORM='FORMATTED',IOSTAT=info)
  IF ( info/=0 ) THEN
    msg = ' Failure in attempting to open '//temp
    nerr = 1
    GOTO 700
  ENDIF
  !
  !     Write welcome message.
  !
  fmt2 = '('' Welcome to '//UTIL//', the '//LIB//&
    ' on-line documentation program'' /)'
  WRITE (UNIT=LU6,FMT=fmt2)
  !
  !     Write the complete message showing the commands.
  !
  100  WRITE (UNIT=LU6,FMT=99003)
  !
  !     Write "Ready for your command".
  !
  200  WRITE (UNIT=LU6,FMT=99004)
  REWIND (UNIT=LU5,ERR=300)
  300  READ (UNIT=LU5,FMT=99001,END=400) line
  CALL UPCASE(line,line)
  GOTO 500
  400  line = ' '
  500  leng = LENSTR(line)
  CALL CHARIN(line,leng,2,lb,lt)
  DO
    lb = MAX(lb,1)
    IF ( line(lb:lb)=='L'.OR.line(lb:lb)=='C'.OR.line(lb:lb)=='K'.OR.&
        line(lb:lb)=='X'.OR.line(lb:lb)=='V' ) THEN
      input1 = line(lb:lb)
      !
      !
      IF ( input1=='L' ) THEN
        !
        !         User has requested information on the GAMS classification
        !         scheme.
        !
        IF ( .NOT.llu14 ) THEN
          !
          !           Read in the information from file FCAT.
          !
          READ (UNIT=LU14,FMT=99037) ncc
          IF ( ncc>MXNCAT ) THEN
            msg = 'MXNCAT internal error.  Please contact the consulting office.'
            nerr = 3
            EXIT
          ENDIF
          ncc = ncc - 1
          DO j = 1, ncc
            READ (UNIT=LU14,FMT=99040) iptr(j), jptr(j), kptr(j), &
              tclass(j)
          ENDDO
          READ (UNIT=LU14,FMT=99038) kptr(ncc+1)
          istmt = kptr(ncc+1)
          IF ( istmt>MXNCL ) THEN
            msg = 'MXNCL internal error.  Please contact the consulting office.'
            nerr = 4
            EXIT
          ENDIF
          READ (UNIT=LU14,FMT=99001) (stmts(i),i=1,istmt)
          llu14 = .TRUE.
          CLOSE (LU14)
        ENDIF
        ls = lt + lb
        CALL CHARIN(line(ls:ls),leng,2,lb,lt)
        IF ( lt==0 ) THEN
          !
          !           CASE I.  l <cr>    or    l<cr>
          !
          !           Print out the major categories.
          !
          WRITE (UNIT=LU6,FMT=99007)
          kat = tclass(1)
          ifind = FIND(tclass,ncc,kat)
          DO
            IF ( ifind>0 ) THEN
              !
              I1(1) = iptr(ifind)
              I3(1) = kptr(ifind)
              tcl = ' '
              CALL UNDOCL(tclass(ifind),tcl)
              LMSg(1) = kptr(ifind+1) - kptr(ifind)
              ifind = I1(1)
              ltcl = LENSTR(tcl)
              WRITE (UNIT=form,FMT=99041) ltcl
              istart = I3(1)
              DO jcl = 1, LMSg(1)
                WRITE (UNIT=LU6,FMT=form) tcl(1:ltcl), stmts(istart)&
                  (1:LENSTR(stmts(istart)))
                istart = istart + 1
                tcl = ' '
              ENDDO
              CYCLE
            ENDIF
            !
            !           Ask the user to input a MAJOR category he/she wishes to
            !           explore.
            !
            WRITE (UNIT=LU6,FMT=99008)
            REWIND (UNIT=LU5,ERR=505)
            EXIT
          ENDDO
          505          READ (UNIT=LU5,FMT=99001,END=100) line
          CALL UPCASE(line,line)
          !
          !           Remove leading blanks from the input line.
          !
          CALL RBLNKS(line,linesv)
          kat = linesv(1:1)
          kats = kat(1:7)
          DO
            !
            !           KATS is the unexpanded version of the category name.
            !           KAT  is the expanded version of the category name.
            !           E.G.,  If (KAT) = H02A01A01, then (KATS) = H2A1A1.
            !
            ierror = MINOR(kat,kats,ncc,tclass,iptr,jptr,kptr,ntry)
            IF ( ierror/=0 ) THEN
              WRITE (UNIT=LU6,FMT=99015) kats
              GOTO 200
            ELSE
              !
              !             The first entry is a repeat of the category information
              !             he/she now wishes to explore.
              !
              lkats = LENSTR(kats)
              WRITE (UNIT=form,FMT=99041) lkats
              istart = I3(1)
              tcl = kats
              DO jcl = 1, LMSg(1)
                WRITE (UNIT=LU6,FMT=form) tcl(1:lkats), stmts(istart)&
                  (1:LENSTR(stmts(istart)))
                istart = istart + 1
                tcl = ' '
              ENDDO
            ENDIF
            IF ( ntry>1 ) THEN
              DO in = 2, ntry
                tcl = CLAss(in)
                ltcl = LENSTR(tcl)
                WRITE (UNIT=form,FMT=99041) ltcl
                istart = I3(in)
                DO jcl = 1, LMSg(in)
                  WRITE (UNIT=LU6,FMT=form) tcl(1:ltcl), stmts(istart)&
                    (1:LENSTR(stmts(istart)))
                  istart = istart + 1
                  tcl = ' '
                ENDDO
              ENDDO
              WRITE (UNIT=LU6,FMT=99009)
              line = ' '
              REWIND (UNIT=LU5,ERR=506)
              506              READ (UNIT=LU5,FMT=99001,END=200) line
              IF ( LENSTR(line)==0 ) GOTO 200
              CALL RBLNKS(line,linesv)
              leng = LENSTR(linesv)
              CALL UPCASE(linesv(1:leng),kats)
              kat = CVTCAT(kats(1:leng))
            ELSE
              WRITE (UNIT=LU6,FMT=99010) kats
              kats = ' '
              WRITE (UNIT=LU6,FMT=99011)
              GOTO 200
            ENDIF
          ENDDO
        ELSE
          !
          !           CASE II.    l,cat <cr>
          !
          ll = ls - 1 + lb
          IF ( (leng-ll+1)>MXLKAT ) THEN
            !
            !             A longer category has been requested than permitted.
            !
            WRITE (UNIT=form,FMT=99039) leng - ll + 1
            forma(10:11) = form(1:2)
            WRITE (UNIT=LU6,FMT=forma) line(ll:leng)
            GOTO 200
          ENDIF
          kats = line(ll:leng)
          leng = LENSTR(kats)
          kat = CVTCAT(kats(1:leng))
          DO
            !
            !           KATS is the unexpanded version of the category name.
            !           KAT  is the expanded version of the category name.
            !           E.G.,  If (KAT) = H02A01A01, then  (KATS) = H2A1A1.
            !
            ierror = MINOR(kat,kats,ncc,tclass,iptr,jptr,kptr,ntry)
            IF ( ierror/=0 ) THEN
              !
              !             Category not found in this library.
              !
              WRITE (UNIT=LU6,FMT=99015) kats
              GOTO 200
            ELSE
              !
              !             The first entry is a repeat of the category information
              !             he/she now wishes to explore.
              !
              lkats = LENSTR(kats)
              WRITE (UNIT=form,FMT=99041) lkats
              istart = I3(1)
              tcl = kats
              DO jcl = 1, LMSg(1)
                WRITE (UNIT=LU6,FMT=form) tcl(1:lkats), stmts(istart)&
                  (1:LENSTR(stmts(istart)))
                istart = istart + 1
                tcl = ' '
              ENDDO
            ENDIF
            IF ( ntry>1 ) THEN
              DO in = 2, ntry
                tcl = CLAss(in)
                ltcl = LENSTR(tcl)
                WRITE (UNIT=form,FMT=99041) ltcl
                istart = I3(in)
                DO jcl = 1, LMSg(in)
                  WRITE (UNIT=LU6,FMT=form) tcl(1:ltcl), stmts(istart)&
                    (1:LENSTR(stmts(istart)))
                  istart = istart + 1
                  tcl = ' '
                ENDDO
              ENDDO
              WRITE (UNIT=LU6,FMT=99009)
              line = ' '
              REWIND (UNIT=LU5,ERR=508)
              508              READ (UNIT=LU5,FMT=99001,END=200) line
              IF ( LENSTR(line)==0 ) GOTO 200
              CALL RBLNKS(line,linesv)
              leng = LENSTR(linesv)
              CALL UPCASE(linesv(1:leng),kats)
              kat = CVTCAT(kats(1:leng))
            ELSE
              WRITE (UNIT=LU6,FMT=99010) kats
              kats = ' '
              WRITE (UNIT=LU6,FMT=99011)
              GOTO 200
            ENDIF
          ENDDO
        ENDIF
        !
      ELSEIF ( input1=='K' ) THEN
        !
        !         User is looking for routine names by keyword phrase.
        !
        IF ( .NOT.llu19 ) THEN
          !
          !           Read in the information from file FKWD.
          !
          READ (UNIT=LU19,FMT=99037) ntkwd
          WRITE (UNIT=form,FMT=99042) KMAXI
          IF ( ntkwd>MXKWDS ) THEN
            msg = 'MXKWDS internal error.  Please contact the consulting office.'
            nerr = 5
            EXIT
          ENDIF
          READ (UNIT=LU19,FMT=form) (tkwd(j),j=1,ntkwd)
          !
          inext = 0
          DO
            READ (UNIT=LU19,FMT=99001,END=510) linesv
            IF ( inext>=10*MXKWDS ) THEN
              msg = 'MXKWDS internal error.  Please contact the consulting office.'
              nerr = 6
              GOTO 700
            ENDIF
            READ (UNIT=linesv,FMT=99037) iptrl(inext+1), iptrr(inext+1)
            inext = inext + 1
          ENDDO
          510          llu19 = .TRUE.
          CLOSE (LU19)
        ENDIF
        IF ( .NOT.llu18 ) THEN
          !
          !           Read in the information from file FTBL.
          !
          lftbl = 0
          DO
            lftbl = lftbl + 1
            READ (UNIT=LU18,FMT=99001,END=515) linesv
            IF ( lftbl>MXNRN ) THEN
              msg = 'MXNRN internal error.  Please contact the consulting office.'
              nerr = 2
              GOTO 700
            ENDIF
            READ (UNIT=linesv,FMT=99017) cat(lftbl), rtname(lftbl), &
              is(lftbl), ie(lftbl), ips(lftbl), ipe(lftbl)
          ENDDO
          515          lftbl = lftbl - 1
          llu18 = .TRUE.
          CLOSE (LU18)
        ENDIF
        ls = lt + lb
        CALL CHARIN(line(ls:ls),leng,2,lb,lt)
        IF ( lt==0 ) THEN
          !
          !           Ask the user to input the keyword phrase he/she wishes
          !           to find.
          !
          WRITE (UNIT=LU6,FMT=99016)
          REWIND (UNIT=LU5,ERR=520)
          520          READ (UNIT=LU5,FMT=99001,END=525) line
          CALL UPCASE(line,line)
          GOTO 530
          525          line = ' '
          530          lb = 1
          lt = LENSTR(line)
          IF ( lt==0 ) THEN
            WRITE (UNIT=LU6,FMT=99020)
            GOTO 100
          ENDIF
          kwrd = line(lb:lt)
        ELSE
          kwrd = line(ls-1+lb:leng)
        ENDIF
        !
        !         The keyword phrase was found on the original command line.
        !
        ilen = LENSTR(kwrd)
        found = .FALSE.
        DO i = 1, ntkwd
          ij = INDEX(tkwd(i),kwrd(1:ilen))
          IF ( ij/=0 ) THEN
            found = .TRUE.
            !
            !             We have found this keyword in one of the phrases.
            !
            ij = i
            in = 1
            DO
              il = iptrl(ij)
              ir = iptrr(ij)
              !
              !             Collect together in CNAME all the routines which
              !             contain the keyword phrase, so that they can be printed
              !             six on a line.
              !
              cname(in) = rtname(ir)
              IF ( il==0 ) THEN
                WRITE (UNIT=LU6,FMT=99018) tkwd(i)
                WRITE (UNIT=LU6,FMT=99019)
                WRITE (UNIT=LU6,FMT=99043) (cname(ij),ij=1,in)
                EXIT
              ELSE
                ij = il
                in = in + 1
              ENDIF
            ENDDO
          ENDIF
        ENDDO
        IF ( .NOT.found ) WRITE (UNIT=LU6,FMT=99020)
        !
        !
      ELSEIF ( input1=='C' ) THEN
        !
        !         User is looking for routine names by category.
        !
        IF ( .NOT.llu18 ) THEN
          !
          !           Read in the information from file FTBL.
          !
          lftbl = 0
          DO
            lftbl = lftbl + 1
            READ (UNIT=LU18,FMT=99001,END=535) linesv
            IF ( lftbl>MXNRN ) THEN
              msg = 'MXNRN internal error.  Please contact the consulting office.'
              nerr = 2
              GOTO 700
            ENDIF
            READ (UNIT=linesv,FMT=99017) cat(lftbl), rtname(lftbl), &
              is(lftbl), ie(lftbl), ips(lftbl), ipe(lftbl)
          ENDDO
          535          lftbl = lftbl - 1
          llu18 = .TRUE.
          CLOSE (LU18)
        ENDIF
        ls = lt + lb
        CALL CHARIN(line(ls:ls),leng,2,lb,lt)
        IF ( lt==0 ) THEN
          !
          !           Ask the user to input the classification category he/she
          !           wishes to find.
          !
          WRITE (UNIT=LU6,FMT=99012)
          REWIND (UNIT=LU5,ERR=540)
          540          READ (UNIT=LU5,FMT=99001,END=545) line
          CALL UPCASE(line,line)
          GOTO 550
          545          line = ' '
          550          lb = 1
          lt = LENSTR(line)
          IF ( lt==0 ) THEN
            WRITE (UNIT=LU6,FMT=99014)
            GOTO 100
          ENDIF
          kat = line(lb:lt)
        ELSE
          !
          !           The category appeared on the original input line.
          !
          kat = line(ls-1+lb:ls-1+lb+lt-1)
        ENDIF
        ij = 0
        ilen = LENSTR(kat)
        DO i = 1, lftbl
          IF ( kat==cat(i)(1:ilen) ) THEN
            ij = ij + 1
            !
            !             Collect together in CNAME all the routines having
            !             this category.
            !
            cname(ij) = rtname(i)
          ENDIF
        ENDDO
        IF ( ij==0 ) THEN
          WRITE (UNIT=LU6,FMT=99014)
        ELSE
          WRITE (UNIT=LU6,FMT=99013)
          !
          !           Write out the routine names, six per line.
          !
          WRITE (UNIT=LU6,FMT=99043) (cname(i),i=1,ij)
        ENDIF
      ELSEIF ( input1=='V' ) THEN
        ls = lt + lb
        CALL CHARIN(line(ls:ls),leng,2,lb,lt)
        IF ( lt==0 ) THEN
          !
          !           Ask the user to input if he wants classification categories
          !           or the keywords.
          !
          WRITE (UNIT=LU6,FMT=99032)
          REWIND (UNIT=LU5,ERR=555)
          555          READ (UNIT=LU5,FMT=99001,END=560) line
          CALL UPCASE(line,line)
          GOTO 565
          560          line = ' '
          565          lb = 1
          lt = LENSTR(line)
          IF ( lt==0 ) THEN
            WRITE (UNIT=LU6,FMT=99014)
            GOTO 100
          ENDIF
          kat = line(lb:lt)
        ELSE
          !
          !           The category appeared on the original input line.
          !
          kat = line(ls-1+lb:ls-1+lb+lt-1)
        ENDIF
        IF ( kat(1:1)=='C' ) THEN
          IF ( .NOT.llu14 ) THEN
            !
            !             Read in the information from file FCAT.
            !
            READ (UNIT=LU14,FMT=99037) ncc
            IF ( ncc>MXNCAT ) THEN
              msg = 'MXNCAT internal error.  Please contact the consulting office.'
              nerr = 3
              EXIT
            ENDIF
            ncc = ncc - 1
            DO j = 1, ncc
              READ (UNIT=LU14,FMT=99040) iptr(j), jptr(j), kptr(j), &
                tclass(j)
            ENDDO
            READ (UNIT=LU14,FMT=99038) kptr(ncc+1)
            istmt = kptr(ncc+1)
            IF ( istmt>MXNCL ) THEN
              msg = 'MXNCL internal error.  Please contact the consulting office.'
              nerr = 4
              EXIT
            ENDIF
            READ (UNIT=LU14,FMT=99001) (stmts(i),i=1,istmt)
            llu14 = .TRUE.
            CLOSE (LU14)
          ENDIF
        ELSEIF ( kat(1:1)=='K' ) THEN
          !
          !           The keywords are being requested.
          !
          IF ( .NOT.llu19 ) THEN
            !
            !             Read in the information from file FKWD.
            !
            READ (UNIT=LU19,FMT=99037) ntkwd
            WRITE (UNIT=form,FMT=99042) KMAXI
            IF ( ntkwd>MXKWDS ) THEN
              msg = 'MXKWDS internal error.  Please contact the consulting office.'
              nerr = 5
              EXIT
            ENDIF
            READ (UNIT=LU19,FMT=form) (tkwd(j),j=1,ntkwd)
            !
            inext = 0
            DO
              READ (UNIT=LU19,FMT=99001,END=566) linesv
              IF ( inext>=10*MXKWDS ) THEN
                msg = 'MXKWDS internal error.  Please contact the consulting office.'
                nerr = 6
                GOTO 700
              ENDIF
              READ (UNIT=linesv,FMT=99037) iptrl(inext+1), iptrr(inext+1)
              inext = inext + 1
            ENDDO
            566            llu19 = .TRUE.
            CLOSE (LU19)
          ENDIF
        ELSE
          WRITE (UNIT=LU6,FMT=99006)
          GOTO 200
        ENDIF
        IF ( kat(1:1)=='C' ) THEN
          fname = 'classlis'
          WRITE (UNIT=LU6,FMT=99033) 'Classification', ncc
        ELSE
          fname = 'keylis'
          WRITE (UNIT=LU6,FMT=99033) 'Keyword', ntkwd
        ENDIF
        ilen = LENSTR(fname)
        WRITE (UNIT=LU6,FMT=99034) fname(1:ilen)
        !
        !         Ask where he/she wants the list information written.
        !
        WRITE (UNIT=LU6,FMT=99035)
        READ (UNIT=LU5,FMT=99001) line
        leng = LENSTR(line)
        CALL CHARIN(line,leng,2,lb,lt)
        !
        !         The user wants to browse through the list on her/his terminal.
        !
        IF ( line(lb:lb)=='b'.OR.line(lb:lb)=='B' ) THEN
          pgsz = 21
          low = 1
          high = pgsz
          570          WRITE (UNIT=LU6,FMT=99026)
          DO
            READ (UNIT=LU5,FMT=99001,END=570) line
            leng = LENSTR(line)
            CALL UPCASE(line,line)
            CALL CHARIN(line,leng,2,lb,lt)
            IF ( kat(1:1)=='C' ) THEN
              nlines = ncc
            ELSE
              nlines = ntkwd
            ENDIF
            !
            !           'SPGSZ'   Set page size
            !
            IF ( line(lb:lb+4)=='SPGSZ' ) THEN
              IF ( (lt==5).AND.(lb+4==leng) ) THEN
                !
                !               Print out the current value of PGSZ
                !
                WRITE (UNIT=LU6,FMT=99030) pgsz
              ELSE
                !
                !               Get a new pgsz
                !
                IF ( lt+lb-1>lb+4 ) THEN
                  !
                  !                 There are no spaces between 'spgsz' and a value
                  !
                  WRITE (form,99027) lt - 5
                  READ (line(lb+5:lb+lt-1),form,ERR=575) pgsz
                  pgsz = ABS(pgsz)
                ELSE
                  !
                  !                 There are spaces; call CHARIN again to get the next
                  !                 field
                  !
                  ls = lb + lt
                  CALL CHARIN(line(ls:ls),leng,2,lb2,lt2)
                  WRITE (form,99027) leng - ls - lb2 + 2
                  READ (line(ls+lb2-1:leng),form,ERR=575) pgsz
                  pgsz = ABS(pgsz)
                ENDIF
                WRITE (UNIT=LU6,FMT=99031) pgsz
              ENDIF
              WRITE (UNIT=LU6,FMT=99028)
              !
              !           'PD'   Page forwards (downward)
              !
            ELSEIF ( line(lb:lb+1)=='PD' ) THEN
              IF ( (lt==2).AND.(lb+1==leng) ) THEN
                !
                !               There is no value given; assume one (1).
                !
                npd = 1
              ELSEIF ( lt+lb-1>lb+1 ) THEN
                !
                !                 There are no spaces between 'pd' and a value
                !
                WRITE (form,99027) lt - 2
                READ (line(lb+2:lb+lt-1),form,ERR=575) npd
              ELSE
                !
                !                 There are spaces; call CHARIN again to get the next
                !                 field
                !
                ls = lb + lt
                CALL CHARIN(line(ls:ls),leng,2,lb2,lt2)
                WRITE (form,99027) leng - ls - lb2 + 2
                READ (line(ls+lb2-1:leng),form,ERR=575) npd
              ENDIF
              low = MAX(high+(npd-1)*pgsz+1,1)
              high = MIN(low+pgsz-1,nlines)
              IF ( low>high.OR.high-low+1<pgsz ) low = MAX(high-pgsz,1)
              DO irec = low, MIN(high,nlines)
                IF ( kat(1:1)=='C' ) THEN
                  ii = kptr(irec)
                  tcl = ' '
                  CALL UNDOCL(tclass(irec),tcl)
                  WRITE (UNIT=LU6,FMT=99044) ii, tcl(1:LENSTR(tcl)), &
                    stmts(ii)(1:LENSTR(stmts(ii)))
                  itemp = kptr(irec+1) - kptr(irec) - 1
                  ltcl = LENSTR(tcl) + 3
                  WRITE (UNIT=form,FMT=99045) ltcl
                  DO jj = 1, itemp
                    ii = ii + 1
                    WRITE (UNIT=LU6,FMT=form) ii, stmts(ii)&
                      (1:LENSTR(stmts(ii)))
                  ENDDO
                ELSE
                  WRITE (UNIT=LU6,FMT=99036) irec, tkwd(irec)
                ENDIF
              ENDDO
              WRITE (UNIT=LU6,FMT=99028)
              !
              !           'PU'   Page backwards (upward)
              !
            ELSEIF ( line(lb:lb+1)=='PU' ) THEN
              IF ( (lt==2).AND.(lb+1==leng) ) THEN
                !
                !               There is no value given; assume one (1).
                !
                npd = 1
              ELSEIF ( lt+lb-1>lb+1 ) THEN
                !
                !                 There are no spaces between 'pu' and a value
                !
                WRITE (form,99027) lt - 2
                READ (line(lb+2:lb+lt-1),form,ERR=575) npd
              ELSE
                !
                !                 There are spaces; call CHARIN again to get the next
                !                 field
                !
                ls = lb + lt
                CALL CHARIN(line(ls:ls),leng,2,lb2,lt2)
                WRITE (form,99027) leng - ls - lb2 + 2
                READ (line(ls+lb2-1:leng),form,ERR=575) npd
              ENDIF
              npd = -npd
              low = MAX(low+npd*pgsz,1)
              high = MIN(low+pgsz-1,nlines)
              IF ( low>high.OR.high-low+1<pgsz ) low = MAX(high-pgsz,1)
              DO irec = low, MIN(high,nlines)
                IF ( kat(1:1)=='C' ) THEN
                  ii = kptr(irec)
                  tcl = ' '
                  CALL UNDOCL(tclass(irec),tcl)
                  WRITE (UNIT=LU6,FMT=99044) ii, tcl(1:LENSTR(tcl)), &
                    stmts(ii)(1:LENSTR(stmts(ii)))
                  itemp = kptr(irec+1) - kptr(irec) - 1
                  ltcl = LENSTR(tcl) + 3
                  WRITE (UNIT=form,FMT=99045) ltcl
                  DO jj = 1, itemp
                    ii = ii + 1
                    WRITE (UNIT=LU6,FMT=form) ii, stmts(ii)&
                      (1:LENSTR(stmts(ii)))
                  ENDDO
                ELSE
                  WRITE (UNIT=LU6,FMT=99036) irec, tkwd(irec)
                ENDIF
              ENDDO
              WRITE (UNIT=LU6,FMT=99028)
              !
              !           'HD'   Page half a page forward
              !
            ELSEIF ( line(lb:lb+1)=='HD' ) THEN
              low = MAX(low+pgsz/2,1)
              high = MIN(low+pgsz-1,nlines)
              IF ( low>high.OR.high-low+1<pgsz ) low = MAX(high-pgsz,1)
              DO irec = low, MIN(high,nlines)
                IF ( kat(1:1)=='C' ) THEN
                  ii = kptr(irec)
                  tcl = ' '
                  CALL UNDOCL(tclass(irec),tcl)
                  WRITE (UNIT=LU6,FMT=99044) ii, tcl(1:LENSTR(tcl)), &
                    stmts(ii)(1:LENSTR(stmts(ii)))
                  itemp = kptr(irec+1) - kptr(irec) - 1
                  ltcl = LENSTR(tcl) + 3
                  WRITE (UNIT=form,FMT=99045) ltcl
                  DO jj = 1, itemp
                    ii = ii + 1
                    WRITE (UNIT=LU6,FMT=form) ii, stmts(ii)&
                      (1:LENSTR(stmts(ii)))
                  ENDDO
                ELSE
                  WRITE (UNIT=LU6,FMT=99036) irec, tkwd(irec)
                ENDIF
              ENDDO
              WRITE (UNIT=LU6,FMT=99028)
              !
              !           'HU'   Page half a page backward
              !
            ELSEIF ( line(lb:lb+1)=='HU' ) THEN
              low = MAX(low-pgsz/2,1)
              high = MIN(low+pgsz-1,nlines)
              IF ( low>high.OR.high-low+1<pgsz ) low = MAX(high-pgsz,1)
              DO irec = low, MIN(high,nlines)
                IF ( kat(1:1)=='C' ) THEN
                  ii = kptr(irec)
                  tcl = ' '
                  CALL UNDOCL(tclass(irec),tcl)
                  WRITE (UNIT=LU6,FMT=99044) ii, tcl(1:LENSTR(tcl)), &
                    stmts(ii)(1:LENSTR(stmts(ii)))
                  itemp = kptr(irec+1) - kptr(irec) - 1
                  ltcl = LENSTR(tcl) + 3
                  WRITE (UNIT=form,FMT=99045) ltcl
                  DO jj = 1, itemp
                    ii = ii + 1
                    WRITE (UNIT=LU6,FMT=form) ii, stmts(ii)&
                      (1:LENSTR(stmts(ii)))
                  ENDDO
                ELSE
                  WRITE (UNIT=LU6,FMT=99036) irec, tkwd(irec)
                ENDIF
              ENDDO
              WRITE (UNIT=LU6,FMT=99028)
              !
              !           'P'   Print the current page
              !
            ELSEIF ( line(lb:lb)=='P'.AND.lt==1 ) THEN
              high = MIN(low+pgsz-1,nlines)
              IF ( low>high.OR.high-low+1<pgsz ) low = MAX(high-pgsz,1)
              DO irec = low, MIN(high,nlines)
                IF ( kat(1:1)=='C' ) THEN
                  ii = kptr(irec)
                  tcl = ' '
                  CALL UNDOCL(tclass(irec),tcl)
                  WRITE (UNIT=LU6,FMT=99044) ii, tcl(1:LENSTR(tcl)), &
                    stmts(ii)(1:LENSTR(stmts(ii)))
                  itemp = kptr(irec+1) - kptr(irec) - 1
                  ltcl = LENSTR(tcl) + 3
                  WRITE (UNIT=form,FMT=99045) ltcl
                  DO jj = 1, itemp
                    ii = ii + 1
                    WRITE (UNIT=LU6,FMT=form) ii, stmts(ii)&
                      (1:LENSTR(stmts(ii)))
                  ENDDO
                ELSE
                  WRITE (UNIT=LU6,FMT=99036) irec, tkwd(irec)
                ENDIF
              ENDDO
              WRITE (UNIT=LU6,FMT=99028)
              !
              !           'E'  End the browsing mode
              !
            ELSEIF ( line(lb:lb)=='E' ) THEN
              WRITE (UNIT=LU6,FMT=99005)
              REWIND (UNIT=LU5,ERR=300)
              GOTO 300
              !
              !           'Q'  Quit the browsing mode
              !
            ELSEIF ( line(lb:lb)=='Q' ) THEN
              WRITE (UNIT=LU6,FMT=99005)
              REWIND (UNIT=LU5,ERR=300)
              GOTO 300
            ELSEIF ( line(lb:lb)=='?' ) THEN
              GOTO 570
            ELSE
              WRITE (UNIT=LU6,FMT=99006)
              GOTO 570
            ENDIF
          ENDDO
          575          WRITE (UNIT=LU6,FMT=99006)
          GOTO 570
        ELSEIF ( line(lb:lb)=='t'.OR.line(lb:lb)=='T' ) THEN
          !
          !           Write it to the standard output file.
          !
          IF ( kat(1:1)=='C' ) THEN
            DO j = 1, ncc
              i = kptr(j)
              tcl = ' '
              CALL UNDOCL(tclass(j),tcl)
              WRITE (UNIT=LU6,FMT=99046) tcl(1:LENSTR(tcl)), stmts(i)&
                (1:LENSTR(stmts(i)))
              itemp = kptr(j+1) - kptr(j) - 1
              ltcl = LENSTR(tcl) + 1
              WRITE (UNIT=form,FMT=99047) ltcl
              DO jj = 1, itemp
                i = i + 1
                WRITE (UNIT=LU6,FMT=form) stmts(i)(1:LENSTR(stmts(i)))
              ENDDO
            ENDDO
          ELSE
            DO i = 1, ntkwd
              WRITE (UNIT=LU6,FMT=99002) tkwd(i)
            ENDDO
          ENDIF
        ELSEIF ( line(lb:lb)=='f'.OR.line(lb:lb)=='F' ) THEN
          ls = lb + lt
          CALL CHARIN(line(ls:ls),leng,2,lb,lt)
          IF ( lt==0 ) THEN
            !
            !             Write it to file FNAME.
            !
            fn = fname
          ELSE
            fn = line(ls-1+lb:ls-1+lb+lt-1)
            !
            !             Write it to the file he/she specified.
            !
          ENDIF
          !           IF (FN .NE. FNAMSV) THEN
          !
          !             If this filename is not the one previously used for some
          !             list, then close the file (if it is still open) and open
          !             UNIT 13 for the new file.
          !
          IF ( llu13 ) CLOSE (LU13)
          OPEN (UNIT=LU13,FILE=fn,STATUS='UNKNOWN',FORM='FORMATTED')
          fnamsv = fn
          llu13 = .TRUE.
          !           ENDIF
          !
          !           Write the list to the file specified by the user.
          !
          IF ( kat(1:1)=='C' ) THEN
            DO j = 1, ncc
              i = kptr(j)
              tcl = ' '
              CALL UNDOCL(tclass(j),tcl)
              WRITE (UNIT=LU13,FMT=99046) tcl(1:LENSTR(tcl)), stmts(i)&
                (1:LENSTR(stmts(i)))
              itemp = kptr(j+1) - kptr(j) - 1
              ltcl = LENSTR(tcl) + 1
              WRITE (UNIT=form,FMT=99047) ltcl
              DO jj = 1, itemp
                i = i + 1
                WRITE (UNIT=LU13,FMT=form) stmts(i)(1:LENSTR(stmts(i)))
              ENDDO
            ENDDO
          ELSE
            DO i = 1, ntkwd
              WRITE (UNIT=LU13,FMT=99002) tkwd(i)
            ENDDO
          ENDIF
          CLOSE (LU13)
        ELSE
          WRITE (UNIT=LU6,FMT=99005)
          REWIND (UNIT=LU5,ERR=300)
          GOTO 300
        ENDIF
        IF ( lb>0.AND.(line(lb:lb)=='Q'.OR.line(lb:lb)=='E') ) THEN
          !
          !           The command typed in is assumed to be "quit" or "end".
          !
          input1 = 'Q'
        ELSEIF ( lb>0.AND.(line(lb:lb)=='H'.OR.line(lb:lb)=='?') ) THEN
          !
          !           The command typed in is assumed to be "help" or "?".
          !           Go back and print the original input instructions.
          !
          input1 = 'H'
        ELSE
          !
          !           Print "invalid command" and assume the command was "help".
          !
          input1 = 'H'
        ENDIF
      ELSE
        !
        !         The input command was X.
        !
        !         User wants documentation for a specific routine.
        !
        IF ( .NOT.llu18 ) THEN
          !
          !           Read in the information from file FTBL.
          !
          lftbl = 0
          DO
            lftbl = lftbl + 1
            READ (UNIT=LU18,FMT=99001,END=580) linesv
            IF ( lftbl>MXNRN ) THEN
              msg = 'MXNRN internal error.  Please contact the consulting office.'
              nerr = 2
              GOTO 700
            ENDIF
            READ (UNIT=linesv,FMT=99017) cat(lftbl), rtname(lftbl), &
              is(lftbl), ie(lftbl), ips(lftbl), ipe(lftbl)
          ENDDO
          580          lftbl = lftbl - 1
          llu18 = .TRUE.
          CLOSE (LU18)
        ENDIF
        ls = lt + lb
        CALL CHARIN(line(ls:ls),leng,2,lb,lt)
        temp = ' '
        IF ( lt==0 ) THEN
          !
          !           Ask the user for the routine name.
          !
          WRITE (UNIT=LU6,FMT=99021)
          REWIND (UNIT=LU5,ERR=585)
          585          READ (UNIT=LU5,FMT=99001,END=590) line
          CALL UPCASE(line,line)
          GOTO 595
          590          line = ' '
          595          leng = LENSTR(line)
          IF ( leng==0 ) GOTO 600
          temp = line(1:leng)
        ELSE
          !
          !           The routine name was given on the input command line.
          !
          temp = line(ls-1+lb:ls-1+lb+lt-1)
        ENDIF
        rtnin = temp(1:6)
        DO i = 1, lftbl
          IF ( rtnin==rtname(i) ) GOTO 610
        ENDDO
        600        WRITE (UNIT=LU6,FMT=99025)
        !
        !         This routine does not exist in the library.
        !
        GOTO 200
        !
        !         IS(I) contains the location of the subprogram statement.
        !         IE(I) contains the location of the END PROLOGUE statement.
        !         IPS(I) contains the starting location of the PURPOSE section.
        !         IPE(I) contains the ending location of the PURPOSE section.
        !
        610        num = ie(i) - is(i) + 1
        !
        !         Write the name of the routine and the number of lines of
        !         documentation.
        !
        WRITE (UNIT=LU6,FMT=99022) rtnin, num
        !
        !         Write the purpose of the subprogram.
        !
        DO irec = ips(i), ipe(i)
          READ (UNIT=LU17,FMT=99001,REC=irec) line
          WRITE (UNIT=LU6,FMT=99002) line
        ENDDO
        fname = FLIS
        ilen = LENSTR(fname)
        WRITE (UNIT=LU6,FMT=99023) fname(1:ilen)
        !
        !         Ask where he/she wants the documentation information written.
        !
        WRITE (UNIT=LU6,FMT=99024)
        READ (UNIT=LU5,FMT=99001) line
        leng = LENSTR(line)
        CALL CHARIN(line,leng,2,lb,lt)
        !
        !         The user wants to browse through the documentation on her/his
        !         terminal.
        !
        IF ( line(lb:lb)=='b'.OR.line(lb:lb)=='B' ) THEN
          pgsz = 21
          low = 1
          high = pgsz
          615          WRITE (UNIT=LU6,FMT=99026)
          DO
            READ (UNIT=LU5,FMT=99001,END=615) line
            leng = LENSTR(line)
            CALL UPCASE(line,line)
            CALL CHARIN(line,leng,2,lb,lt)
            !
            !           'SPGSZ'   Set page size
            !
            IF ( line(lb:lb+4)=='SPGSZ' ) THEN
              IF ( (lt==5).AND.(lb+4==leng) ) THEN
                !
                !               Print out the current value of PGSZ
                !
                WRITE (UNIT=LU6,FMT=99030) pgsz
              ELSE
                !
                !               Get a new pgsz
                !
                IF ( lt+lb-1>lb+4 ) THEN
                  !
                  !                 There are no spaces between 'spgsz' and a value
                  !
                  WRITE (form,99027) lt - 5
                  READ (line(lb+5:lb+lt-1),form,ERR=620) pgsz
                  pgsz = ABS(pgsz)
                ELSE
                  !
                  !                 There are spaces; call CHARIN again to get the next
                  !                 field
                  !
                  ls = lb + lt
                  CALL CHARIN(line(ls:ls),leng,2,lb2,lt2)
                  WRITE (form,99027) leng - ls - lb2 + 2
                  READ (line(ls+lb2-1:leng),form,ERR=620) pgsz
                  pgsz = ABS(pgsz)
                ENDIF
                WRITE (UNIT=LU6,FMT=99031) pgsz
              ENDIF
              WRITE (UNIT=LU6,FMT=99028)
              !
              !           'PD'   Page forwards (downward)
              !
            ELSEIF ( line(lb:lb+1)=='PD' ) THEN
              IF ( (lt==2).AND.(lb+1==leng) ) THEN
                !
                !               There is no value given; assume one (1).
                !
                npd = 1
              ELSEIF ( lt+lb-1>lb+1 ) THEN
                !
                !                 There are no spaces between 'pd' and a value
                !
                WRITE (form,99027) lt - 2
                READ (line(lb+2:lb+lt-1),form,ERR=620) npd
              ELSE
                !
                !                 There are spaces; call CHARIN again to get the next
                !                 field
                !
                ls = lb + lt
                CALL CHARIN(line(ls:ls),leng,2,lb2,lt2)
                WRITE (form,99027) leng - ls - lb2 + 2
                READ (line(ls+lb2-1:leng),form,ERR=620) npd
              ENDIF
              low = MAX(high+(npd-1)*pgsz+1,1)
              nlines = ie(i) - is(i) + 1
              high = MIN(low+pgsz-1,nlines)
              IF ( low>high.OR.high-low+1<pgsz ) low = MAX(high-pgsz+1,1)
              DO irec = is(i) + low - 1, MIN(is(i)+high-1,ie(i))
                READ (UNIT=LU17,FMT=99001,REC=irec) line
                WRITE (UNIT=LU6,FMT=99029) irec - is(i) + 1, line
              ENDDO
              WRITE (UNIT=LU6,FMT=99028)
              !
              !           'PU'   Page backwards (upward)
              !
            ELSEIF ( line(lb:lb+1)=='PU' ) THEN
              IF ( (lt==2).AND.(lb+1==leng) ) THEN
                !
                !               There is no value given; assume one (1).
                !
                npd = 1
              ELSEIF ( lt+lb-1>lb+1 ) THEN
                !
                !                 There are no spaces between 'pu' and a value
                !
                WRITE (form,99027) lt - 2
                READ (line(lb+2:lb+lt-1),form,ERR=620) npd
              ELSE
                !
                !                 There are spaces; call CHARIN again to get the next
                !                 field
                !
                ls = lb + lt
                CALL CHARIN(line(ls:ls),leng,2,lb2,lt2)
                WRITE (form,99027) leng - ls - lb2 + 2
                READ (line(ls+lb2-1:leng),form,ERR=620) npd
              ENDIF
              npd = -npd
              low = MAX(low+npd*pgsz,1)
              nlines = ie(i) - is(i) + 1
              high = MIN(low+pgsz-1,nlines)
              IF ( low>high.OR.high-low+1<pgsz ) low = MAX(high-pgsz+1,1)
              DO irec = is(i) + low - 1, MIN(is(i)+high-1,ie(i))
                READ (UNIT=LU17,FMT=99001,REC=irec) line
                WRITE (UNIT=LU6,FMT=99029) irec - is(i) + 1, line
              ENDDO
              WRITE (UNIT=LU6,FMT=99028)
              !
              !           'HD'   Page half a page forward
              !
            ELSEIF ( line(lb:lb+1)=='HD' ) THEN
              low = MAX(low+pgsz/2,1)
              nlines = ie(i) - is(i) + 1
              high = MIN(low+pgsz-1,nlines)
              IF ( low>high.OR.high-low+1<pgsz ) low = MAX(high-pgsz+1,1)
              DO irec = is(i) + low - 1, MIN(is(i)+high-1,ie(i))
                READ (UNIT=LU17,FMT=99001,REC=irec) line
                WRITE (UNIT=LU6,FMT=99029) irec - is(i) + 1, line
              ENDDO
              WRITE (UNIT=LU6,FMT=99028)
              !
              !           'HU'   Page half a page backward
              !
            ELSEIF ( line(lb:lb+1)=='HU' ) THEN
              low = MAX(low-pgsz/2,1)
              nlines = ie(i) - is(i) + 1
              high = MIN(low+pgsz-1,nlines)
              IF ( low>high.OR.high-low+1<pgsz ) low = MAX(high-pgsz+1,1)
              DO irec = is(i) + low - 1, MIN(is(i)+high-1,ie(i))
                READ (UNIT=LU17,FMT=99001,REC=irec) line
                WRITE (UNIT=LU6,FMT=99029) irec - is(i) + 1, line
              ENDDO
              WRITE (UNIT=LU6,FMT=99028)
              !
              !           'P'   Print the current page
              !
            ELSEIF ( line(lb:lb)=='P'.AND.lt==1 ) THEN
              nlines = ie(i) - is(i) + 1
              high = MIN(low+pgsz-1,nlines)
              IF ( low>high.OR.high-low+1<pgsz ) low = MAX(high-pgsz+1,1)
              DO irec = is(i) + low - 1, MIN(is(i)+high-1,ie(i))
                READ (UNIT=LU17,FMT=99001,REC=irec) line
                WRITE (UNIT=LU6,FMT=99029) irec - is(i) + 1, line
              ENDDO
              WRITE (UNIT=LU6,FMT=99028)
              !
              !           'E'  End the browsing mode
              !
            ELSEIF ( line(lb:lb)=='E' ) THEN
              WRITE (UNIT=LU6,FMT=99005)
              REWIND (UNIT=LU5,ERR=300)
              GOTO 300
              !
              !           'Q'  Quit the browsing mode
              !
            ELSEIF ( line(lb:lb)=='Q' ) THEN
              WRITE (UNIT=LU6,FMT=99005)
              REWIND (UNIT=LU5,ERR=300)
              GOTO 300
            ELSEIF ( line(lb:lb)=='?' ) THEN
              GOTO 615
            ELSE
              WRITE (UNIT=LU6,FMT=99006)
              GOTO 615
            ENDIF
          ENDDO
          620          WRITE (UNIT=LU6,FMT=99006)
          GOTO 615
        ELSEIF ( line(lb:lb)=='t'.OR.line(lb:lb)=='T' ) THEN
          !
          !           Write it to the standard output file.
          !
          DO irec = is(i), ie(i)
            READ (UNIT=LU17,FMT=99001,REC=irec) line
            WRITE (UNIT=LU6,FMT=99002) line
          ENDDO
        ELSEIF ( line(lb:lb)=='f'.OR.line(lb:lb)=='F' ) THEN
          ls = lb + lt
          CALL CHARIN(line(ls:ls),leng,2,lb,lt)
          IF ( lt==0 ) THEN
            fn = FLIS
            !
            !             Write it to file FLIS.
            !
          ELSE
            fn = line(ls-1+lb:ls-1+lb+lt-1)
            !
            !             Write it to the file he/she specified.
            !
          ENDIF
          IF ( fn/=fnamsv ) THEN
            !
            !             If this filename is not the one previously used for some
            !             documentation, then close the file (if it is still open)
            !             and open UNIT 3 for the new file.
            !
            IF ( llu13 ) CLOSE (LU13)
            OPEN (UNIT=LU13,FILE=fn,STATUS='UNKNOWN',FORM='FORMATTED')
            fnamsv = fn
            llu13 = .TRUE.
          ENDIF
          !
          !           Write the documentation to the file specified by the user.
          !
          DO irec = is(i), ie(i)
            READ (UNIT=LU17,FMT=99001,REC=irec) line
            WRITE (UNIT=LU13,FMT=99002) line
          ENDDO
        ELSE
          WRITE (UNIT=LU6,FMT=99005)
          REWIND (UNIT=LU5,ERR=300)
          GOTO 300
        ENDIF
      ENDIF
    ELSEIF ( lb>0.AND.(line(lb:lb)=='Q'.OR.line(lb:lb)=='E') ) THEN
      !
      !         The command typed in is assumed to be "quit" or "end".
      !
      input1 = 'Q'
    ELSEIF ( lb>0.AND.(line(lb:lb)=='H'.OR.line(lb:lb)=='?') ) THEN
      !
      !         The command typed in is assumed to be "help" or "?".
      !         Go back and print the original input instructions.
      !
      input1 = 'H'
    ELSE
      !
      !         Print "invalid command" and assume the command was "help".
      !
      WRITE (UNIT=LU6,FMT=99006)
      input1 = 'H'
    ENDIF
    !
    !       Go back to the beginning and print the original instructions.
    !
    IF ( input1=='H' ) GOTO 100
    IF ( input1/='Q' ) THEN
      !
      !         Print "Ready for your command" and then go process the new
      !         request.
      !
      WRITE (UNIT=LU6,FMT=99005)
      REWIND (UNIT=LU5,ERR=640)
      640      READ (UNIT=LU5,FMT=99001,END=660) line
      CALL UPCASE(line,line)
      GOTO 680
      660      line = ' '
      680      leng = LENSTR(line)
      CALL CHARIN(line,leng,2,lb,lt)
    ELSE
      !
      !         Close any files still open and terminate.
      !
      IF ( llu13 ) CLOSE (UNIT=LU13)
      !         CLOSE (UNIT=LU5)
      !         CLOSE (UNIT=LU6)
      CLOSE (UNIT=LU17)
      STOP
    ENDIF
  ENDDO
  !     OPEN (UNIT=I1MACH(4), FILE=FERR, FORM='FORMATTED',
  !    +      STATUS='UNKNOWN')
  700  CALL XERMSG(' ','SLADOC',msg,nerr,1)
  STOP
  !
  99001 FORMAT (A)
  99002 FORMAT (' ',A)
  99003 FORMAT (' The first field of a command line is required, but'/&
    ' the second field is optional.  For example, to view'/&
    ' the main classification categories, just type ''l''.'/&
    ' Other commands are: x,abc  to extract the documentation by name, where'/&
    '  ''abc'' is a routine name'/&
    ' k,...  to find routine names by keyword(s), where'/&
    '  ''...'' is a keyword or keyphrase'/&
    ' c,xyz  to find routine names by classification category,'/&
    '  where ''xyz'' is a classification category'/&
    ' l,c    to list subcategories of a main category, where'/&
    '  ''c'' is a main classification category'/&
    ' v,xyz  to view the list of keywords or the classification'/&
    '  scheme, where ''abc'' is K for the keywords'' or C'/&
    '  for the classification scheme'/&
    ' q      to quit')
  99004 FORMAT (/' Ready for your command')
  99005 FORMAT (/' Ready for your command {x, k, c, l, v, or q}')
  99006 FORMAT (' Invalid command')
  99007 FORMAT (/' The major categories are:')
  99008 FORMAT (/' Input a MAJOR category you wish to explore')
  99009 FORMAT (/' Type in the SUBCATEGORY you wish to explore, or <cr>')
  99010 FORMAT (/' There are no subcategories of: ',A)
  99011 FORMAT (1X)
  99012 FORMAT (/' Input classification category for routine names')
  99013 FORMAT (/' The routine names classified under the category are')
  99014 FORMAT (' category not found')
  99015 FORMAT (/1X,A8,' category does not exist in this library.'/)
  99016 FORMAT (/' Input keyword(s) for routine names')
  99017 FORMAT (1X,2A,4I8)
  99018 FORMAT (/' This keyword was found in the keyword phrase:'/5X,A)
  99019 FORMAT (/' The routine names associated with the keyword(s) are')
  99020 FORMAT (/' Keyword not found')
  99021 FORMAT (' Input a routine name for its purpose')
  99022 FORMAT (' ',A,' ... ',I6,' lines of documentation')
  99023 FORMAT (/' If you wish to see the full documentation,'/&
    '     type''b''          to browse through the ',&
    'documentation'/&
    '     type''t''          to have it written on your ',&
    'terminal'/'     type''f,filename'' to have it written on file '&
    ,'''filename'''/&
    '     type''f       '' to have it written on file ','''',A,&
    '''')
  99024 FORMAT (' If you do not wish to see the full documentation,'/&
    '     type anything else')
  99025 FORMAT (' Routine name not found')
  99026 FORMAT (' The browsing commands are:'&
    /'     type''p''            to display the current ','page',&
    /'     type''pd''           to display the next page',&
    /'     type''pd {+-}[n]''   to display the {+-}[n]-th page down',&
    /'     type''pu''           to display the preceeding ','page',&
    /'     type''pu {+-}[n]''   to display the {+-}[n]-th page up',&
    /'     type''spgsz''        to show the current page size',&
    /'     type''spgsz [n]''    to set page size to [n] lines',&
    /'     type''hd''           to display one-half page down (forward)',&
    /'     type''hu''           to display one-half page up (backward)',&
    /'     type''e''            to exit browsing mode',&
    /'     type''q''            to quit browsing mode')
  99027 FORMAT ('(I',I2,')')
  99028 FORMAT (/' Enter your next browsing command',' {spgsz p pd pu hd hu e q}')
  99029 FORMAT (' ',I4,2X,80A)
  99030 FORMAT (/,' The current value of PGSZ is: ',I5)
  99031 FORMAT (/,' The new value of PGSZ is: ',I5)
  99032 FORMAT (/' Input C for classification scheme or K for keywords')
  99033 FORMAT (' ',A,' list ',I6,' lines ')
  99034 FORMAT (/' If you wish to view these,'/&
    '     type''b''          to browse through the list'/&
    '     type''t''          to have it written on your terminal'/&
    '     type''f,filename'' to have it written on file ''filename'''/&
    '     type''f       '' to have it written on file ','''',A,'''')
  99035 FORMAT (' If you do not wish to view these,'/'     type anything else')
  99036 FORMAT (' ',I4,2X,A)
  99037 FORMAT (I5,2X,I5)
  99038 FORMAT (I15)
  99039 FORMAT (2I2)
  99040 FORMAT (3I5,3X,A)
  99041 FORMAT ('(1X, A',I2,', A)')
  99042 FORMAT ('(A',I2,')')
  99043 FORMAT ((1X,6(A,2X)))
  99044 FORMAT (1X,I4,2X,A,1X,A)
  99045 FORMAT ('(1X, I4, ',I2,'X, A)')
  99046 FORMAT (1X,A,1X,A)
  99047 FORMAT ('(1X, ',I2,'X, A)')
END PROGRAM SLADOC
!** CHARIN
SUBROUTINE CHARIN(Cardin,Lcard,Iopt,Lb,Lt)
  IMPLICIT NONE
  !>
  !***
  !  Subsidiary to SLADOC
  !***
  ! **Library:**   (NONE)
  !***
  ! **Author:**  Chow, Jeff, C-10, Los Alamos National Laboratory
  !***
  ! **Description:**
  !
  !   Locate a phrase terminated by a comma or a blank.
  !
  !***
  ! **See also:**  SLADOC
  !***
  ! **Routines called:**  (NONE)

  !* REVISION HISTORY  (YYMMDD)
  !   870827  DATE WRITTEN
  !   891208  Changed to check only for a blank or comma.
  !   891208  Prologue converted to Version 4.0 format.  (BAB)
  !   920911  Declarations section restructured.  (WRB)
  
  !     .. Parameters ..
  INTEGER LAST
  PARAMETER (LAST=2)
  !     .. Scalar Arguments ..
  INTEGER Iopt, Lb, Lcard, Lt
  CHARACTER*(*) Cardin
  !     .. Local Scalars ..
  INTEGER i, l, l1, l2, l3, l9, lbp1, le, match
  CHARACTER(2) :: specia
  !     .. Data statements ..
  DATA specia/' ,'/
  !* FIRST EXECUTABLE STATEMENT  CHARIN
  IF ( Iopt/=2 ) THEN
    l1 = Lcard
    l2 = 1
    l3 = -1
    l9 = 1
  ELSE
    l1 = 1
    l2 = Lcard
    l3 = 1
    l9 = LAST
  ENDIF
  Lb = 0
  DO i = l1, l2, l3
    match = 0
    DO l = 1, l9
      IF ( Cardin(i:i)==specia(l:l) ) THEN
        match = l
        EXIT
      ENDIF
    ENDDO
    IF ( match==0 ) THEN
      Lb = i
      EXIT
    ENDIF
  ENDDO
  IF ( Iopt/=2 ) THEN
    IF ( Lb>0 ) THEN
      Lt = Lb
    ELSE
      Lt = 1
    ENDIF
    Lb = 1
  ELSEIF ( Lb<=0 ) THEN
    Lt = 0
  ELSEIF ( Lb==Lcard ) THEN
    Lt = 1
    RETURN
  ELSE
    le = Lcard
    lbp1 = Lb + 1
    DO i = lbp1, Lcard
      match = 0
      DO l = 1, l9
        IF ( Cardin(i:i)==specia(l:l) ) THEN
          match = l
          EXIT
        ENDIF
      ENDDO
      IF ( match/=0 ) THEN
        le = i - 1
        EXIT
      ENDIF
    ENDDO
    Lt = le - Lb + 1
  ENDIF
END SUBROUTINE CHARIN
!** MINOR
INTEGER FUNCTION MINOR(Kat,Kats,Ncc,Tclass,Iptr,Jptr,Kptr,Ntry)
  IMPLICIT NONE
  !>
  !***
  !  Subsidiary to SLADOC
  !***
  ! **Library:**   (NONE)
  !***
  ! **Author:**  Bacon, Barbara A., C-10, Los Alamos National Laboratory
  !***
  ! **Description:**
  !
  !   Function to locate all the subcategories of a given category in the
  !   SLATEC library.
  !
  !***
  ! **See also:**  SLADOC
  !***
  ! **Routines called:**  FIND, UNDOCL

  !* REVISION HISTORY  (YYMMDD)
  !   871201  DATE WRITTEN
  !   891208  Prologue converted to Version 4.0 format.  (BAB)
  !   920911  Declarations section restructured.  (WRB)
  
  !     .. Parameters ..
  INTEGER IALPHA
  PARAMETER (IALPHA=26)
  !     .. Scalar Arguments ..
  INTEGER Ncc, Ntry
  CHARACTER*(*) Kat, Kats
  !     .. Array Arguments ..
  INTEGER Iptr(Ncc), Jptr(Ncc), Kptr(Ncc)
  CHARACTER*(*) Tclass(Ncc)
  !     .. Arrays in Common ..
  INTEGER I1(IALPHA), I2(IALPHA), I3(IALPHA), LMSg(IALPHA)
  CHARACTER(7) :: CLAss(IALPHA)
  !     .. Local Scalars ..
  INTEGER ifind
  !     .. External Functions ..
  INTEGER FIND
  EXTERNAL FIND
  !     .. External Subroutines ..
  EXTERNAL UNDOCL
  !     .. Common blocks ..
  COMMON /CATGRY/ I1, I2, I3, LMSg
  COMMON /KLASS / CLAss
  !* FIRST EXECUTABLE STATEMENT  MINOR
  MINOR = 0
  ifind = FIND(Tclass,Ncc,Kat)
  IF ( ifind<=0 ) THEN
    MINOR = 1
    Ntry = 0
    RETURN
  ENDIF
  !
  Ntry = 1
  CLAss(Ntry) = Kats
  LMSg(Ntry) = Kptr(ifind+1) - Kptr(ifind)
  I3(Ntry) = Kptr(ifind)
  ifind = Jptr(ifind)
  DO WHILE ( ifind>0 )
    Ntry = Ntry + 1
    I1(Ntry) = Iptr(ifind)
    I2(Ntry) = Jptr(ifind)
    I3(Ntry) = Kptr(ifind)
    CLAss(Ntry) = ' '
    CALL UNDOCL(Tclass(ifind),CLAss(Ntry))
    LMSg(Ntry) = Kptr(ifind+1) - Kptr(ifind)
    ifind = Iptr(ifind)
  ENDDO
  RETURN
END FUNCTION MINOR
!** RBLNKS
SUBROUTINE RBLNKS(L1,L2)
  IMPLICIT NONE
  !>
  !***
  !  Remove leading blanks from a character string.
  !***
  ! **Library:**   (NONE)
  !***
  ! **Author:**  Bacon, Barbara A., C-10, Los Alamos National Laboratory
  !***
  ! **Description:**
  !
  !   Subroutine to remove leading blanks from a character string
  !
  !***
  ! **See also:**  SLADOC
  !***
  ! **Routines called:**  LENSTR

  !* REVISION HISTORY  (YYMMDD)
  !   871201  DATE WRITTEN
  !   891208  Prologue converted to Version 4.0 format.  (BAB)
  !   920911  Declarations section restructured.  (WRB)
  
  !     .. Scalar Arguments ..
  CHARACTER(72) :: L1, L2
  !     .. Local Scalars ..
  INTEGER i, j, k, leng
  !     .. External Functions ..
  INTEGER LENSTR
  EXTERNAL LENSTR
  !* FIRST EXECUTABLE STATEMENT  RBLNKS
  leng = LENSTR(L1)
  DO i = 1, leng
    IF ( L1(i:i)/=' ' ) GOTO 100
  ENDDO
  !
  !     We found a completely blank line.
  !
  L2 = ' '
  RETURN
  100  L2 = ' '
  k = 1
  !
  !     Remove leading blanks in the line.
  !
  DO j = i, leng
    L2(k:k) = L1(j:j)
    k = k + 1
  ENDDO
END SUBROUTINE RBLNKS
!** UNDOCL
SUBROUTINE UNDOCL(Kat,Cat)
  IMPLICIT NONE
  !>
  !***
  !  Subsidiary to SLADOC
  !***
  ! **Library:**   (NONE)
  !***
  ! **Author:**  Bacon, Barbara A., C-10, Los Alamos National Laboratory
  !***
  ! **Description:**
  !
  !   Subroutine to collapse a GAMS category name by removing the
  !   zero before a numerical part.
  !   E.G., D02D01A   becomes   D2D1A
  !
  !***
  ! **See also:**  SLADOC
  !***
  ! **Routines called:**  (NONE)

  !* REVISION HISTORY  (YYMMDD)
  !   871201  DATE WRITTEN
  !   891208  Prologue converted to Version 4.0 format.  (BAB)
  !   920911  Declarations section restructured.  (WRB)
  
  !     .. Scalar Arguments ..
  CHARACTER*(*) Cat, Kat
  !     .. Local Scalars ..
  INTEGER ic, ik, leng, weny
  !     .. External Functions ..
  INTEGER LENSTR
  EXTERNAL LENSTR
  !* FIRST EXECUTABLE STATEMENT  UNDOCL
  leng = LENSTR(Kat)
  weny = 1
  ik = 1
  ic = 1
  DO
    IF ( weny==1 ) THEN
      Cat(ic:ic) = Kat(ik:ik)
      ic = ic + 1
      ik = ik + weny
    ELSEIF ( Kat(ik:ik)=='0' ) THEN
      Cat(ic:ic) = Kat(ik+1:ik+1)
      ic = ic + 1
      ik = ik + weny
    ELSE
      Cat(ic:ic+1) = Kat(ik:ik+1)
      ic = ic + 2
      ik = ik + weny
    ENDIF
    weny = 3 - weny
    IF ( ik>leng ) EXIT
  ENDDO
END SUBROUTINE UNDOCL
