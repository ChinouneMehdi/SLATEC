!*==ZQCBY.f90  processed by SPAG 6.72Dc at 10:52 on  6 Feb 2019
!DECK ZQCBY
SUBROUTINE ZQCBY(Lun,Kprint,Ipass)
  IMPLICIT NONE
  !*--ZQCBY5
  !***BEGIN PROLOGUE  ZQCBY
  !***SUBSIDIARY
  !***PURPOSE  Quick check for SLATEC subroutine
  !            ZBESY
  !***LIBRARY   SLATEC
  !***CATEGORY  C10A4
  !***TYPE      COMPLEX (CQCBY-C, ZQCBY-Z)
  !***KEYWORDS  QUICK CHECK, ZBESY
  !***AUTHOR  Amos, Don, (SNL)
  !           Goudy, Sue, (SNL)
  !           Walton, Lee, (SNL)
  !***DESCRIPTION
  !
  ! *Usage:
  !
  !        INTEGER  LUN, KPRINT, IPASS
  !
  !        CALL ZQCBY (LUN, KPRINT, IPASS)
  !
  ! *Arguments:
  !
  !     LUN    :IN  is the unit number to which output is to be written.
  !
  !     KPRINT :IN  controls the amount of output, as specified in the
  !                 SLATEC Guidelines.
  !
  !     IPASS  :OUT indicates whether the test passed or failed.
  !                 A value of one is good, indicating no failures.
  !
  ! *Description:
  !
  !                 *** A DOUBLE PRECISION ROUTINE ***
  !
  !   ZQCBY is a quick check routine for the complex Y Bessel function
  !    generated by subroutine ZBESY.
  !
  !   ZQCBY generates sequences of Y Bessel functions from ZBESY
  !    and checks them against the evaluation from the formula
  !
  !    Y(FNU,Z*ROT) = C(FNU+1)*I(FNU,Z)-(2/PI)*CONJG(C(FNU))*K(FNU,Z)
  !
  !    where ROT = EXP(PI*I/2) , C(FNU)=EXP(PI*FNU*I/2) , I**2=-1
  !
  !    and -PI.LT.ARG(Z).LE.PI/2, in the (Z,FNU) space.
  !
  !***REFERENCES  Abramowitz, M. and Stegun, I. A., Handbook
  !                 of Mathematical Functions, Dover Publications,
  !                 New York, 1964.
  !               Amos, D. E., A Subroutine Package for Bessel
  !                 Functions of a Complex Argument and Nonnegative
  !                 Order, SAND85-1018, May, 1985.
  !***ROUTINES CALLED  ZBESI, ZBESK, ZBESY, ZABS, ZEXP, I1MACH, D1MACH
  !***REVISION HISTORY  (YYMMDD)
  !   830501  DATE WRITTEN
  !   890831  Revised to meet new SLATEC standards
  !   930122  Added ZEXP to EXTERNAL Statement.  (RWC)
  !***END PROLOGUE  ZQCBY
  !
  !*Internal Notes:
  !   Machine constants are defined by functions I1MACH and D1MACH.
  !
  !   The parameter MQC can have values 1 (the default) for a faster,
  !   less definitive test or 2 for a slower, more definitive test.
  !
  !**End
  !
  !  Set test complexity parameter.
  !
  INTEGER MQC
  PARAMETER (MQC=1)
  !
  !  Declare arguments.
  !
  INTEGER Lun , Kprint , Ipass
  !
  !  Declare external functions.
  !
  INTEGER I1MACH
  REAL(8) :: D1MACH , ZABS
  EXTERNAL I1MACH , D1MACH , ZABS , ZEXP
  !
  !  Declare local variables.
  !
  REAL(8) :: cipr , cipi , coe1r , coe1i , coe2r , coe2i , csgnr , &
    csgni , cspnr , cspni , cwr , cwi , cwrkr , cwrki , vr , &
    vi , wr , wi , yr , yi , zr , zi , znr , zni
  REAL(8) :: aa , ab , aer , ai , alim , ar , arg , atol , av , cc , &
    ct , dig , elim , eps , er , ertol , ffnu , film , fnu , &
    fnul , hpi , pi , ptr , r , rhpi , rl , rm , r1m4 , &
    r1m5 , r2 , slak , st , sti , str , t , tol , ts , xnu
  INTEGER i , icase , ierr , ifnu , il , ir , irb , it , itl , i4 , k , &
    kdo , keps , kk , kode , k1 , k2 , lflg , mflg , n , nl , nu , &
    nul , nz , nz1 , nz2
  DIMENSION aer(20) , cipr(4) , cipi(4) , cwrkr(20) , cwrki(20) , kdo(20) , &
    keps(20) , t(20) , vr(20) , vi(20) , wr(20) , wi(20) , xnu(20) , &
    yr(20) , yi(20)
  DATA cipr(1) , cipi(1) , cipr(2) , cipi(2) , cipr(3) , cipi(3) , cipr(4) , &
    cipi(4)/1.0D0 , 0.0D0 , 0.0D0 , 1.0D0 , -1.0D0 , 0.0D0 , 0.0D0 , &
    -1.0D0/
  !
  !***FIRST EXECUTABLE STATEMENT  ZQCBY
  IF ( Kprint>=2 ) THEN
    WRITE (Lun,99001)
    99001   FORMAT (' QUICK CHECK ROUTINE FOR THE Y BESSEL FUNCTION FROM ','ZBESY'/)
  ENDIF
  !-----------------------------------------------------------------------
  !     Set parameters related to machine constants.
  !     TOL is the approximate unit roundoff limited to 1.0D-18.
  !     ELIM is the approximate exponential over- and underflow limit.
  !     exp(-ELIM).lt.exp(-ALIM)=exp(-ELIM)/TOL    and
  !     exp(ELIM).gt.exp(ALIM)=exp(ELIM)*TOL       are intervals near
  !     underflow and overflow limits where scaled arithmetic is done.
  !     RL is the lower boundary of the asymptotic expansion for large Z.
  !     DIG = number of base 10 digits in TOL = 10**(-DIG).
  !     FNUL is the lower boundary of the asymptotic series for large FNU.
  !-----------------------------------------------------------------------
  r1m4 = D1MACH(4)
  tol = MAX(r1m4,1.0D-18)
  atol = 100.0D0*tol
  aa = -LOG10(r1m4)
  k1 = I1MACH(12)
  k2 = I1MACH(13)
  r1m5 = D1MACH(5)
  k = MIN(ABS(k1),ABS(k2))
  elim = 2.303D0*(k*r1m5-3.0D0)
  ab = aa*2.303D0
  alim = elim + MAX(-ab,-41.45D0)
  dig = MIN(aa,18.0D0)
  fnul = 10.0D0 + 6.0D0*(dig-3.0D0)
  rl = 1.2D0*dig + 3.0D0
  slak = 3.0D0 + 4.0D0*(-LOG10(tol)-7.0D0)/11.0D0
  slak = MAX(slak,3.0D0)
  ertol = tol*10.0D0**slak
  rm = 0.5D0*(alim+elim)
  rm = MIN(rm,200.0D0)
  rm = MAX(rm,rl+10.0D0)
  r2 = MIN(rm,fnul)
  IF ( Kprint>=2 ) THEN
    WRITE (Lun,99002)
    99002   FORMAT (' PARAMETERS'/5X,'TOL ',8X,'ELIM',8X,'ALIM',8X,'RL  ',8X,'FNUL',&
      8X,'DIG')
    WRITE (Lun,99003) tol , elim , alim , rl , fnul , dig
    99003   FORMAT (1X,6D12.4/)
  ENDIF
  !-----------------------------------------------------------------------
  !     Set other constants needed in the tests.
  !-----------------------------------------------------------------------
  hpi = 2.0D0*ATAN(1.0D0)
  rhpi = 1.0D0/hpi
  pi = hpi + hpi
  !-----------------------------------------------------------------------
  !     Generate angles for construction of complex Z to be used in tests.
  !-----------------------------------------------------------------------
  !     KDO(K), K = 1,IL  determines which of the IL angles in -PI to PI
  !     are used to compute values of Z.
  !       KDO(K) = 0  means that the index K will be used for one or two
  !                   values of Z, depending on the choice of KEPS(K)
  !              = 1  means that the index K and the corresponding angle
  !                   will be skipped
  !     KEPS(K), K = 1,IL determines which of the angles get incremented
  !     up and down to put values of Z in regions where different
  !     formulae are used.
  !       KEPS(K)  = 0  means that the angle will be used without change
  !                = 1  means that the angle will be incremented up and
  !                   down by EPS
  !     The angles to be used are stored in the T(I) array, I = 1,ITL.
  !-----------------------------------------------------------------------
  IF ( MQC/=2 ) THEN
    nl = 2
    il = 5
    DO i = 1 , il
      keps(i) = 0
      kdo(i) = 0
    ENDDO
    kdo(5) = 1
    nul = 5
    xnu(1) = 0.0D0
    xnu(2) = 1.0D0
    xnu(3) = 2.0D0
    xnu(4) = 0.5D0*fnul
    xnu(5) = fnul + 1.2D0
  ELSE
    nl = 4
    il = 13
    DO i = 1 , il
      kdo(i) = 0
      keps(i) = 0
    ENDDO
    kdo(2) = 1
    kdo(6) = 1
    kdo(8) = 1
    kdo(11) = 1
    kdo(12) = 1
    kdo(13) = 1
    keps(3) = 1
    keps(4) = 1
    keps(5) = 1
    keps(9) = 1
    nul = 6
    xnu(1) = 0.0D0
    xnu(2) = 0.6D0
    xnu(3) = 1.3D0
    xnu(4) = 2.0D0
    xnu(5) = 0.5D0*fnul
    xnu(6) = fnul + 1.2D0
  ENDIF
  i = 2
  eps = 0.01D0
  film = il - 1
  t(1) = -pi + eps
  DO k = 2 , il
    IF ( kdo(k)==0 ) THEN
      t(i) = pi*(-il+2*k-1)/film
      IF ( keps(k)/=0 ) THEN
        ts = t(i)
        t(i) = ts - eps
        i = i + 1
        t(i) = ts + eps
      ELSE
        i = i + 1
      ENDIF
    ENDIF
  ENDDO
  itl = i - 1
  !-----------------------------------------------------------------------
  !     Test values of Z in -PI/2.lt.arg(Z).le.PI
  !-----------------------------------------------------------------------
  IF ( Kprint>=2 ) THEN
    WRITE (Lun,99004)
    99004   FORMAT (' CHECKS IN THE (Z,FNU) SPACE')
  ENDIF
  lflg = 0
  DO kode = 1 , 2
    DO n = 1 , nl
      DO nu = 1 , nul
        !-----------------------------------------------------------------------
        !     Construct values which will be used to set
        !           COE1 = exp(i*(FNU+1)*PI/2) and
        !           COE2 = (2/pi)*exp(-i*FNU*PI/2).
        !-----------------------------------------------------------------------
        fnu = xnu(nu)
        ifnu = INT(fnu)
        ffnu = fnu - ifnu
        arg = hpi*ffnu
        csgnr = COS(arg)
        csgni = SIN(arg)
        i4 = MOD(ifnu,4) + 1
        str = csgnr*cipr(i4) - csgni*cipi(i4)
        csgni = csgnr*cipi(i4) + csgni*cipr(i4)
        csgnr = str
        cspnr = csgnr*rhpi
        cspni = -csgni*rhpi
        !---------- CSGN=CSGN*CI in CQCBY
        str = -csgni
        csgni = csgnr
        csgnr = str
        DO icase = 1 , 3
          irb = MIN(2,icase)
          DO ir = irb , 4
            !-------------- switch (icase)
            SELECT CASE (icase)
              CASE (2)
                r = (2.0D0*(4-ir)+r2*(ir-1))/3.0D0
              CASE (3)
                IF ( r2>=rm ) EXIT
                r = (r2*(4-ir)+rm*(ir-1))/3.0D0
              CASE DEFAULT
                r = (eps*(4-ir)+2.0D0*(ir-1))/3.0D0
            END SELECT
            !-------------- end switch
            DO it = 1 , itl
              ct = COS(t(it))
              st = SIN(t(it))
              IF ( ABS(ct)<atol ) ct = 0.0D0
              IF ( ABS(st)<atol ) st = 0.0D0
              zr = r*ct
              zi = r*st
              CALL ZBESI(zr,zi,fnu,kode,n,wr,wi,nz2,ierr)
              !---------------- Underflow in ZBESI - skip test for this case.
              IF ( nz2==0 ) THEN
                CALL ZBESK(zr,zi,fnu,kode,n,yr,yi,nz1,ierr)
                !---------------- Underflow in ZBESK - skip test for this case.
                IF ( nz1==0 ) THEN
                  znr = -zi
                  zni = zr
                  CALL ZBESY(znr,zni,fnu,kode,n,vr,vi,nz,cwrkr,cwrki,ierr)
                  !---------------- Underflow in ZBESY - skip test for this case.
                  IF ( nz==0 ) THEN
                    coe1r = csgnr
                    coe1i = csgni
                    coe2r = cspnr
                    coe2i = cspni
                    IF ( kode==2 ) THEN
                      !------------------ Adjust scale for I and K functions.
                      cc = -zr - ABS(zr)
                      IF ( cc>(-alim) ) THEN
                        znr = cc
                        zni = -zi
                        CALL ZEXP(znr,zni,str,sti)
                        ptr = str*coe2r - sti*coe2i
                        coe2i = str*coe2i + sti*coe2r
                        coe2r = ptr
                      ELSE
                        !-------------------- Scaling problem - skip test for this case
                        coe2r = 0.0D0
                        coe2i = 0.0D0
                        CYCLE
                      ENDIF
                    ENDIF
                    DO kk = 1 , n
                      str = yr(kk)*coe2r - yi(kk)*coe2i
                      yi(kk) = yr(kk)*coe2i + yi(kk)*coe2r
                      yr(kk) = str
                      str = wr(kk)*coe1r - wi(kk)*coe1i
                      wi(kk) = wr(kk)*coe1i + wi(kk)*coe1r
                      wr(kk) = str
                      str = -coe1i
                      coe1i = coe1r
                      coe1r = str
                      str = coe2i
                      coe2i = -coe2r
                      coe2r = str
                    ENDDO
                    !-----------------------------------------------------------------------
                    !     Compare Y(ZN,FNU) with COE1*I(Z,FNU)-COE2*K(Z,FNU).
                    !-----------------------------------------------------------------------
                    mflg = 0
                    DO i = 1 , n
                      ab = fnu + i - 1
                      aa = MAX(0.5D0,ab)
                      cwr = wr(i) - yr(i)
                      cwi = wi(i) - yi(i)
                      av = ZABS(vr(i),vi(i))
                      ar = cwr - vr(i)
                      ai = cwi - vi(i)
                      er = ZABS(ar,ai)
                      IF ( av/=0.0D0 ) THEN
                        IF ( zni/=0.0D0 ) THEN
                          er = er/av
                        ELSEIF ( znr>0.0D0 ) THEN
                          IF ( DABS(znr)<aa ) er = er/av
                        ELSEIF ( DABS(ffnu-0.5D0)<0.125D0 ) THEN
                          IF ( DABS(znr)<aa ) er = er/av
                        ELSE
                          er = er/av
                        ENDIF
                      ENDIF
                      aer(i) = er
                      IF ( er>ertol ) mflg = 1
                    ENDDO
                    IF ( mflg/=0 ) THEN
                      IF ( lflg==0 ) THEN
                        IF ( Kprint>=2 ) THEN
                          WRITE (Lun,99005) ertol
                          99005                         FORMAT (/' CASES WHICH VIOLATE THE RELATIVE ',&
                            'ERROR TEST WITH ERTOL = ',D12.4/)
                          WRITE (Lun,99006)
                          99006                         FORMAT (' INPUT TO ZBESY   ZN, FNU, KODE, N')
                        ENDIF
                        IF ( Kprint>=3 ) THEN
                          WRITE (Lun,99007)
                          99007                         FORMAT (' COMPARE Y(ZN,FNU) WITH COE1*I(Z,FNU)',&
                            '-COE2*K(Z,FNU)')
                          WRITE (Lun,99008)
                          99008                         FORMAT (' Z = ZN*EXP(-i*PI/2)'/&
                            ' COE1 = EXP(i*(FNU+1)*PI/2)  ',&
                            ' COE2 = (2/PI)*EXP(-i*FNU*PI/2)')
                          WRITE (Lun,99009)
                          99009                         FORMAT (' RESULTS FROM ZBESY   V(KK)'/9X,&
                            'FROM ZBESI   W(KK)'/9X,&
                            'FROM ZBESK   Y(KK)')
                          WRITE (Lun,99010)
                          99010                         FORMAT (' TEST CASE INDICES   IR, IT, ICASE'/)
                        ENDIF
                      ENDIF
                      lflg = lflg + 1
                      IF ( Kprint>=2 ) THEN
                        WRITE (Lun,99011) znr , zni , fnu , kode , n
                        99011                       FORMAT ('   INPUT:   ZN=',2D12.4,3X,'FNU=',D12.4,3X,&
                          'KODE=',I3,3X,'N=',I3)
                      ENDIF
                      IF ( Kprint>=3 ) THEN
                        WRITE (Lun,99012) (aer(k),k=1,n)
                        99012                       FORMAT ('   ERROR:   AER(K)=',4D12.4)
                        WRITE (Lun,99013) zr , zi , coe1r , coe1i , coe2r , &
                          coe2r
                        99013                       FORMAT (12X,'Z=',2D12.4/12X,'COE1=',2D12.4,3X,&
                          'COE2=',2D12.4)
                        kk = MAX(nz1,nz2) + 1
                        kk = MIN(n,kk)
                        WRITE (Lun,99014) vr(kk) , vi(kk) , wr(kk) , wi(kk)&
                          , yr(kk) , yi(kk)
                        99014                       FORMAT (' RESULTS:   V(KK)=',2D12.4/12X,'W(KK)=',&
                          2D12.4/12X,'Y(KK)=',2D12.4)
                        WRITE (Lun,99015) ir , it , icase
                        99015                       FORMAT ('    CASE:   IR=',I3,3X,'IT=',I3,3X,&
                          'ICASE=',I3/)
                      ENDIF
                    ENDIF
                  ENDIF
                ENDIF
              ENDIF
            ENDDO
          ENDDO
        ENDDO
      ENDDO
    ENDDO
  ENDDO
  IF ( Kprint>=2 ) THEN
    IF ( lflg==0 ) THEN
      WRITE (Lun,99016)
      99016     FORMAT (' QUICK CHECKS OK')
    ELSE
      WRITE (Lun,99017) lflg
      99017     FORMAT (' ***',I5,' FAILURE(S) FOR ZBESY IN THE (Z,FNU) ','PLANE')
    ENDIF
  ENDIF
  Ipass = 0
  IF ( lflg==0 ) Ipass = 1
  IF ( Ipass==1.AND.Kprint>=2 ) THEN
    WRITE (Lun,99018)
    99018   FORMAT (/' ****** ZBESY  PASSED ALL TESTS  ******'/)
  ENDIF
  IF ( Ipass==0.AND.Kprint>=1 ) THEN
    WRITE (Lun,99019)
    99019   FORMAT (/' ****** ZBESY  FAILED SOME TESTS ******'/)
  ENDIF
END SUBROUTINE ZQCBY
